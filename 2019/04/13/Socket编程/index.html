<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Socket编程 | MyBlog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Socket编程</h1><a id="logo" href="/.">MyBlog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Socket编程</h1><div class="post-meta"><a href="/2019/04/13/Socket编程/#comments" class="comment-count"></a><p><span class="date">Apr 13, 2019</span><span><a href="/categories/Network/" class="category">Network</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><hr>
<h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><h3 id="1-1-OSI模型"><a href="#1-1-OSI模型" class="headerlink" title="1.1 OSI模型"></a>1.1 OSI模型</h3><p><img src="/2019/04/13/Socket编程/1549453424679.png" alt="Alt text"><br>Socket API位于上三层和下四层之间。<br>理由：</p>
<ol>
<li>上三层主要处理应用逻辑，对通信细节了解不多；下三层主要对应用了解不多，但是处理所有的通信细节。(发送数据，等待确认，给无序到达的数据排序，计算并验证校验和)</li>
<li>上三层构成用户进程，底下四层作为操作系统内核一部分提供。</li>
</ol>
<p>所以在这个地方设立API</p>
<blockquote>
<p>TCP和UDP之间的间隙表明网络应用绕过传输层直接使用IPV4和v6是有可能的，这是所谓的raw socket.</p>
</blockquote>
<h2 id="2-TCP、UDP、SCTP"><a href="#2-TCP、UDP、SCTP" class="headerlink" title="2. TCP、UDP、SCTP"></a>2. TCP、UDP、SCTP</h2><h3 id="2-1-协议介绍"><a href="#2-1-协议介绍" class="headerlink" title="2.1 协议介绍"></a>2.1 协议介绍</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ol>
<li>提供Server和Client之间的连接</li>
<li>提供可靠性：要求收到ACK，失败重传，多次才放弃。</li>
<li>含有估算RTT的算法，持续估算一个给定连接的RTT</li>
<li>通过给每个字节关联一个序列号对数据排序。</li>
<li>提供流量控制：告知对端一次能够接收到多少数据。</li>
<li>全双工通信</li>
</ol>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ol>
<li>缺乏可靠性：没有重传，确认，序列号，RTT估算。</li>
<li>有一个数据包长度。（TCP面向流没有记录边界）</li>
<li>无连接</li>
<li>可以全双工</li>
<li>没有流量控制</li>
</ol>
<h4 id="SCTP"><a href="#SCTP" class="headerlink" title="SCTP"></a>SCTP</h4><p><img src="/2019/04/13/Socket编程/1549728975766.png" alt="Alt text"></p>
<h3 id="2-2-TCP详细说明"><a href="#2-2-TCP详细说明" class="headerlink" title="2.2 TCP详细说明"></a>2.2 TCP详细说明</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>建立一个TCP连接会发生下面</p>
<ol>
<li>Server准备好接受连接（<strong>被动打开</strong>），<code>socket,bind,listen</code>完成。</li>
<li>Client通过调用<code>connect</code>发起<strong>主动打开</strong>，这导致客户TCP发送一个SYN（同步）分节，通常SYN分节不携带数据，其所在的IP数据报只有一个IP首部，一个TCP首部和可能的TCP选项。<strong>(SYN J)</strong></li>
<li>Server必须ACK Client的SYN，同时自己也得发送一个SYN分节（Server在同一连接发送的数据初始序列号）。<strong>（ACK J+1和SYN K）</strong></li>
<li>Client必须确认Server的SYN <strong>(ACK K+1)</strong>。<br>这种交换至少需要3个分组，称为三路握手。<br><img src="/2019/04/13/Socket编程/1549477828174.png" alt="Alt text"><h4 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h4>一个SYN可以含有多个TCP选项</li>
</ol>
<ul>
<li>MSS(最大分节大小): 发送端使用接收端的MSS值作为发送的最大分节大小。</li>
<li>窗口规模: TCP连接任何一端都能通告对端的最大窗口大小是65535。</li>
<li>时间戳选项: 高速连接必要，无需关心。</li>
</ul>
<h4 id="TCP连接终止"><a href="#TCP连接终止" class="headerlink" title="TCP连接终止"></a>TCP连接终止</h4><p>终止一个连接发生:</p>
<ol>
<li>某个应用先调用close,<strong>主动关闭</strong>，该端的TCP发送一个FIN分节，表示数据发送完毕。</li>
<li>接受到这个FIN的对端执行<strong>被动关闭</strong>，这个FIN由TCP确认。接受作为一个文件结束符(EOF)传递给接收端应用程序（放在任何其他数据后）。</li>
<li>一段时间后接受到这个文件结束符的应用进程将调用close关闭它的Socket。这导致它的TCP也发送一个FIN。</li>
<li>接收最后这个FIN的原发送端TCP(即执行主动关闭那一端)确认这个FIN。</li>
</ol>
<p><img src="/2019/04/13/Socket编程/1549507883044.png" alt="Alt text"></p>
<blockquote>
<p>每个方向都需要一个FIN和一个ACK，因此通常为4个分节。但是某些情况1的FIN随数据一起发送，2和3的分节都出自被动关闭的一段，可能被合并为一个分节。<br><strong>并不是所有的情况都是客户主动关闭，在（HTTP/1.0）服务器执行主动关闭。</strong></p>
</blockquote>
<h4 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h4><p><img src="/2019/04/13/Socket编程/1549508427057.png" alt="Alt text"><br><strong>图中展示了TCP的11种状态，可使用netstat显示，它是调试C/S应用时很有用的工具。</strong></p>
<h4 id="观察分组"><a href="#观察分组" class="headerlink" title="观察分组"></a>观察分组</h4><p><img src="/2019/04/13/Socket编程/1549508648790.png" alt="Alt text"></p>
<blockquote>
<p>图中的Client通告一个536的MSS(表明Client只实现了最小重组缓冲区)，Server通告一个1460的MSS(以太网IPv4的典型值)。不同方向上的MSS不同不成问题。</p>
</blockquote>
<ol>
<li>Server对Client的SYN的ACK是伴随应答发送的，这种做法称为捎带(通常在应答小于200ms)。如果Server用时更长，则是先ACK，后应答。</li>
<li>执行主动关闭的一端，进入TIME_WAIT状态。</li>
<li>如果只是发送单个分节请求和接受一个单分节的应答，那么使用TCP有8个分节开销。如果改用UDP只需要交换两个分组，一个承载请求，一个承载应答。</li>
<li>但是会丧失可靠性，要通过UDP应用层保证，包括拥塞控制也由UDP处理。</li>
</ol>
<h4 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h4><p>主动关闭一端停留在这个状态持续时间是最长分节生命期(MSL)的两倍，有时称为2MSL。任何TCP实现都必须为MSL选择一个值。(具有最大跳限255的分组在网络中存在时间不可能超过MSL)。<br>这个状态存在的理由</p>
<ol>
<li>可靠地实现TCP的全双工连接的终止</li>
<li>允许老的重复分节在网络中消失</li>
</ol>
<ul>
<li>第一原因是因为主动关闭的一端最后的ACK可能丢失，TIME_WAIT保留状态信息，重新发送ACK。</li>
<li>第二原因是防止老的连接的重复分组称为新的连接的化身，因为TIME_WAIT是MSL的两倍，这样就足够让某个方向上的分组最多存活MSL秒被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。</li>
</ul>
<h4 id="端口号和套接字对"><a href="#端口号和套接字对" class="headerlink" title="端口号和套接字对"></a>端口号和套接字对</h4><p><strong>端口号</strong><br>任何时候，多个进程可能同时使用TCP、UDP和SCTP这3种传输层协议的一种。这3种协议都使用16位整数的端口号区分进程。<br>例如，支持FTP的任何TCP实现都把21分配给FTP Server。TFTP的Server UDP实现端口号69。<br>而客户使用的是短期存活的临时端口，由传输层协议自动赋予用户，不关心端口，只要唯一。<br>端口号划分如下</p>
<ul>
<li>0-1023 众所周知端口，保留端口，必须由超级用户使用</li>
<li>1024-49151 已登记的端口</li>
<li>49152-65535 临时端口<br><strong>套接字对</strong><br>一个TCP连接的SocketPar是一个定义该连接的四元组(本地ip，本地端口，外地ip，外地端口)。套接字对唯一标识一个网络上的每个TCP连接。</li>
</ul>
<h4 id="TCP端口号和并发服务器"><a href="#TCP端口号和并发服务器" class="headerlink" title="TCP端口号和并发服务器"></a>TCP端口号和并发服务器</h4><p>并发Server使用循环来派生子进程处理每个新的连接。<br>Server被动打开<br><img src="/2019/04/13/Socket编程/1549724304471.png" alt="Alt text"><br>使用(<em> :21, </em> :  *)指出服务器的套接字对，称为监听套接字。<br>现在在IP:206.168.112.219启动第一个客户，对12.106.32.254执行主动打开。<br><img src="/2019/04/13/Socket编程/1549724521654.png" alt="Alt text"><br>当Server接收这个客户的连接，它fork一个自身的副本，让子进程处理客户的请求。<br><img src="/2019/04/13/Socket编程/1549724629397.png" alt="Alt text"><br>下一步假设在客户主机另有一个客户请求Server<br><img src="/2019/04/13/Socket编程/1549724702042.png" alt="Alt text"></p>
<blockquote>
<p>不同点：客户端{-:本地端口2,-:-},服务器{-:-,-:外地端口2}。这时候使用新的1501端口。<br>TCP无法仅仅查看目的端口号来分离外来的分节到不同的端点。必须查看4个元素才能确定哪个端点接收某个到来的分节。</p>
</blockquote>
<h4 id="缓冲区大小和限制"><a href="#缓冲区大小和限制" class="headerlink" title="缓冲区大小和限制"></a>缓冲区大小和限制</h4><table>
<thead>
<tr>
<th style="text-align:left">协议</th>
<th style="text-align:right">数据包大小</th>
<th style="text-align:center">备注</th>
<th style="text-align:center">要求最小MTU</th>
<th style="text-align:center">分片</th>
<th style="text-align:center">最小重组区大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IPV4</td>
<td style="text-align:right">65535B</td>
<td style="text-align:center">包含v4首部</td>
<td style="text-align:center">68B(20B首部+40B选项+8B片段偏移)</td>
<td style="text-align:center">主机和转发的路由器</td>
<td style="text-align:center">576B</td>
</tr>
<tr>
<td style="text-align:left">IPV6</td>
<td style="text-align:right">65575B</td>
<td style="text-align:center">包含40B的v6首部，净负荷65535B</td>
<td style="text-align:center">1280B</td>
<td style="text-align:center">68B(20B首部+40B选项+8B片段偏移)</td>
<td style="text-align:center">主机</td>
<td>1500B</td>
</tr>
</tbody>
</table>
<ul>
<li>MTU:以太网1500B，两个主机相反方向上MTU不一致。</li>
<li>当IP数据包&gt;链路MTU时分片，到达目的的时重组。</li>
<li>对于IPV4 当df=1，不分片。</li>
<li>以太网中ipv4的MSS=1460(最大65535)，ipv6的MSS=1440。<br><img src="/2019/04/13/Socket编程/1549726558048.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1549726574233.png" alt="Alt text"></li>
</ul>
<h4 id="TCP输出"><a href="#TCP输出" class="headerlink" title="TCP输出"></a>TCP输出</h4><p>某个应用进程写数据到TCP socket如下。<br>当write被调用时<br><img src="/2019/04/13/Socket编程/1549727543899.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1549727595773.png" alt="Alt text"></p>
<blockquote>
<p>对端TCP必须确认收到的数据，伴随对端的ACK到达，才能丢弃缓冲区已经确认的数据。<br>本端TCP以MSS大小及更小的块发送到IP，目的是避免分片。如果链路层输出队列满，错误向上传递到TCP然后重传。</p>
</blockquote>
<p>####UDP输出<br>某个应用进程写数据到UDP socket如下。<br><img src="/2019/04/13/Socket编程/1549728123270.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1549727964951.png" alt="Alt text"></p>
<blockquote>
<p>socket缓冲区并不存在，因为UDP不可靠。</p>
</blockquote>
<p>####常见Internet协议<br><img src="/2019/04/13/Socket编程/1549728253653.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1549728207915.png" alt="Alt text"></p>
<h2 id="3-套接字编程简介"><a href="#3-套接字编程简介" class="headerlink" title="3. 套接字编程简介"></a>3. 套接字编程简介</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>从套接字地址开始，它可以在两个方向上传递：进程到内核，内核到进程。内核到进程方向传递是value-&gt;result。<br><strong>地址转换函数</strong>在地址的文本表达和它们存放在套接字地址结构中的二进制值之间转换。ipv4大多数情况使用<code>inet_addr</code>和<code>inet_ntoa</code>两个函数。新函数<code>inet_pton</code>和<code>inet_ntop</code>同样适用v4和v6。<br>为了消除这个函数的协议相关性，使用sock_开头的函数。</p>
<h3 id="3-2-套接字地址结构"><a href="#3-2-套接字地址结构" class="headerlink" title="3.2 套接字地址结构"></a>3.2 套接字地址结构</h3><h4 id="IPv4套接字结构"><a href="#IPv4套接字结构" class="headerlink" title="IPv4套接字结构"></a>IPv4套接字结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;netinet/in.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">	<span class="keyword">in_addr_t</span> s_addr;    <span class="comment">/* 32位 IPV4 地址 */</span></span><br><span class="line">&#125;;  								<span class="comment">/* 网络字节序 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> sin_len ;<span class="comment">/* 结构的长度(16) */</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* AF_INET */</span></span><br><span class="line">	<span class="keyword">in_port_t</span> sin_port; <span class="comment">/* 16位TCP和UDP端口号 */</span></span><br><span class="line">								<span class="comment">/* 网络字节序 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* 32位 IPV4 地址 */</span> </span><br><span class="line">								<span class="comment">/* 网络字节序 */</span></span><br><span class="line">	<span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* 未使用 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Socket编程/1549765727223.png" alt="Alt text"></p>
<blockquote>
<ul>
<li>sa_family_t:支持长度字段，uint8_t;不支持长度uint16_t。</li>
<li>in_addr_t: uint32_t</li>
<li>in_port_t: uint16_t<br>32位ip地址有两种访问方法：in_addr结构和int_addr_t(uint32_t)。<br>套接字地址结构仅在给定主机使用，不在主机之间传递</li>
</ul>
</blockquote>
<h4 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;sys/socket.h&gt;</span><br><span class="line">struct sockaddr&#123;</span><br><span class="line">	uint8_t sa_len;</span><br><span class="line">	sa_family_t sa_family;     /* 地址族:AF_xxx value*/</span><br><span class="line"> 	char sa_data[14];          /* 协议相关的地址 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int bind(int, struct sockaddr*, socklen_t);  /* 这要求对套接字地址的指针进行强制转换 */</span><br><span class="line"></span><br><span class="line">struct sockaddr_in serv; /* ipv4 地址结构 */</span><br><span class="line">bind(sockfd,(struct sockaddr*)serv,sizeof(serv));</span><br></pre></td></tr></table></figure>
<h4 id="IPv6套接字结构"><a href="#IPv6套接字结构" class="headerlink" title="IPv6套接字结构"></a>IPv6套接字结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;netinet/in.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>&#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> s6_addr[<span class="number">16</span>];    <span class="comment">/* 128位 IPV6 地址 */</span></span><br><span class="line">&#125;;</span><br><span class="line">  								<span class="comment">/* 网络字节序 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIN6_LEN   <span class="comment">/* 编译期测试需要 */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> sin6_len ;<span class="comment">/* 结构的长度(28) */</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sin6_family; <span class="comment">/* AF_INET6 */</span></span><br><span class="line">	<span class="keyword">in_port_t</span> sin6_port; <span class="comment">/* 传输层端口号 */</span></span><br><span class="line">								<span class="comment">/* 网络字节序 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>  sin6_flowinfo;   <span class="comment">/*流信息，未定义*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in6_addrs</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* 128位 IPV6 地址 */</span> </span><br><span class="line">								<span class="comment">/* 网络字节序 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sin6_scope_id; <span class="comment">/* 接口集合 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果支持字段长度，SIN6_LEN常值必须定义</li>
<li>结构中字段的先后顺序进行过编排，64位对齐</li>
<li>sin6_flowinfo分成两个字段<ul>
<li>低序20位flow label</li>
<li>高序12位保留</li>
</ul>
</li>
<li>sin6_scope_id标识范围</li>
</ul>
</blockquote>
<h4 id="套接字地址比较"><a href="#套接字地址比较" class="headerlink" title="套接字地址比较"></a>套接字地址比较</h4><p><img src="/2019/04/13/Socket编程/1549769117901.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1549769193047.png" alt="Alt text"><br><strong>前两种固定长度，后两种可变长度</strong></p>
<h3 id="3-3-值-结果参数"><a href="#3-3-值-结果参数" class="headerlink" title="3.3 值-结果参数"></a>3.3 值-结果参数</h3><p>当往一个socket函数传递套接字地址结构时，使用引用的方式传递，传递方式取决于<strong>方向</strong>。</p>
<ol>
<li>从进程–&gt;内核:<code>bind</code>、<code>connect</code>和<code>sendto</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">connect(sockfd,(SA*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Socket编程/1549769958401.png" alt="Alt text"></p>
<ol start="2">
<li>从内核–&gt;进程:<code>accept</code>、<code>recvfrom</code>、<code>getsockname</code>和<code>getpeername</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cli</span>;</span>   <span class="comment">/*unix domain*/</span></span><br><span class="line"><span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">len = <span class="keyword">sizeof</span>(cli);   <span class="comment">/*长度是一个value*/</span></span><br><span class="line">getpeername(unixfd,(SA*) &amp;cli, &amp;len);  <span class="comment">/*传递两个指针*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>这里把整数改成指针的原因是:当函数被调用时，结构大小是一个<strong>值(value)</strong>，它告诉内核该结构大大小，这样内核在写该结构时不至于越界；当函数返回时，结构大小是一个<strong>结果(result)</strong>，它告诉进程内核在该结构中究竟存储了多少信息。这种类型的参数称为<strong>value-result参数</strong>。<br><img src="/2019/04/13/Socket编程/1549867815373.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1549868075047.png" alt="Alt text"></p>
</blockquote>
<h3 id="3-4-字节排序函数"><a href="#3-4-字节排序函数" class="headerlink" title="3.4 字节排序函数"></a>3.4 字节排序函数</h3><p><strong>小端(little-endian)字节序</strong>:将低序字节存储在起始地址。<br><strong>大端(big-endian)字节序</strong>:将高序字节存储在起始地址。<br><img src="/2019/04/13/Socket编程/1549868302287.png" alt="Alt text"><br>因为每个TCP分节都有16位的端口和32位的ipv4地址，发送协议栈和接收协议栈必须就这些多字节字段各个字节的传送顺序达成一致。网际协议使用<strong>大端字节序</strong>传送多字节整数。<br>主机字节序和网络字节序的转换使用如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> host16bitvalue)</span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hot32bitvalue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> net16bitvalue)</span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> net32bitvalue)</span><br></pre></td></tr></table></figure></p>
<h3 id="3-5-字节操纵函数"><a href="#3-5-字节操纵函数" class="headerlink" title="3.5 字节操纵函数"></a>3.5 字节操纵函数</h3><p>名字以b开头的函数:用于所有支持套接字函数的OS<br>名字以mem开头的函数:支持ANSI C函数库的所有OS</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *dest,<span class="keyword">size_t</span> nbytes)</span></span>;  <span class="comment">/* 把目标字符串中指定数目的字节置为0 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *src,<span class="keyword">void</span> *dest,<span class="keyword">size_t</span> nbytes)</span></span>;<span class="comment">/* 将指定数目的字节从源字节串copy到目标字节串*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1,<span class="keyword">const</span> <span class="keyword">void</span> *ptr2,<span class="keyword">size_t</span> nbytes)</span></span>;<span class="comment">/*比较任意两个字节串，如相等返回0 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">int</span> c, <span class="keyword">size_t</span> len)</span></span>; <span class="comment">/* 把目标字符串中指定数目的字节置为c  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> nbytes)</span></span>;<span class="comment">/* 将指定数目的字节从源字节串copy到目标字节串*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span>;<span class="comment">/*比较任意两个字节串，如相等返回0,否则返回两个字符串第一个字节比大小的结果 */</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6-地址转换函数"><a href="#3-6-地址转换函数" class="headerlink" title="3.6 地址转换函数"></a>3.6 地址转换函数</h3><h4 id="inet-aton、-inet-addr和inet-ntoa函数"><a href="#inet-aton、-inet-addr和inet-ntoa函数" class="headerlink" title="inet_aton、 inet_addr和inet_ntoa函数"></a>inet_aton、 inet_addr和inet_ntoa函数</h4><p>适用于v4<br>shell输入的ip(ascll字符串) <--> 套接字地址中的ip(网络字节序的二进制值)</--></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strptr, struct in_addr *addrptr)</span></span>;<span class="comment">/*返回：若字符串有效则为1，否则为0 */</span></span><br><span class="line"><span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span> *strptr);<span class="comment">/* 返回：若字符串有效则为32位二进制网络字节序的IPv4地址，否则INADDR_NONE*/</span>(不能处理<span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span>)</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr inaddr)</span></span>;<span class="comment">/* 返回：指向一个点分十进制的指针*/</span></span><br></pre></td></tr></table></figure>
<h4 id="inet-pton和inet-ntop函数"><a href="#inet-pton和inet-ntop函数" class="headerlink" title="inet_pton和inet_ntop函数"></a>inet_pton和inet_ntop函数</h4><p>适用于v4和v6，函数的p为presentatin,n为numeric。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family,<span class="keyword">char</span>* strptr, <span class="keyword">void</span> *addrptr)</span></span>;<span class="comment">/* 返回：若成功则为1,若输入不是有效的表达格式则为0，若出错则为-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> family,<span class="keyword">void</span> *addrptr,<span class="keyword">char</span> *strptr, <span class="keyword">size_t</span> len)</span></span>;<span class="comment">/* 返回：若成功则为指向结果的指针，若出错则为NULL */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Socket编程/1549886277243.png" alt="Alt text"></p>
<p><strong>sock_ntop和相关函数</strong><br>书中使用的和协议无关的函数</p>
<h4 id="readn、written和readline函数"><a href="#readn、written和readline函数" class="headerlink" title="readn、written和readline函数"></a>readn、written和readline函数</h4><p>字节流套接字(如TCP)的read和write不同于通常的文件io。输入或输出的字节数可能比请求的数量少，然而这不是出错的状态。<br>原因在于内核中的缓冲区可能已经满了，此时会再次调用read或write来输出剩余的字节。<br>为了不让实现返回不足的字节计数值，使用written来取代write。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unp.h"</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> readn(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> written(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *size buff, <span class="keyword">size_t</span> nbytes);</span><br><span class="line"><span class="keyword">ssize_t</span> readline(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> maxlen);  <span class="comment">/* 均返回读或者写的字节数，若出错则为-1 */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>readline 低效，每读一个字节就调用一次read函数。需要自己实现快速地版本（实现一套缓冲机制）。<br>基于文本行的网络协议:SMTP、HTTP、FTP的连接控制协议和finger。</p>
</blockquote>
<h2 id="4-基本TCP套接字编程"><a href="#4-基本TCP套接字编程" class="headerlink" title="4. 基本TCP套接字编程"></a>4. 基本TCP套接字编程</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p><img src="/2019/04/13/Socket编程/1549955609376.png" alt="Alt text"></p>
<h3 id="4-2-socket函数"><a href="#4-2-socket函数" class="headerlink" title="4.2 socket函数"></a>4.2 socket函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">int socket(int family,int type,int protocol);   /*返回套接字描述符*/</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Socket编程/1549955582004.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1549955337475.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1549955307204.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1549955402014.png" alt="Alt text"></p>
<blockquote>
<p>对比AF_XXX和PF_XXX,<br>AF_xxx表示地址族，PF_xxx表示协议族，书中只使用地址族。</p>
</blockquote>
<h3 id="4-3-connect函数"><a href="#4-3-connect函数" class="headerlink" title="4.3 connect函数"></a>4.3 connect函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;   <span class="comment">/*成功返回0，否则-1*/</span></span><br></pre></td></tr></table></figure>
<ol>
<li>调用connect前不必bind，内核会确定地址和端口</li>
<li>TCPsocket会激发三次握手过程，且仅在连接成功或者出错才返回。</li>
<li>出错有这几种可能<ul>
<li>TCP client 没有收到ACK</li>
<li>TCP client 收到RST（复位），表示该主机在指定端口没有进程等待。(硬错误)</li>
<li>RST产生条件：目的地为某端口的SYN到达然而没服务器等待，TCP想取消一个已有连接，TCP收到一个根本不存在的连接上的分节。</li>
<li>如果在某个路由器上出现ICMP会引发软错误。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closed--&gt;syn_sent--&gt;established</span><br></pre></td></tr></table></figure>
<h3 id="4-4-bind函数"><a href="#4-4-bind函数" class="headerlink" title="4.4 bind函数"></a>4.4 bind函数</h3><p>bind函数把一个本地协议地址赋予一个套接字。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">/*成功返回0，否则-1*/</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>服务器启动时捆绑接口，一般指定端口（RPC除外，会临时分配端口）。</li>
<li>对于TCPclient，就为该套接字上发送的IP数据报指派了源IP地址。</li>
<li>对于TCPserver，就限定该socket只接收那些目的地为这个ip地址的客户连接。<br>根据结果可以如下设定<code>sin_addr</code>和<code>sin_port</code>或者<code>sin6_addr</code>和<code>sin6_port</code>。<br><img src="/2019/04/13/Socket编程/1550052356332.png" alt="Alt text"><blockquote>
<p>通配地址有<code>INADDR_ANY</code>=0指定<br>捆绑非通配地址用于在子网内让IP层接受所有目的地为任何一个别名地址的外来数据报。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">/* for ipv4 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">serv.sin6_addr = in6addr_any;  <span class="comment">/* 系统预先分配了in6addr_any的extern声明 */</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h3 id="4-5-listen函数"><a href="#4-5-listen函数" class="headerlink" title="4.5 listen函数"></a>4.5 listen函数</h3><p>listen函数仅在TCP server使用，它只做两件事。</p>
<ol>
<li>当socket函数创建套接字时，被假设为主动套接字。listen函数把它转化为监听套接字(被动套接字)，指示内核接受请求。<code>CLOSED--&gt;LISTEN</code></li>
<li>本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>; <span class="comment">/*成功返回0，否则-1*/</span></span><br></pre></td></tr></table></figure>
<p>内核为监听套接字维护两个队列：</p>
<ol>
<li>未完成连接队列：每个SYN分节对应一项：由Client发送Server，Server等待其完成三路握手。这些套接字处于<code>SYN_RCVD</code>状态。</li>
<li>已完成连接队列：每个已完成三路握手的client对应其中一项。<br><img src="/2019/04/13/Socket编程/1550055508962.png" alt="Alt text"></li>
</ol>
<p>每当未完成队列建立一项，来自监听套接字的参数就复制到即将建立的连接中，完全自动。<br><img src="/2019/04/13/Socket编程/1550055740512.png" alt="Alt text"><br>每次调用accept时，返回已完成队列的队头。如果队列为空则进程睡眠直到放入一项再唤醒。</p>
<ul>
<li>listen函数的backlog参数层被规定为两个队列总和最大值</li>
<li>berleley实现：backlog * 1.5 = 未处理队列的最大长度</li>
<li>不要把backlog设置为0</li>
<li>如果三路握手正常完成，那么一项在未完成队列停留的时间是一个RTT。</li>
<li>历来backlog设为5，但是对于如今最好设大点。</li>
<li><p>可以通过环境变量和命令行参数修改避免重新编译，可以重写一个listen函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">Listen(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> *ptr;</span><br><span class="line">	<span class="keyword">if</span>((ptr = getenv(*LISTENQ*))!=<span class="literal">NULL</span>)</span><br><span class="line">	backlog = atoi(ptr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(listen(sockfd,backlog) &lt; <span class="number">0</span>)</span><br><span class="line">   err_sys(<span class="string">"listen error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个Client SYN到达时，发现队列都满了，TCP忽略分节。等待client重发。</p>
</li>
<li>在三路握手完成后，但在Server调用accept之前到达的数据应由Server TCP排队，最大数据为相应已连接套接字的接受缓冲区大小。</li>
</ul>
<p><img src="/2019/04/13/Socket编程/1550056847371.png" alt="Alt text"></p>
<h3 id="4-6-accept函数"><a href="#4-6-accept函数" class="headerlink" title="4.6 accept函数"></a>4.6 accept函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">									<span class="comment">/*若成功返回非负描述符，出错为-1*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果accept返回成功则生成一个新的已连接描述符。一个服务器一般只建立一个监听描述符，它在服务器的生命期一直存在。内核为每个服务器进程接受的客户连接创建一个已连接套接字。当服务器完成对某个client的服务后，就关闭已连接套接字。</li>
<li><p>函数最多返回三个值：新描述符或-1，客户进程协议地址和地址大小（这两个一般为空，因为不关心）。</p>
<h3 id="4-7-fork和exec函数"><a href="#4-7-fork和exec函数" class="headerlink" title="4.7 fork和exec函数"></a>4.7 fork和exec函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line">						<span class="comment">/*子进程返回0，父进程返回子进程的ID，出错返回-1*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子进程只有一个父进程，并可以通过getppid获取父进程id，所以返回0</p>
</li>
<li>父进程有多个子进程，所以返回子进程id</li>
<li><strong>父进程调用fork前打开的所有描述符由子进程共享</strong>。父进程调用accept后fork，已连接socket在父子间共享，通常父亲关闭，子进程接着读写。</li>
</ul>
<p><strong>fork两个用法</strong></p>
<ol>
<li>一个进程创建一个自身副本，这样每个副本都可以在另一个副本工作时进行各自的操作。(网络Server常用)</li>
<li>一个进程想要执行另一个程序，首先调用fork，然后其中一个副本调用exec把自身替换成新的程序。(shell用法)</li>
<li>由现有进程调用exec替换成新的程序文件是硬盘上的exe在unix执行的唯一方法。调用exec的进程称为Call process，新程序为new program。</li>
</ol>
<blockquote>
<p>6个exec区别为</p>
<ol>
<li>带执行的程序由filename还是pathname指定</li>
<li>新程序参数是一一给出还是一个指针数组引用</li>
<li>把调用进程的环境传递给新程序还是给新程序指定新环境。</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*pathname, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*pathname, <span class="keyword">char</span>* <span class="keyword">const</span> argv[],<span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;<span class="comment">/*系统调用*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*filename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*filename, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line">									<span class="comment">/* 均返回：成功则不返回，出错-1*/</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Socket编程/1550059621533.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1550059761841.png" alt="Alt text"></p>
<blockquote>
<p>进程在调用exec前打开的描述符通常跨exec继续打开。</p>
</blockquote>
<h3 id="4-8-并发服务器"><a href="#4-8-并发服务器" class="headerlink" title="4.8 并发服务器"></a>4.8 并发服务器</h3><p>一个典型的并发服务器的轮廓</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid;</span><br><span class="line">int listenfd,connfd;</span><br><span class="line">listenfd = Socket(...);</span><br><span class="line">			/* 省略sockaddr*/</span><br><span class="line">Bind(listenfd,..);</span><br><span class="line">Listen(listenfd,LISTENEQ);</span><br><span class="line">for(;;)</span><br><span class="line">&#123;</span><br><span class="line">	connfd = Accept(listenfd,...);</span><br><span class="line">	if((pid = Fork())==0)</span><br><span class="line">	&#123;</span><br><span class="line">		Close(listenfd);  /*子进程关闭监听描述符*/</span><br><span class="line">		doit(connfd);     /*子进程处理请求*/</span><br><span class="line">  		Close(connfd);    /*子进程关闭已连接描述符*/</span><br><span class="line">		exit(0);</span><br><span class="line">&#125;</span><br><span class="line">Close(connfd);     /*父进程关闭已连接描述符*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么父进程关闭描述符后没有断开连接？<br>因为connfd的引用计数，父进程关闭后只是从2减到1，只有等于0才关闭释放。<br><img src="/2019/04/13/Socket编程/1550060388877.png" alt="Alt text"><br><img src="/2019/04/13/Socket编程/1550061570123.png" alt="Alt text"><br>并发服务器下一步是fork<br><img src="/2019/04/13/Socket编程/1550061597480.png" alt="Alt text"><br>再下一步子进程关闭监听套接字，父进程关闭已连接套接字。</p>
<h3 id="4-9-close函数"><a href="#4-9-close函数" class="headerlink" title="4.9 close函数"></a>4.9 close函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int close(int sockfd);</span><br><span class="line">									/*如成功返回0，否则返回-1*/</span><br></pre></td></tr></table></figure>
<p>close后的描述符不能再由调用进程使用<br><strong>描述符引用计数</strong><br>如果想发送fin但是不用close，可以使用shutdown函数。</p>
<h3 id="4-10-getsockname函数和getpeername函数"><a href="#4-10-getsockname函数和getpeername函数" class="headerlink" title="4.10 getsockname函数和getpeername函数"></a>4.10 getsockname函数和getpeername函数</h3><p>这两个函数返回与某个套接字相关连的本地协议地址(<code>getsockname</code>),或者返回相关的外地协议地址(<code>getpeername</code>)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * localaddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* peeraddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line">								<span class="comment">/* 成功返回0否则-1*/</span></span><br></pre></td></tr></table></figure></p>
<p>需要这两个函数的理由：</p>
<ol>
<li>TCPclient connect返回后，getsockname返回由内核赋予该连接的本地ip和本地端口号。</li>
<li>在以0号调用bind后，getsockname返回由内核赋予的本地端口号</li>
<li>getsockname可用于获取某个套接字的地址族</li>
<li>在一个以通配ip调用bind的Server上，与client连接后getsockname可以返回内核赋予该连接的本地ip地址。这样的调用中套接字必须是<strong>已连接套接字</strong>。</li>
<li>当Server由accept的某个进程通过exec执行程序时，它能获取client身份唯一途径getpeername。<br><img src="/2019/04/13/Socket编程/1550071498732.png" alt="Alt text"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	返回套接字的地址族</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unp.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockfd_to_family</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span> <span class="comment">/*不知道套接字地址结构，使用通用结构*/</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len;</span><br><span class="line">	len = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">	<span class="keyword">if</span>(getsockname(sockfd,(SA*)&amp;ss,&amp;len)&lt;<span class="number">0</span>)   <span class="comment">/*适用任何已经打开的套接字 */</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> (ss.ss_family);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="5-TCP-C-S程序实例"><a href="#5-TCP-C-S程序实例" class="headerlink" title="5. TCP C/S程序实例"></a>5. TCP C/S程序实例</h2><h3 id="5-1-目标"><a href="#5-1-目标" class="headerlink" title="5.1 目标"></a>5.1 目标</h3><p>实现一个TCP回射服务器</p>
<ol>
<li>Client从标准输入读入一行文本，并写给Server。</li>
<li>Server从网络输入读入这行文本，并回射给Client。</li>
<li>Client从网络输入读入这行回射文本，并标出用于输入和输出的函数。</li>
</ol>
<p><img src="/2019/04/13/Socket编程/1550160339038.png" alt="Alt text"></p>
<blockquote>
<p>我们把地址和端口等硬编码到代码，原因是:</p>
<ol>
<li>了解地址结构放什么内容</li>
<li>后续再后面会介绍</li>
</ol>
</blockquote>
<h3 id="5-2-TCP回射Server"><a href="#5-2-TCP回射Server" class="headerlink" title="5.2 TCP回射Server"></a>5.2 TCP回射Server</h3><h3 id="5-3-TCP回射Client"><a href="#5-3-TCP回射Client" class="headerlink" title="5.3 TCP回射Client"></a>5.3 TCP回射Client</h3><h3 id="5-4-正常启动和关闭"><a href="#5-4-正常启动和关闭" class="headerlink" title="5.4 正常启动和关闭"></a>5.4 正常启动和关闭</h3><ol>
<li><p>启动服务端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tcpserv01 &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用netstat 查看监听状态。<br><img src="/2019/04/13/Socket编程/1550827279284.png" alt="Alt text"><br>发现server正在LISTEN状态</p>
</li>
<li>启动client，并指定server ip为本地环回地址。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tcpcli01 127.0.0.1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>客户调用socket和connect，后者引起TCP三路握手的过程。当三路握手完成后，Client的connect和Serveraccept返回，连接建立。<br>客户调用str_cli函数阻塞与fgets调用。<br>Server的accept返回，服务器调用fork，子进程调用str_echo。该函数调用readline，readline调用read，而read等待客户送入一行文本期间阻塞。<br>另外Server父进程再次accept阻塞，等待下一个客户连接。<br>现在：3个进程睡眠。<br><img src="/2019/04/13/Socket编程/1550834647389.png" alt="Alt text"></p>
<ol start="4">
<li>然后输入^D(EOF符)，fgets返回nullptr，str_cli返回</li>
<li>str_cli返回到main后，main调用exit终止。</li>
<li>进程终止的部分工作是关闭所有的fd，因此socketfd由内核关闭发送FIN给Server，则TCP发送ACK，这是TCP连接终止的前一半，Server此时CLOSE_WAIT。CLient则FIN_WAIT_2</li>
<li>当Server TCP接收FIN时，Server子进程阻塞于readline，readline返回0，导致str_echo返回子进程main函数。</li>
<li>子进程调用exit终止。</li>
<li>子进程打开的socketfd开始关闭，TCP发送终止的最后两个分节:一个从Server到CLient的FIN和一个从Client到Server的ACK。至此，连接终止进入TIME_WAIT状态。</li>
<li>服务器子进程终止后时，给父进程发送SIGCHLD信号。但是父进程未捕获子进程僵死。<br><img src="/2019/04/13/Socket编程/1550836667275.png" alt="Alt text"></li>
</ol>
</blockquote>
<h3 id="5-5-POSIX信号处理"><a href="#5-5-POSIX信号处理" class="headerlink" title="5.5 POSIX信号处理"></a>5.5 POSIX信号处理</h3><p>Signal就是告知某个进程发生某个事件的通知，有时也叫<strong>软件中断</strong>。信号通常异步发生，也就是进程预先不知道信号准确发生时刻。<br>信号可以:</p>
<ul>
<li>由进程发给另一个进程</li>
<li>也可以由内核发给某个进程。<br>通过sigaction来设定信号处置，有三种选择。</li>
</ul>
<ol>
<li><code>signal handler:catch signal</code>。只要有特定的信号就被调用。但是不能捕获sigkill和sigstop</li>
<li>我们可以把信号处置设为SIG_IGN来忽略它。SIGKILL和SIGSTOP不能忽略。</li>
<li>把某个信号设为SIG_DFL来启用默认处置。</li>
</ol>
<p>可以通过编写signal函数替代sigaction。<br>如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_chld</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> stat;</span><br><span class="line">	pid = wait(&amp;stat);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"child %d terminated\n"</span>,pid);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在tcpserv2调用了该函数处理僵死的子进程*/</span></span><br></pre></td></tr></table></figure></p>
<p><strong>处理僵死进程</strong><br>僵死状态是为了维护子进程信息让父进程以后某个时候获取。信息包括子进程的进程ID、状态和资源利用信息。</p>
<p>新的server父进程调用sig_chld，wait取到子进程id和状态，返回。信号在系统阻塞于accept时父进程捕获，内核使accept返回一个enter错误。而父进程不处理该错误。</p>
<p><strong>处理中断的系统调用</strong><br>慢系统调用指：那些可能永远阻塞的系统调用，如accept，Server的read，对pipe和dev的读写。例外磁盘io一般都会返回。<br>慢系统调用在捕获信号的时候可能会返回一个EINTR错误，调用中断。<br>所有需要对这个错误进行处理。添加处理的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(connfd = accept(listenfd,(SA *)&amp;cliaddr,&amp;clilen)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		err_sys(<span class="string">"accept error"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码可以重启accept，也可用于read、write、select和open等<br>但是不能用于connect,不能重启</p>
</blockquote>
<h3 id="5-6-wait-和-waitpid-函数"><a href="#5-6-wait-和-waitpid-函数" class="headerlink" title="5.6 wait 和 waitpid 函数"></a>5.6 wait 和 waitpid 函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc)</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *statloc,<span class="keyword">int</span> options)</span><br><span class="line">						<span class="comment">/* 均返回:若成功则为pid,出错则0或-1 */</span></span><br><span class="line">pid = 已终止的子进程pid</span><br><span class="line">statloc-&gt;子进程终止状态(一个整数)<span class="comment">/*可以调用宏检查*/</span></span><br><span class="line">如果没有已终止的子进程，wait会阻塞到现有子进程第一个终止。</span><br><span class="line"></span><br><span class="line">waitpid</span><br><span class="line">pid = 向等待的Pid</span><br><span class="line">options = 允许指定选项(WNOHANG可以告知内核在没有子进程时不要阻塞)</span><br></pre></td></tr></table></figure>
<h2 id="6-I-O复用-select和poll"><a href="#6-I-O复用-select和poll" class="headerlink" title="6. I/O复用:select和poll"></a>6. I/O复用:select和poll</h2><h3 id="6-1-关于IO复用"><a href="#6-1-关于IO复用" class="headerlink" title="6.1 关于IO复用"></a>6.1 关于IO复用</h3><p>上一章写的client可以处理两个输入:标准输入和socket。<br>问题在于client阻塞于fgets调用的过程时，server会被kill。虽然TCP Server正确地给Client发送一个FIN，但是client阻塞在fgets，无法看到EOF直到从socket读入，（这阻塞了很长时间）。这需要预先告诉内核，一旦发现多个IO条件准备好就通知应用程序，这个能力称为<strong>io复用</strong>。这是由<code>select</code>和<code>poll</code>两个函数支持的。<br><strong>IO复用的网络场景</strong></p>
<ul>
<li>当client处理多个描述符,必须使用IO复用。</li>
<li>一个client同时处理多个Socket可能，只是比较少见。</li>
<li>如果TCP既要处理listenfd又要处理connfd一般用io复用</li>
<li>如果一个Server要处理多个服务或多个协议，使用IO复用<br>IO复用不止用于网络编程也用于应用程序。<h3 id="6-2-IO模型"><a href="#6-2-IO模型" class="headerlink" title="6.2 IO模型"></a>6.2 IO模型</h3><h4 id="5种io模型（Unix）"><a href="#5种io模型（Unix）" class="headerlink" title="5种io模型（Unix）"></a>5种io模型（Unix）</h4></li>
<li>阻塞io</li>
<li>非阻塞io</li>
<li>io复用(select,poll)</li>
<li>信号驱动式io(sigio)</li>
<li>异步io(aio等)<br><a href="https://stockdean.github.io/2019/02/06/%E5%90%8C%E6%AD%A5IO%E3%80%81%E5%BC%82%E6%AD%A5IO%E3%80%81%E9%98%BB%E5%A1%9EIO%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/">IO对比</a><br>同步io和异步io<br>前四种都是同步io，只有后一种是异步io。<br><img src="/2019/04/13/Socket编程/1551883814251.png" alt="Alt text"><h3 id="6-3-select函数"><a href="#6-3-select函数" class="headerlink" title="6.3 select函数"></a>6.3 select函数</h3>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有有一个或多个事件发生或经历指定时间才唤醒它。<br>我们利用select能做什么？<br><strong>告知内核在下列情况发生后才返回</strong></li>
<li>{1,4,5}中任何fd准备好读</li>
<li>{2,7}中任何fd准备好写</li>
<li>{1,4}中的任何描述符有异常条件待处理。</li>
<li>经历10.2秒</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdpl, fd_set *readset, fd_set *writeset, fd_set *expectset <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line">					<span class="comment">//如果有就绪的fd=数目，如果超时=0，如果出错=-1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec; <span class="comment">//秒</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">&#125;;</span><br><span class="line">timeout：有三种可能。</span><br><span class="line"><span class="number">1.</span>永远等待，直到有一个fd准备好io才返回。timeout==<span class="literal">nullptr</span></span><br><span class="line"><span class="number">2.</span>等待固定时间：有一个fd准备好io返回，但是不能超过timeval中的秒数和微秒数。</span><br><span class="line"><span class="number">3.</span>不等待。检查fd后立即返回，称为polling(轮询)。timeout必须指向timeval且定时器值必须为<span class="number">0</span></span><br><span class="line">timeval 不会被函数改变</span><br><span class="line">中间三个参数readset,writeset和expectset指定我们要让内核测试读、写和异常条件的描述符。</span><br><span class="line">maxfdpl参数指定待测试的fd个数，=待测试的maxfd + <span class="number">1</span>   <span class="comment">//因为fd从0开始所以 + 1</span></span><br><span class="line">支持的异常条件</span><br><span class="line"><span class="number">1.</span> 某个Socket的带外数据到达。</span><br><span class="line"><span class="number">2.</span> 某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息。</span><br><span class="line"></span><br><span class="line">如何给三个参数指定一个或多个fd？</span><br><span class="line">使用fdset(**描述符集**)，通常为一个整数数组，每个整数中的每一位对应一个描述符。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FD_ZERO(fd_set *fdset);<span class="comment">//clear所有bit</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;<span class="comment">//置1 fdset数组的fd</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;<span class="comment">//置0 fdset数组的fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *fdset)</span></span>;<span class="comment">//判断对应bit是否=1</span></span><br><span class="line"></span><br><span class="line">fd_set rset;</span><br><span class="line">FD_SET(<span class="number">1</span>,&amp;rset);</span><br><span class="line">FD_SET(<span class="number">4</span>,&amp;rset);</span><br><span class="line">FD_SET(<span class="number">5</span>,&amp;rset);</span><br></pre></td></tr></table></figure>
<p>fdset的初始化很重要，自动分配需要初始化。<br>三个描述符指针都可以设置为空(这时候可用来做sleep())，poll函数提供类似的功能。</p>
<p>使用select的两个常见错误</p>
<ul>
<li>忘记maxfdpl =maxfd + 1</li>
<li>忘记fdset是值-结果参数（每次重新调用select需要重新赋值）</li>
</ul>
<h4 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h4><p><strong>满足准备好读的情况（有一个即可）</strong></p>
<ol>
<li>该Socket接收缓冲区databytes &gt;= 低水位标记大小，返回一个大于0的值</li>
<li>该连接读半关闭(即接收了FIN的TCP连接)。不阻塞读返回0</li>
<li>listenfd且已完成的连接数不为0。这样的Socket的accept通常不阻塞。</li>
<li>有一个Socket错误待处理。对这样的Socket的read操作不阻塞并返回-1。并把errno设置成确切的错误条件。这些待处理错误也可以通过SO_ERROR套接字选项调用getsockopt获取并消除。<blockquote>
<p>接收低水位标记(Receive Low Water Mark)，是接收缓冲区的一个限制标记，当接收缓冲区中的数据字节数达到此限制时，读操作可以返回数据（数据已准备好）。</p>
</blockquote>
</li>
</ol>
<p><strong>满足准备好写的情况（有一个即可）</strong></p>
<ol>
<li>套接字的发送buff中可用空间字节数&gt;=低水位标记大小且或者Socket已连接或不需要连接。</li>
<li>该连接的写半部关闭。产生<strong>SIGPIPE</strong>信号。</li>
<li>使用非阻塞的connect的Socket已建立连接，或者connect已经以失败告终。</li>
<li>有一个错误待处理，此时不阻塞并返回-1。。并把errno设置成确切的错误条件。这些待处理错误也可以通过SO_ERROR套接字选项调用getsockopt获取并消除。<br><strong>满足异常条件</strong><br>同上一节的说明，</li>
</ol>
<blockquote>
<p>某个Socket发生错误时，会由select标记为既可读又可写<br>低水位目的：允许应用进程控制select返回可读和可写条件前有多少数据可读或有多大空间可写。<br>任何UDP只要发送低水位标记小于等于发送缓冲区大小总可写。因为不需要连接。<br><img src="/2019/04/13/Socket编程/1552057227158.png" alt="Alt text"></p>
</blockquote>
<p>select最大描述符数约为256，poll能提供更大连接数。</p>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/04/13/剑指offer刷题笔记（一）/" class="pre">剑指offer刷题笔记（一）</a><a href="/2019/04/13/Effective C++ Note/" class="next">Effective C++ Note</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket编程"><span class="toc-text">Socket编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-绪论"><span class="toc-text">1. 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-OSI模型"><span class="toc-text">1.1 OSI模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-TCP、UDP、SCTP"><span class="toc-text">2. TCP、UDP、SCTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-协议介绍"><span class="toc-text">2.1 协议介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCTP"><span class="toc-text">SCTP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-TCP详细说明"><span class="toc-text">2.2 TCP详细说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#三次握手"><span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP选项"><span class="toc-text">TCP选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP连接终止"><span class="toc-text">TCP连接终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP状态转换图"><span class="toc-text">TCP状态转换图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#观察分组"><span class="toc-text">观察分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TIME-WAIT状态"><span class="toc-text">TIME_WAIT状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#端口号和套接字对"><span class="toc-text">端口号和套接字对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP端口号和并发服务器"><span class="toc-text">TCP端口号和并发服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲区大小和限制"><span class="toc-text">缓冲区大小和限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP输出"><span class="toc-text">TCP输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-套接字编程简介"><span class="toc-text">3. 套接字编程简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-概述"><span class="toc-text">3.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-套接字地址结构"><span class="toc-text">3.2 套接字地址结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv4套接字结构"><span class="toc-text">IPv4套接字结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通用套接字地址结构"><span class="toc-text">通用套接字地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6套接字结构"><span class="toc-text">IPv6套接字结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#套接字地址比较"><span class="toc-text">套接字地址比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-值-结果参数"><span class="toc-text">3.3 值-结果参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-字节排序函数"><span class="toc-text">3.4 字节排序函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-字节操纵函数"><span class="toc-text">3.5 字节操纵函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-地址转换函数"><span class="toc-text">3.6 地址转换函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inet-aton、-inet-addr和inet-ntoa函数"><span class="toc-text">inet_aton、 inet_addr和inet_ntoa函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inet-pton和inet-ntop函数"><span class="toc-text">inet_pton和inet_ntop函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readn、written和readline函数"><span class="toc-text">readn、written和readline函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-基本TCP套接字编程"><span class="toc-text">4. 基本TCP套接字编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-概述"><span class="toc-text">4.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-socket函数"><span class="toc-text">4.2 socket函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-connect函数"><span class="toc-text">4.3 connect函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-bind函数"><span class="toc-text">4.4 bind函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-listen函数"><span class="toc-text">4.5 listen函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-accept函数"><span class="toc-text">4.6 accept函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-fork和exec函数"><span class="toc-text">4.7 fork和exec函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-并发服务器"><span class="toc-text">4.8 并发服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-close函数"><span class="toc-text">4.9 close函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-getsockname函数和getpeername函数"><span class="toc-text">4.10 getsockname函数和getpeername函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-TCP-C-S程序实例"><span class="toc-text">5. TCP C/S程序实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-目标"><span class="toc-text">5.1 目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-TCP回射Server"><span class="toc-text">5.2 TCP回射Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-TCP回射Client"><span class="toc-text">5.3 TCP回射Client</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-正常启动和关闭"><span class="toc-text">5.4 正常启动和关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-POSIX信号处理"><span class="toc-text">5.5 POSIX信号处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-wait-和-waitpid-函数"><span class="toc-text">5.6 wait 和 waitpid 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-I-O复用-select和poll"><span class="toc-text">6. I/O复用:select和poll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-关于IO复用"><span class="toc-text">6.1 关于IO复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-IO模型"><span class="toc-text">6.2 IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5种io模型（Unix）"><span class="toc-text">5种io模型（Unix）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-select函数"><span class="toc-text">6.3 select函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#描述符就绪条件"><span class="toc-text">描述符就绪条件</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/剑指offer刷题笔记（一）/">剑指offer刷题笔记（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Socket编程/">Socket编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Effective C++ Note/">Effective C++ Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Aurora Multi-Master 解读/">Aurora Multi-Master 解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Make学习/">Make学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Shell编程/">Shell编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/CMAKE 学习/">CMAKE 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（三）——valgrind/">性能分析工具（三）——valgrind</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（二）——perf/">性能分析工具（二）——perf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/MysqlTuner使用/MysqlTuner使用/">MysqlTuner使用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">CPP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">Database</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/oj/">OJ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能分析/">性能分析</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Stockdean Mu.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>