<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Effective C++ Note | MyBlog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Effective C++ Note</h1><a id="logo" href="/.">MyBlog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Effective C++ Note</h1><div class="post-meta"><a href="/2019/04/13/Effective C++ Note/#comments" class="comment-count"></a><p><span class="date">Apr 13, 2019</span><span><a href="/categories/cpp/" class="category">CPP</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><hr>
<h2 id="Effective-C-Note"><a href="#Effective-C-Note" class="headerlink" title="Effective C++ Note"></a>Effective C++ Note</h2><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="1-c-四个次语言"><a href="#1-c-四个次语言" class="headerlink" title="1. c++四个次语言"></a>1. c++四个次语言</h3><p><strong>c，objective-orinted c++,Template C++,STL</strong></p>
<h3 id="2-尽量用const，enum-inline-替换-define"><a href="#2-尽量用const，enum-inline-替换-define" class="headerlink" title="2. 尽量用const，enum, inline 替换 #define"></a>2. 尽量用const，enum, inline 替换 #define</h3><p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ASPECT_RATIO 1.652 /* 预编译器 */</span><br><span class="line">const double Aspect_Ration 1.652 /* 使用常量替换宏，以免error时看不到变量名 */</span><br></pre></td></tr></table></figure>
<p>而当对于一个字符串常量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> str = <span class="string">"stockdean"</span>;<span class="comment">/* 常量字符串*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="string">"stockdean"</span>)</span></span>; <span class="comment">/* 比上一个更好*/</span></span><br></pre></td></tr></table></figure>
<p>而对于类内变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span>:  <span class="comment">//封装性</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;  <span class="comment">//常量声明式，static 表示只存在一个</span></span><br><span class="line">		<span class="keyword">int</span> scores [NumTurns];   <span class="comment">//使用该常量</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时NumTurns为声明式而非定义式，如果必须提供定义式，则需要在.cc文件内定义。<code>const int GamePlayer::NumTurns ;</code><br>无法使用#define 来创建一个class 专属常量,因为#define并不重视作用域，却不提供封装性。如private。但是使用const 可以提供封装性。</p>
</blockquote>
<p>下面提供一个例子,如果<strong>老式编译器</strong>不支持在声明式赋予初值，则如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	xx.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostEstimate</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> FudgeFactor; <span class="comment">/* static class 常量声明 */</span></span><br><span class="line">		...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	xx.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> CostEstimate::FudgeFactor = <span class="number">1.35</span>; <span class="comment">/* 定义*/</span></span><br></pre></td></tr></table></figure>
<p>但是，如果后面的数组必须在编译期间指导数组大小怎么办？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line">		<span class="keyword">private</span>:  <span class="comment">//封装性</span></span><br><span class="line">		<span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;   <span class="comment">//使用enum可以充当int</span></span><br><span class="line">		<span class="keyword">int</span> scores [NumTurns];   <span class="comment">//使用该常量		</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>一.<code>enum hack</code> 行为更像#define(比如可以取const的地址，但是不能取enum的地址，也不能取#define的地址)<br>二. 实用主义</p>
</blockquote>
<p>macros的实现引发的错误，如下面的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b)?(a):(b))  </span></span><br><span class="line">取a b 中的较大值调用f</span><br><span class="line"></span><br><span class="line">一个有趣的例子</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b); <span class="comment">//a累加两次</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>);<span class="comment">//a累加一次</span></span><br></pre></td></tr></table></figure>
<p>为了避免macro引发的错误，template inline函数可以避免<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void callWithMax(const T&amp; a,const T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	f(a&gt;b?a:b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>小节：常量避免#define,macro实用template inline func 来替代。</p>
</blockquote>
<h3 id="3-尽可能使用const"><a href="#3-尽可能使用const" class="headerlink" title="3. 尽可能使用const"></a>3. 尽可能使用const</h3><p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char* p =&quot;stockdean&quot;;/* 字符串*/</span><br><span class="line">const char* p =&quot;stockdean&quot;;/*内容为const*/</span><br><span class="line">char* const p =&quot;stockdean&quot; /*指针为const*/</span><br><span class="line">const char* const p =&quot;stockdean&quot; /*内容和指针都是const*/</span><br></pre></td></tr></table></figure>
<p>两种形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void f1(const Widget* w);</span><br><span class="line">void f2(Widget const* w);  //都是指向不变的Widget类对象</span><br></pre></td></tr></table></figure></p>
<p>对于STL迭代器有同等适用的规则[2]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin(); <span class="comment">//类似T* const</span></span><br><span class="line">*iter = <span class="number">10</span>;<span class="comment">/*没问题*/</span></span><br><span class="line">iter++;<span class="comment">/* 报错 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter = vec.begin(); <span class="comment">//类似const T*</span></span><br><span class="line">*iter = <span class="number">10</span>;<span class="comment">/*报错*/</span></span><br><span class="line">iter++;<span class="comment">/*报错*/</span></span><br></pre></td></tr></table></figure>
<p>对于重载的operator有同样的妙用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> .. &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">返回<span class="keyword">const</span> 避免在a*b后再调用<span class="keyword">operator</span>=</span><br></pre></td></tr></table></figure>
<p><strong>const 对于成员函数</strong></p>
<ul>
<li>使class容易理解，标明什么是可以改的</li>
<li>使操作const 对象成为可能（见[20]）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TextBook&#123;</span><br><span class="line">public:	const char&amp; operator[](std::size_t position)const//operator for const 对象</span><br><span class="line">		&#123;return  text[position];&#125;</span><br><span class="line">		char&amp; operator[](std::size_t position)//operator for non-const 对象</span><br><span class="line">		&#123;return text[position];&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private: std::string text;</span><br><span class="line">&#125;;</span><br><span class="line">const TextBook ctb(&quot;hello&quot;);</span><br><span class="line">std::cout&lt;&lt;ctb[0];  //调用const operator[]</span><br><span class="line">TextBook tb(&quot;world&quot;);</span><br><span class="line">std::cout&lt;&lt;tb[0];//调用non-const operator[]</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1547647434748.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547647501336.png" alt="Alt text"></p>
<p><strong>bitwise const 和logical const</strong><br>假如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TextBook&#123;</span><br><span class="line">public:	const char&amp; operator[](std::size_t position)const//operator for const 对象</span><br><span class="line">		&#123;return  text[position];&#125;</span><br><span class="line">		char&amp; operator[](std::size_t position)//operator for non-const 对象</span><br><span class="line">		&#123;return text[position];&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private: char* text;</span><br><span class="line">&#125;;</span><br><span class="line">const TextBook ctb(&quot;hello&quot;);</span><br><span class="line">char* pc = &amp;ctb[0];</span><br><span class="line">*pc = &apos;J&apos;;//这是允许的</span><br><span class="line">因为只改变了内部值，这是允许的</span><br></pre></td></tr></table></figure></p>
<p>假如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class TextBook&#123;</span><br><span class="line">public:	std::size_t length() const;</span><br><span class="line">private: const char* pText;</span><br><span class="line">		 std::size_t textLength;</span><br><span class="line">		 bool lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line">std::size_t TextBook::length() const</span><br><span class="line">&#123;</span><br><span class="line">	if(!lengthIsValid)</span><br><span class="line">	&#123;</span><br><span class="line">		textLength = std::strlen(pText);//错误const成员函数内不能修改属性</span><br><span class="line">		lengthIsValid = true;	   //错误</span><br><span class="line">	&#125;</span><br><span class="line">	return textLenght;</span><br><span class="line">&#125;</span><br><span class="line">想要解决这个问题使用mutable类型（可变的）来修改non-static成员变量bitwise const限定</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/04/13/Effective C++ Note/1547648443302.png" alt="Alt text"></p>
<p><strong>在const和non-const成员函数间避免重复</strong><br><img src="/2019/04/13/Effective C++ Note/1547648975554.png" alt="Alt text"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBook</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)<span class="keyword">const</span><span class="comment">//operator for const 对象</span></span><br><span class="line">		&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span>  text[position];&#125;</span><br><span class="line">		<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)<span class="comment">//operator for non-const 对象</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBook&amp;&gt;(*<span class="keyword">this</span>)[position]);				</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">private</span>: <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1547649333830.png" alt="Alt text"></p>
<h3 id="4-确定对象使用前被初始化"><a href="#4-确定对象使用前被初始化" class="headerlink" title="4. 确定对象使用前被初始化"></a>4. 确定对象使用前被初始化</h3><ol>
<li><strong>要为内置对象手动初始化，因为C++不一定初始化（c part可能不会初始化，其他可能会）</strong></li>
<li><strong>构造函数使用初始值列表，而不要使用构造函数的赋值操作，排列顺序最好与声明顺序同</strong></li>
<li><strong>未免受”跨编译单元初始化次序”干扰，用<code>local static</code> 替换<code>non-local static</code> 对象</strong></li>
</ol>
<p>对于第一条举例：STL的vector会保证初始化，而c的array需要手动初始化。<br>对于非内置类型，类的初始化和member的初始化一般交由<strong>构造函数</strong>。</p>
<p>举例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,<span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; phones);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>: 	<span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">string</span> theAddress;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">			<span class="keyword">int</span>  numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,<span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; phones)</span><br><span class="line">&#123;</span><br><span class="line">	theName = name;     <span class="comment">//这些都是赋值(assignment 操作)</span></span><br><span class="line">	theAddress = address;<span class="comment">//不是初始化</span></span><br><span class="line">	thePhones =  phones;</span><br><span class="line">	numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于string等类型先执行了=default构造操作，然后才赋值。</span></span><br><span class="line"></span><br><span class="line">更好的写法</span><br><span class="line">ABEntry():theName(),theAddress,thePhones(),numTimesConsulted(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有些情况下对于<strong>内置类型</strong>也一定要初始化，例如<strong>const</strong>和<strong>reference</strong>的<code>member field</code><br>C++的初始化顺序一般与声明的顺序相同，但是有些操作一定要按顺序来（如数组大小要在数组前初始化）。</p>
</blockquote>
<p><strong>不同编译单元内定义之non-local static 对象</strong>次序<br>编译单元：<br><img src="/2019/04/13/Effective C++ Note/1547299943230.png" alt="Alt text"><br>local 对象：函数内的对象。<br>non-local static对象:global或者namespace内的或者class和file作用域内被声明为static的对象</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class FileSystem&#123;</span><br><span class="line">public: 			</span><br><span class="line">		std::size_t numDisks() const;</span><br><span class="line">&#125;;</span><br><span class="line">extern FileSystem tfs;//预备给客户使用的对象</span><br></pre></td></tr></table></figure>
<p>此时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Directory&#123;</span><br><span class="line">public: </span><br><span class="line">		Directroy(params);</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directroy(params)</span><br><span class="line">&#123;</span><br><span class="line">	std::size_t disks = tfs.numDisks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directory tmpDir(params);</span><br><span class="line">/**</span><br><span class="line">	除非tfs在tmpDir前被初始化，否则会用到未初始化的tfs，这个不同文件的是难以确定的。</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p><strong>所以需要用另外一种方式去实现。</strong><br>这里使用的是单例模式Singleton<br>即用local static 替换non-local static。使用return T&amp;类型的func来实现。</p>
<blockquote>
<p>理由:C++保证，函数内的non-local对象会在该函数被调用期间和首次遇到该对向定义式时初始化。所以使用函数调用替换”直接访问non-local 对象”</p>
</blockquote>
<p>修改后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class FileSystem&#123;</span><br><span class="line">public: 			</span><br><span class="line">		std::size_t numDisks() const;</span><br><span class="line">		FileSystem&amp; tfs();</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line">	local static 替换non-local static </span><br><span class="line">*/</span><br><span class="line">FileSystem&amp; tfs()</span><br><span class="line">&#123;</span><br><span class="line">	static FileSystem fs;</span><br><span class="line">	return fs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Directory&#123;</span><br><span class="line">public: </span><br><span class="line">		Directroy(params);</span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directroy(params)</span><br><span class="line">&#123;</span><br><span class="line">	std::size_t disks = tfs().numDisks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directory&amp; tempDir()</span><br><span class="line">&#123;</span><br><span class="line">	static Directory td;</span><br><span class="line">	return td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="5-了解C-编译器默默做了什么"><a href="#5-了解C-编译器默默做了什么" class="headerlink" title="5. 了解C++编译器默默做了什么"></a>5. 了解C++编译器默默做了什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Empty&#123;//实质上cpp编译器生成的是下面的</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Empty&#123;</span><br><span class="line">	public:</span><br><span class="line">			 Empty()&#123;&#125;//默认构造函数</span><br><span class="line">			 ~Empty()&#123;&#125;</span><br><span class="line">			 Empty(const Empty&amp; empty)&#123;&#125;//拷贝构造函数</span><br><span class="line">			Empty&amp; operator= (const Empty&amp; rhs)&#123;return rhs&#125;//</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">默认生成四个：两个构造函数，一个析构函数，一个拷贝赋值运算符</span><br><span class="line">只有当这些函数被调用，才会被编译器创造出来。</span><br><span class="line">如</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Empty e1();</span><br><span class="line">Empty e2(e1);</span><br><span class="line">e1 = e2;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器产出的析构函数是non-virtual类型的，除非base class自身声明<br>而对于拷贝构造函数和拷贝赋值运算符将non-static 对象拷贝到目标对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class NameObject&#123;</span><br><span class="line">	public: NameObject(const char* name, const T&amp; value);</span><br><span class="line">				NameObject(const std::string &amp; name,const T&amp; value);</span><br><span class="line"></span><br><span class="line">	private: std::string nameValue;</span><br><span class="line">			T objectValue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">由于已经声明了构造函数，所以编译器不再生产default。但是会生成拷贝构造函数和拷贝赋值运算符</span><br></pre></td></tr></table></figure>
<p>但是生成copy assignment operator的条件必须满足：1.代码合法2.有适当机会证明有意义<br>下面一种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class NameObject&#123;</span><br><span class="line">	public: NameObject(std::string&amp; name,const T&amp; value);</span><br><span class="line"></span><br><span class="line">   private: std::string  nameValue;</span><br><span class="line">			    const T objectValue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::string newDog(&quot;P&quot;);</span><br><span class="line">std::string oldDog(&quot;S&quot;);</span><br><span class="line">NameObject&lt;int&gt; p(newDog,2);</span><br><span class="line">NameObject&lt;int&gt; s(oldDog,32);</span><br><span class="line">p = s//错误这里编译器会拒绝编译</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为这里string&amp; name 不能变更，因为c++不允许”让reference改变向不同对象”</p>
</blockquote>
<p>如果某个base classes将copy assignment operator声明为private,那么编译器会拒绝为其derived classes 生成CAO。因为无权调用。</p>
<h3 id="6-阻止编译器生成拷贝构造函数和拷贝构造运算符"><a href="#6-阻止编译器生成拷贝构造函数和拷贝构造运算符" class="headerlink" title="6. 阻止编译器生成拷贝构造函数和拷贝构造运算符"></a>6. 阻止编译器生成拷贝构造函数和拷贝构造运算符</h3><p>两种方法:</p>
<ul>
<li>声明但是不定义</li>
<li>继承一个uncopyable class</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">只声明不定义</span><br><span class="line">class HomeForSale&#123;</span><br><span class="line">	private:    HomeForSale(const HomeForSale&amp; hfs);//编译器生成都是public,这里为private</span><br><span class="line">				HomeForSale&amp; operator=(const HomeForSale&amp; rhs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者定义一个base class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Uncopyable&#123;</span><br><span class="line">	protected:</span><br><span class="line">		Uncopyable();</span><br><span class="line">		~Uncopyable();</span><br><span class="line">	private: Uncopyable(const Uncopyable&amp; );</span><br><span class="line">				Uncopyable operator=(const Uncopyable&amp; );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">然后继承</span><br><span class="line">class HomeForSale:private Uncopyable&#123;//class 不再声明copy 构造或者CAO</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="7-为多态基类声明virtual析构函数"><a href="#7-为多态基类声明virtual析构函数" class="headerlink" title="7. 为多态基类声明virtual析构函数"></a>7. 为多态基类声明virtual析构函数</h3><ol>
<li>如果一个（多态性质）作为base class的类有member函数为virtual，那么它的析构函数应为virtual</li>
<li>如果一个类不打算作为base class不要使用virtual修饰析构函数<br>如果存在一个Factory类</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	Animal();</span><br><span class="line">			~Animal();</span><br><span class="line"></span><br><span class="line">			....			</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Animal* <span class="title">getAnimal</span><span class="params">()</span></span>;</span><br><span class="line">Animal* p = getAnimal();</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//会导致局部销毁，只销毁base class的部分。所以</span></span><br></pre></td></tr></table></figure>
<p>改为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	Animal();</span><br><span class="line">		<span class="comment">//	~Animal();</span></span><br><span class="line">		<span class="keyword">virtual</span> ~Animal();</span><br><span class="line">			....			</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal* p = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//会导致局部销毁，只销毁部分。所以</span></span><br></pre></td></tr></table></figure></p>
<p><strong>如果一个class不作为base class类但是声明了virtual member func会怎么样？</strong></p>
<blockquote>
<p>由于对象会保存一个vptr指向虚函数表（virtual function table）(指针数组)，所以导致对象臃肿。<br><img src="/2019/04/13/Effective C++ Note/1547475173122.png" alt="Alt text"><br>如果继承一个没有virtual函数的class也会出现问题。如STL的string等（析构函数non-virtual）<br>生成一个抽象类</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class AWOV&#123;</span><br><span class="line">	public:    virtual ~AWOV() = 0;//纯虚函数，不会被实例化，抽象类</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">需要定义析构函数</span><br><span class="line">AWOV::~AWOV()&#123;&#125;  //定义</span><br></pre></td></tr></table></figure>
<h3 id="8-别让异常逃离析构函数"><a href="#8-别让异常逃离析构函数" class="headerlink" title="8. 别让异常逃离析构函数"></a>8. 别让异常逃离析构函数</h3><ul>
<li>析构函数绝对不要出现异常</li>
<li>如果对异常要处理，使用普通函数包装<br><img src="/2019/04/13/Effective C++ Note/1547475634954.png" alt="Alt text"><br>这里假设vector销毁时，析构出现问题（大于一个出现异常，导致不明确行为）。<br>可以抛出异常处理<br>例<br><img src="/2019/04/13/Effective C++ Note/1547475757263.png" alt="Alt text"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class DBConn&#123;</span><br><span class="line"></span><br><span class="line">	public: ~DBConn();</span><br><span class="line">	private: DBConnnection db;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DBConn::~DBConn()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	db.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时如果写下面的代码<br><img src="/2019/04/13/Effective C++ Note/1547475909255.png" alt="Alt text"></p>
<p>如果调用close()失败</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//db.close();   处理异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	db.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(...)&#123;</span><br><span class="line"></span><br><span class="line">	Log失败的问题</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无法对抛出异常做出反应，可以使用普通函数处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class DBConn&#123;</span><br><span class="line"></span><br><span class="line">	public: ~DBConn();</span><br><span class="line">			void close()</span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				db.close();</span><br><span class="line">				closed = true;</span><br><span class="line">			&#125;			</span><br><span class="line"></span><br><span class="line">	private: DBConnnection db;</span><br><span class="line">			 bool closed;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DBConn::~DBConn()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	//db.close();</span><br><span class="line">	if(!closed)</span><br><span class="line">	&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">				db.close();</span><br><span class="line">			&#125;	</span><br><span class="line">		catch(...)</span><br><span class="line">			&#123;</span><br><span class="line">&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="9-绝不在构造和析构函数中调用virtual函数"><a href="#9-绝不在构造和析构函数中调用virtual函数" class="headerlink" title="9. 绝不在构造和析构函数中调用virtual函数"></a>9. 绝不在构造和析构函数中调用virtual函数</h3><ul>
<li>绝不在构造和析构函数中调用virtual函数，因为不会下降到derived层<br>假如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Transaction&#123;</span><br><span class="line">	public:  Transaction();</span><br><span class="line">				</span><br><span class="line">		virtual void LogTransacition()const =0;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::Transaction()</span><br><span class="line">&#123;</span><br><span class="line">	LogTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuyTransaction:public Transaction&#123;</span><br><span class="line">	public:</span><br><span class="line">			virtual void LogTransacition() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SellTransaction:public Transaction&#123;</span><br><span class="line">	public:</span><br><span class="line">			virtual void LogTransacition() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BuyTransaction b;</span><br><span class="line">这时候生成的对象仿佛隶属于Transaction(c++阻止下降到derived)</span><br></pre></td></tr></table></figure>
<p>使用新一层包装问题可能更难发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Transaction&#123;</span><br><span class="line">	public:  Transaction()&#123;</span><br><span class="line">					init();    //non virtual</span><br><span class="line">					&#125;</span><br><span class="line">				</span><br><span class="line">		virtual void LogTransacition()const =0;</span><br><span class="line">	private:	void init()</span><br><span class="line">			&#123;</span><br><span class="line">			LogTransaciton();   //virtual</span><br><span class="line">			&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::Transaction()</span><br><span class="line">&#123;</span><br><span class="line">	LogTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuyTransaction:public Transaction&#123;</span><br><span class="line">	public:</span><br><span class="line">			virtual void LogTransacition() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SellTransaction:public Transaction&#123;</span><br><span class="line">	public:</span><br><span class="line">			virtual void LogTransacition() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所以更好地是避免使用virtual<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Transaction&#123;</span><br><span class="line">	public:  explicit Transaction(const std::string&amp; logInfo)</span><br><span class="line">				</span><br><span class="line">		    void LogTransacition(const std::string&amp; logInfo) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::Transaction(const std::string&amp; logInfo)</span><br><span class="line">&#123;</span><br><span class="line">	LogTransaction(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuyTransaction:public Transaction&#123;</span><br><span class="line">	public:</span><br><span class="line">		BuyTransaction(Params):Transaction(createLogString(params))</span><br><span class="line">		&#123;</span><br><span class="line">		...</span><br><span class="line">		&#125;//log传给base构造函数(向上传递弥补不能向下传递)</span><br><span class="line">	private:</span><br><span class="line">		static std::string createLogString(params);		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-令operator-返回一个referfence-to-this"><a href="#10-令operator-返回一个referfence-to-this" class="headerlink" title="10. 令operator=返回一个referfence to *this"></a>10. 令operator=返回一个referfence to *this</h3><ul>
<li>这是个习惯</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Widget</span><br><span class="line">&#123;</span><br><span class="line">	public: Widget();</span><br><span class="line">			Widget&amp; operator=(const Widget&amp; rhs)</span><br><span class="line">			&#123;</span><br><span class="line">					return *this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="11-在operator-中处理自我赋值"><a href="#11-在operator-中处理自我赋值" class="headerlink" title="11. 在operator=中处理自我赋值"></a>11. 在operator=中处理自我赋值</h3><p><img src="/2019/04/13/Effective C++ Note/1547536316099.png" alt="Alt text"><br>例子<br>如果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class BitMap&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">class Weight&#123;</span><br><span class="line">public:</span><br><span class="line">private: Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Weight&amp; operator=(const Weight&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	delete pb;</span><br><span class="line">	pb = new Bitmap(*(rhs.pb));</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">如果pb指向的和rhs的pb是一样的，这里报错。</span><br><span class="line"></span><br><span class="line">最简单的方法是进行“证同测试”</span><br><span class="line">Weight&amp; operator=(const Weight&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	if(rhs == this)</span><br><span class="line">	return *this;</span><br><span class="line">	</span><br><span class="line">	delete pb;</span><br><span class="line">	pb = new Bitmap(*(rhs.pb));	  //不具有异常安全性</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1547618125338.png" alt="Alt text"><br>这种做法保证了异常安全</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitMap</span>&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weight</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">const</span> Weight&amp; rhs)</span></span></span><br><span class="line">private: Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Weight&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Weight&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Weight temp(rhs);</span><br><span class="line">	swap(temp);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-复制对象勿忘每一个成分"><a href="#12-复制对象勿忘每一个成分" class="headerlink" title="12. 复制对象勿忘每一个成分"></a>12. 复制对象勿忘每一个成分</h3><p><img src="/2019/04/13/Effective C++ Note/1547618949854.png" alt="Alt text"><br>如果在自我实现copy 构造函数和COA后，添加了成员变量，注意要修改这两个函数，否则会引起局部copy（采用default构造函数初始化）。<br><img src="/2019/04/13/Effective C++ Note/1547619628309.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547619431475.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs):Customer(rhs),priority(rhs.priority)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::PriorityCustomer(const PrioriCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Customer::operator=(rhs);//base 的CAO</span><br><span class="line">	Priority = rhs.Priority;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1547620284044.png" alt="Alt text"></p>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="13-以Object管理资源"><a href="#13-以Object管理资源" class="headerlink" title="13. 以Object管理资源"></a>13. 以Object管理资源</h3><p><img src="/2019/04/13/Effective C++ Note/1547621986860.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Investment&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">Investment* createInvestment();//Factory模式</span><br><span class="line"></span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">	Investment* iv = createInvestment();</span><br><span class="line">	...  //如果...内有return，会提前结束</span><br><span class="line">	delete iv;</span><br><span class="line">&#125;</span><br><span class="line">为确保正常释放，把资源放入对象，利用析构函数自动释放</span><br><span class="line">或者</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">	std::auto_ptr&lt;Investment&gt; apiv(createInvestment());//auto_ptr的析构函数会自动释放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/04/13/Effective C++ Note/1547621027162.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547621615520.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::auto_ptr&lt;Investment&gt; priv1(createInvestment());</span><br><span class="line">std::auto_ptr&lt;Investment&gt; priv2(priv1)//现在priv2 指向原来的priv1，priv1为空</span><br><span class="line">priv1 = priv2;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1547621781301.png" alt="Alt text"></p>
<p><strong>使用shared_ptr比auto_ptr更好</strong></p>
<p><img src="/2019/04/13/Effective C++ Note/1547621886312.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547621931084.png" alt="Alt text"></p>
<h3 id="14-在资源管理类中小心copying行为"><a href="#14-在资源管理类中小心copying行为" class="headerlink" title="14. 在资源管理类中小心copying行为"></a>14. 在资源管理类中小心copying行为</h3><p><img src="/2019/04/13/Effective C++ Note/1547649656737.png" alt="Alt text"></p>
<p><img src="/2019/04/13/Effective C++ Note/1547649635842.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Lock&#123;</span><br><span class="line">public: explicit Lock(Mutex* pm):mutexPtr(pm)</span><br><span class="line">			&#123;</span><br><span class="line">			 lock(mutexPtr);</span><br><span class="line">	  &#125;</span><br><span class="line">	  ~Lock()</span><br><span class="line">		  &#123;unlock(mutexPtr);</span><br><span class="line">		&#125;</span><br><span class="line">private: Mutex* mutexPtr;</span><br><span class="line">			</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/04/13/Effective C++ Note/1547649950360.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lock l1(&amp;m);</span><br><span class="line">Lock l2(l1)//禁止这种行为，因为不合理。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1547650130214.png" alt="Alt text"><br>重新实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Lock&#123;</span><br><span class="line">public: explicit Lock(Mutex* pm):mutexPtr(pm,unlock)//这里以unlock函数作为删除器</span><br><span class="line">			&#123;</span><br><span class="line">			 lock(mutexPtr.get());</span><br><span class="line">	  &#125;</span><br><span class="line">/*	  ~Lock()</span><br><span class="line">		  &#123;unlock(mutexPtr);</span><br><span class="line">		&#125;*/析构函数不再需要声明</span><br><span class="line">private: std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;</span><br><span class="line">			</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="15-在资源管理类提供对原始资源的访问"><a href="#15-在资源管理类提供对原始资源的访问" class="headerlink" title="15.在资源管理类提供对原始资源的访问"></a>15.在资源管理类提供对原始资源的访问</h3><p><img src="/2019/04/13/Effective C++ Note/1547799444386.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/04/13/Effective C++ Note/1547799580150.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547799613405.png" alt="Alt text"><br>这时候有两种方法可以解决这个问题。<br><strong>显式转换</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int days = daysHeld(pInv.get());</span><br></pre></td></tr></table></figure></p>
<p><strong>隐式转换</strong><br><img src="/2019/04/13/Effective C++ Note/1547800051597.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547800203560.png" alt="Alt text"></p>
<h3 id="16-成对使用new和delete使用相同形式"><a href="#16-成对使用new和delete使用相同形式" class="headerlink" title="16. 成对使用new和delete使用相同形式"></a>16. 成对使用new和delete使用相同形式</h3><p><img src="/2019/04/13/Effective C++ Note/1547800381512.png" alt="Alt text"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr1 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr2 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringPtr1;</span><br><span class="line"><span class="keyword">delete</span>[] stringPtr2</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/04/13/Effective C++ Note/1547800414147.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547800425353.png" alt="Alt text"></p>
<h3 id="17-以独立语句将newed对象置入只能指针"><a href="#17-以独立语句将newed对象置入只能指针" class="headerlink" title="17. 以独立语句将newed对象置入只能指针"></a>17. 以独立语句将newed对象置入只能指针</h3><p><img src="/2019/04/13/Effective C++ Note/1547800635861.png" alt="Alt text"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::shard_ptr&lt;Widget&gt;pw,<span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">processWidget(new Widget,priority());  //不能通过编译</span><br><span class="line">processWidget(std::shared_ptr&lt;Widget&gt;(new Widget),priority());//能通过编译但是会出现资源泄漏</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1547801197212.png" alt="Alt text"><br>如果以下面的顺序<br> <img src="/2019/04/13/Effective C++ Note/1547801267376.png" alt="Alt text"><br>一旦<code>priority()</code>调用出现问题，则会引发异常。<br>所以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shard_ptr&lt;Widget&gt;pw (new Widget) ;</span><br><span class="line">processWidget(pw,priority());</span><br></pre></td></tr></table></figure>
<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="18-让接口容易被正确使用"><a href="#18-让接口容易被正确使用" class="headerlink" title="18. 让接口容易被正确使用"></a>18. 让接口容易被正确使用</h3><p><img src="/2019/04/13/Effective C++ Note/1547801612713.png" alt="Alt text"></p>
<h3 id="19-设计class犹如设计type"><a href="#19-设计class犹如设计type" class="headerlink" title="19. 设计class犹如设计type"></a>19. 设计class犹如设计type</h3><p><img src="/2019/04/13/Effective C++ Note/1547801706152.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547801714873.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547801723391.png" alt="Alt text"></p>
<h3 id="20-宁以pass-by-reference-to-const替代pass-by-value"><a href="#20-宁以pass-by-reference-to-const替代pass-by-value" class="headerlink" title="20. 宁以pass-by-reference-to-const替代pass-by-value"></a>20. 宁以pass-by-reference-to-const替代pass-by-value</h3><h2 id="继承与OO-Design"><a href="#继承与OO-Design" class="headerlink" title="继承与OO-Design"></a>继承与OO-Design</h2><h3 id="32-确定public继承是is-a的关系"><a href="#32-确定public继承是is-a的关系" class="headerlink" title="32. 确定public继承是is-a的关系"></a>32. 确定public继承是is-a的关系</h3><p><img src="/2019/04/13/Effective C++ Note/1547991247375.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1547991292359.png" alt="Alt text"><br>考虑下面的例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">const</span> Person&amp; person)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">const</span> Student&amp; stu)</span></span>;</span><br><span class="line">Person person;</span><br><span class="line">Student stu;</span><br><span class="line">eat(person);</span><br><span class="line">eat(stu);</span><br><span class="line">study(person);  <span class="comment">//错误person 不是Student</span></span><br><span class="line">study(stu);</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1548059829466.png" alt="Alt text"><br>下面更符合事实</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Bird&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class FlyingBird:public Bird&#123;</span><br><span class="line"></span><br><span class="line">	virtual void fly();</span><br><span class="line">&#125;;</span><br><span class="line">class Penguin:public Bird&#123;</span><br><span class="line">	和会飞的鸟区分	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1548060028330.png" alt="Alt text"><br>讨论下面这个例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> newHeight)</span></span>;	</span><br><span class="line">			<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> newWidth)</span></span>;</span><br><span class="line">			<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>  <span class="title">Height</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">			<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>  <span class="title">Width</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeBigger</span><span class="params">(Rectangle&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> height = r.height();</span><br><span class="line">		r.setWidth(r.width() + <span class="number">10</span>);</span><br><span class="line">		assert(r.heigth()==height)<span class="comment">//判断高度是否发生变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1548060793376.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1548060773801.png" alt="Alt text"></p>
<h3 id="33-避免遮掩继承来的名称"><a href="#33-避免遮掩继承来的名称" class="headerlink" title="33. 避免遮掩继承来的名称"></a>33. 避免遮掩继承来的名称</h3><p><img src="/2019/04/13/Effective C++ Note/1548060874832.png" alt="Alt text"><br><img src="/2019/04/13/Effective C++ Note/1548060855207.png" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">		private: int x;</span><br><span class="line">	public: </span><br><span class="line">		virtual void mf1()=0;</span><br><span class="line">		virtual void mf2();</span><br><span class="line">		void  mf3();</span><br><span class="line">&#125;;</span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">	public:</span><br><span class="line">		 virtual void mf1();  //子类会遮掩父类的mf1()</span><br><span class="line">		 void mf4();</span><br><span class="line">&#125;;</span><br><span class="line">void Derived::mf4()</span><br><span class="line">&#123;</span><br><span class="line">	mf2();</span><br><span class="line">&#125;</span><br><span class="line">编译器先找Derived--&gt;Base--&gt;namespace--&gt;global,在Base找到便停止查找。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1548061164139.png" alt="Alt text"><br>下面这个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">		private: int x;</span><br><span class="line">	public: </span><br><span class="line">		virtual void mf1()=0;</span><br><span class="line">		virtual void mf1(int);</span><br><span class="line">		virtual void mf2();</span><br><span class="line">		void  mf3();</span><br><span class="line">		void mf3(double);</span><br><span class="line">&#125;;</span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">	public:</span><br><span class="line">		 virtual void mf1();  //子类会遮掩父类的mf1()</span><br><span class="line">		 void mf3();</span><br><span class="line">		 void mf4();</span><br><span class="line">&#125;;</span><br><span class="line">如果下面调用会发生什么</span><br><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line"></span><br><span class="line">d.mf1();//ok</span><br><span class="line">d.mf1(x);//error!遮掩了</span><br><span class="line">d.mf2();//ok</span><br><span class="line">d.mf3();//ok</span><br><span class="line">d.mf3(x);//error遮掩了</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，一方面可以使用using声明来解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">		private: int x;</span><br><span class="line">	public: </span><br><span class="line">		virtual void mf1()=0;</span><br><span class="line">		virtual void mf1(int);</span><br><span class="line">		virtual void mf2();</span><br><span class="line">		void  mf3();</span><br><span class="line">		void mf3(double);</span><br><span class="line">&#125;;</span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">	public:</span><br><span class="line">				using Base::mf1; //让base class 内mf1和mf3的东西全部可见</span><br><span class="line">				using Base::mf3;//在Derived作用域内都可见（并且public ）</span><br><span class="line">			   virtual void mf1();  //子类会遮掩父类的mf1()</span><br><span class="line">		 void mf3();</span><br><span class="line">		 void mf4();</span><br><span class="line">&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line"></span><br><span class="line">d.mf1();//ok</span><br><span class="line">d.mf1(x);//ok</span><br><span class="line">d.mf2();//ok</span><br><span class="line">d.mf3();//ok</span><br><span class="line">d.mf3(x);//ok</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/13/Effective C++ Note/1548062940300.png" alt="Alt text"><br>利用转交函数forward function可以选择性继承Base的virtual函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">		private: int x;</span><br><span class="line">	public: </span><br><span class="line">		virtual void mf1()=0;</span><br><span class="line">		virtual void mf1(int);</span><br><span class="line">		virtual void mf2();</span><br><span class="line">		void  mf3();</span><br><span class="line">		void mf3(double);</span><br><span class="line">&#125;;</span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">	public:</span><br><span class="line">				</span><br><span class="line">	    virtual void mf1()&#123;    //转交函数</span><br><span class="line">	     Base::mf1();</span><br><span class="line">	    &#125;</span><br><span class="line">		 void mf3();</span><br><span class="line">		 void mf4();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line">d.mf1();//ok</span><br><span class="line">d.mf1(x);//error</span><br></pre></td></tr></table></figure>
<h3 id="34-区分接口继承和实现继承"><a href="#34-区分接口继承和实现继承" class="headerlink" title="34. 区分接口继承和实现继承"></a>34. 区分接口继承和实现继承</h3><p><img src="/2019/04/13/Effective C++ Note/1548779362642.png" alt="Alt text"></p>
<h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="41-隐式接口和编译器多态"><a href="#41-隐式接口和编译器多态" class="headerlink" title="41. 隐式接口和编译器多态"></a>41. 隐式接口和编译器多态</h3><ul>
<li>classes和template都支持接口和多态</li>
<li>OOP支持的是显式接口，可以找到对应代码。virtual函数实现了运行期多态，根据对象的动态类型决定调用哪一个函数。</li>
<li>template 支持的是隐式接口，例如w无论是什么类型，都需要支持doProcessing内的函数操作。而且是编译器多态，在编译的时候决定实际运行的函数。<br><img src="/2019/04/13/Effective C++ Note/1553849682251.png" alt="Alt text"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		Widget();</span><br><span class="line">		<span class="keyword">virtual</span> ~Widget();</span><br><span class="line">		<span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(Widget&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(w.size()&gt;<span class="number">10</span>&amp;&amp;w!=someNastyWidget)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">		temp.normalize();</span><br><span class="line">		temp.swap(w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改写成template 接口</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(w.size()&gt;<span class="number">10</span>&amp;&amp;w!=someNastyWidget)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">		temp.normalize();</span><br><span class="line">		temp.swap(w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="42-了解typename的双重意义"><a href="#42-了解typename的双重意义" class="headerlink" title="42. 了解typename的双重意义"></a>42. 了解typename的双重意义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(container.size()&gt;<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		C::const_iterator iter(container.begin()); //这里的const_iterator是一个嵌套从属类型名称,local variable</span><br><span class="line">		++iter;</span><br><span class="line">		<span class="keyword">int</span> value = *iter; <span class="comment">//这里的int 是非从属类型名</span></span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;value&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/04/13/Socket编程/" class="pre">Socket编程</a><a href="/2019/04/13/Aurora Multi-Master 解读/" class="next">Aurora Multi-Master 解读</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Effective-C-Note"><span class="toc-text">Effective C++ Note</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础部分"><span class="toc-text">基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-c-四个次语言"><span class="toc-text">1. c++四个次语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-尽量用const，enum-inline-替换-define"><span class="toc-text">2. 尽量用const，enum, inline 替换 #define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-尽可能使用const"><span class="toc-text">3. 尽可能使用const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-确定对象使用前被初始化"><span class="toc-text">4. 确定对象使用前被初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造-析构-赋值运算"><span class="toc-text">构造/析构/赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-了解C-编译器默默做了什么"><span class="toc-text">5. 了解C++编译器默默做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-阻止编译器生成拷贝构造函数和拷贝构造运算符"><span class="toc-text">6. 阻止编译器生成拷贝构造函数和拷贝构造运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-为多态基类声明virtual析构函数"><span class="toc-text">7. 为多态基类声明virtual析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-别让异常逃离析构函数"><span class="toc-text">8. 别让异常逃离析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-绝不在构造和析构函数中调用virtual函数"><span class="toc-text">9. 绝不在构造和析构函数中调用virtual函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-令operator-返回一个referfence-to-this"><span class="toc-text">10. 令operator=返回一个referfence to *this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-在operator-中处理自我赋值"><span class="toc-text">11. 在operator=中处理自我赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-复制对象勿忘每一个成分"><span class="toc-text">12. 复制对象勿忘每一个成分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资源管理"><span class="toc-text">资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-以Object管理资源"><span class="toc-text">13. 以Object管理资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-在资源管理类中小心copying行为"><span class="toc-text">14. 在资源管理类中小心copying行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-在资源管理类提供对原始资源的访问"><span class="toc-text">15.在资源管理类提供对原始资源的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-成对使用new和delete使用相同形式"><span class="toc-text">16. 成对使用new和delete使用相同形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-以独立语句将newed对象置入只能指针"><span class="toc-text">17. 以独立语句将newed对象置入只能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计与声明"><span class="toc-text">设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-让接口容易被正确使用"><span class="toc-text">18. 让接口容易被正确使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-设计class犹如设计type"><span class="toc-text">19. 设计class犹如设计type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-宁以pass-by-reference-to-const替代pass-by-value"><span class="toc-text">20. 宁以pass-by-reference-to-const替代pass-by-value</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承与OO-Design"><span class="toc-text">继承与OO-Design</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32-确定public继承是is-a的关系"><span class="toc-text">32. 确定public继承是is-a的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-避免遮掩继承来的名称"><span class="toc-text">33. 避免遮掩继承来的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-区分接口继承和实现继承"><span class="toc-text">34. 区分接口继承和实现继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板与泛型编程"><span class="toc-text">模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-隐式接口和编译器多态"><span class="toc-text">41. 隐式接口和编译器多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-了解typename的双重意义"><span class="toc-text">42. 了解typename的双重意义</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/剑指offer刷题笔记（一）/">剑指offer刷题笔记（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Socket编程/">Socket编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Effective C++ Note/">Effective C++ Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Aurora Multi-Master 解读/">Aurora Multi-Master 解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Make学习/">Make学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Shell编程/">Shell编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/CMAKE 学习/">CMAKE 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（三）——valgrind/">性能分析工具（三）——valgrind</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（二）——perf/">性能分析工具（二）——perf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/MysqlTuner使用/MysqlTuner使用/">MysqlTuner使用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">CPP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">Database</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/oj/">OJ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能分析/">性能分析</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Stockdean Mu.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>