<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SSD与数据库 | MyBlog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SSD与数据库</h1><a id="logo" href="/.">MyBlog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">SSD与数据库</h1><div class="post-meta"><a href="/2019/03/01/SSD与数据库/#comments" class="comment-count"></a><p><span class="date">Mar 01, 2019</span><span><a href="/categories/Database/" class="category">Database</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><hr>
<h2 id="SSD与数据库"><a href="#SSD与数据库" class="headerlink" title="SSD与数据库"></a>SSD与数据库</h2><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><ul>
<li>4k对齐</li>
<li>写入放大</li>
<li>wear leveling</li>
</ul>
<p><strong>4k对齐</strong><br>        SSD的写操作比较特殊，SSD的最小写入单元为4KB，称为页(page)，当写入空白位置时可以按照4KB的单位写入，但是如果需要改写某个单元时，则需要一个额外的擦除(erase)动作，擦除的单位一般是128个page(512KB)，每个擦除单元称为块(block)。如果向一个空白的page写入信息时，可以直接写入而无需擦除，但是如果需要改写某个存储单元(page)的数据，必须首先将整个block读入缓存，然后修改数据，并擦除整个block的数据，最后将整个block写入，很显然，SSD改写数据的代价很高，SSD的这个特性，我们称之为erase-before-write。</p>
<p> <strong>wear leveling</strong><br>        因为SSD存在“写磨损”的问题，当某个单元长时间被反复擦写时(比如Oracle redo)，不仅会造成写入的性能问题，而且会大大缩    短SSD的使用寿命，所以必须设计一个均衡负载的算法来保证SSD的每个单元能够被均衡的使用，这就是wear leveling，称为损耗均衡算法。</p>
<p>　　Wear leveling也是SSD内部的FTL实现的，它通过数据迁移来达到均衡损耗的目的。Wear leveling依赖于SSD中的一部分保留空间，基本原理是在SSD中设置了两个block pool，一个是free block pool(空闲池)，一个是数据池(data block pool)，当需要改写某个page时(如果写入原有位置，必须先擦除整个block，然后才能写入数据)，并不写入原有位置(不需要擦除的动作)，而是从空闲池中取出新的block，将现有的数据和需要改写的数据合并为新的block，一起写入新的空白block，原有的block被标识为invalid状态(等待被擦除回收)，新的block则进入数据池。后台任务会定时从data block中取出无效数据的block，擦除后回收到空闲池中。这样做的好处在于，一是不会反复擦写同一个block，二是写入的速度会比较快(省略了擦除的动作)。</p>
<p>　　Wear leveling分为两种：动态损耗均衡和静态损耗均衡，两者的原理一致，区别在于动态算法只会处理动态数据，比如数据改写时才会触发数据迁移的动作，对静态数据不起作用，而静态算法可以均衡静态数据，当后台任务发现损耗很低的静态数据块时，将其迁移到其他数据库块上，将这些块放入空闲池中使用。从均衡的效果来看，静态算法要好于动态算法，因为几乎所有的block都可以被均衡的使用，SSD的寿命会大大延长，但是静态算法的缺点是当数据迁移时，可能会导致写性能下降。</p>
<p><strong>写入放大</strong><br>        因为SSD的erase-before-write的特性，所以就出现了一个写入放大的概念，比如你想改写4K的数据，必须首先将整个擦除块(512KB)中的数据读出到缓存中，改写后，将整个块一起写入，这时你实际写入了512KB的数据，写入放大系数是128。写入放大最好的情况是1，就是不存在放大的情况。</p>
<p>　　Wear leveling算法可以有效缓解写入放大的问题，但是不合理的算法依然会导致写入放大，比如用户需要写入4k数据时，发现free block pool中没有空白的block，这时就必须在data block pool中选择一个包含无效数据的block，先读入缓存中，改写后，将整个块一起写入，采用wear leveling算法依然会存在写入放大的问题。</p>
<p>　　通过为SSD预留更多空间，可以显著缓解写入放大导致的性能问题。根据我们的测试结果，MLC SSD在长时间的随机写入后，性能下降很明显(随机写IOPS甚至降低到300)。如果为wear leveling预留更多空间，就可以显著改善MLC SSD在长时间写操作之后的性能下降问题，而且保留的空间越多，性能提升就越明显。相比较而言，SLC SSD的性能要稳定很多(IOPS在长时间随机写后，随机写可以稳定在3000 IOPS)，我想应该是SLC SSD的容量通常比较小(32G和64G)，而用于wear leveling的空间又比较大的原因。</p>
<h2 id="数据库IO特点分析"><a href="#数据库IO特点分析" class="headerlink" title="数据库IO特点分析"></a>数据库IO特点分析</h2><p>　　IO有四种类型：连续读，随机读，随机写和连续写，连续读写的IO size通常比较大(128KB-1MB)，主要衡量吞吐量，而随机读写的IO size比较小(小于8KB)，主要衡量IOPS和响应时间。数据库中的全表扫描是连续读IO，索引访问则是典型的随机读IO，日志文件是连续写IO，而数据文件则是随机写IO。</p>
<p>　　数据库系统基于传统磁盘访问特性来设计，最大特点是日志文件采用sequential logging，数据库中的日志文件，要求必须在事务提交时写入到磁盘，对响应时间的要求很高，所以设计为顺序写入的方式，可以有效降低磁盘寻道花费的时间，减少延迟时间。日志文件的顺序写入，虽然是物理位置是连续的，但是并不同于传统的连续写类型，日志文件的IO size很小(通常小于4K),每个IO之间是独立的(磁头必须抬起来重新寻道，并等待磁盘转动到相应的位置)，而且间隔很短，数据库通过log buffer(缓存)和group commit的方式(批量提交)来达到提高IO size的大小，并减少IO的次数，从而得到更小的响应延迟，所以日志文件的顺序写入可以被认为是“连续位置的随机写入”，更关注IOPS，而不是吞吐量。</p>
<p>　　数据文件采用in place uddate的方式，意思是数据文件的修改都是写入到原来的位置，数据文件不同于日志文件，并不会在事务commit时写入数据文件，只有当数据库发现dirty buffer过多或者需要做checkpoint动作时，才会刷新这些dirty buffer到相应的位置，这是一个异步的过程，通常情况下，数据文件的随机写入对IO的要求并不是特别高，只要满足checkpoint和dirty buffer的要求就可以了。</p>
<p>　　SSD的IO特点分析</p>
<p>　　1.随机读能力非常好，连续读性能一般，但比普通SAS磁盘好。</p>
<p>　　2.不存在磁盘寻道的延迟时间，随机写和连续写的响应延迟差异不大。</p>
<p>　　3.erase-before-write特性，造成写入放大，影响写入的性能。</p>
<p>　　4.写磨损特性，采用wear leveling算法延长寿命，但同时会影响读的性能。</p>
<p>　　5.读和写的IO响应延迟不对等(读要大大好于写)，而普通磁盘读和写的IO响应延迟差异很小。</p>
<p>　　6.连续写比随机写性能好，比如1M顺序写比128个8K的随即写要好很多，因为随即写会带来大量的擦除。</p>
<p>　　基于SSD的上述特性，如果将数据库全部放在SSD上，可能会有以下的问题：</p>
<p>　　1.日志文件sequential logging会反复擦写同一位置，虽然有损耗均衡算法，但是长时间写入依然会导致性能下降。</p>
<p>　　2.数据文件in place update会产生大量的随机写入，erase-before-write会产生写入放大。</p>
<p>　　3.数据库读写混合型应用，存在大量的随机写入，同时会影响读的性能，产生大量的IO延迟。</p>
<p>　　基于SSD的数据库优化法则：</p>
<p>　　基于SSD的优化就是解决erase-before-write产生的写入放大的问题，不同类型的IO分离，减少写操作带来的性能影响。</p>
<p>　　1.将sequential logging修改为In-page logging，避免对相同位置的反复擦写。</p>
<p>　　2.通过缓存写入的方式将大量的in-place update随机写入合并为少量顺序写入。</p>
<p>　　3.利用SSD随机读写能力高的特点，减少写增加读，从而达到整体性能的提升。</p>
<p>　　In-page logging</p>
<p>　　In-page logging是基于SSD对数据库sequential logging的一种优化方法，数据库中的sequential logging对传统磁盘是非常有利的，可以大大提高响应时间，但是对于SSD就是噩梦，因为需要对同一位置反复擦写，而wear leveling算法虽然可以平衡负载，但是依然会影响性能，并产生大量的IO延迟。所以In-page logging将日志和数据合并，将日志顺序写入改为随机写入，基于SSD对随机写和连续写IO响应延迟差异不大的特性，避免对同一位置反复擦写，提高整体性能。</p>
<p>　　In-page logging基本原理：在data buffer中，有一个in-memory log sector的结构，类似于log buffer，每个log sector是与data block对应的。在data buffer中，data和log并不合并，只是在data block和log sector之间建立了对应关系，可以将某个data block的log分离出来。但是，在SSD底层的flash memory中，数据和日志是存放在同一个block(擦除单元)，每个block都包含data page和log page。</p>
<p>　　当日志信息需要写入的时候(log buffer空间不足或者事务提交)，日志信息会写入到flash memory对应的block中，也就是说日志信息是分布在很多不同的block中的，而每个block内的日志信息是append write，所以不需要擦除的动作。当某个block中的log sector写满的时候，这时会发生一个动作，将整个block中的信息读出，然后应用block中的log sector，就可以得到最新的数据，然后整个block写入，这时，block中的log sector是空白的。</p>
<p>　　在in-page logging方法中，data buffer中的dirty block是不需要写入到flash memory中的，就算dirty buffer需要被交换出去，也不需要将它们写入flash memory中。当需要读取最新的数据，只要将block中的数据和日志信息合并，就可以得到最新的数据。</p>
<p>　　In-page logging方法，将日志和数据放在同一个擦除单元内，减少了对flash相同位置的反复擦写，而且不需要将dirty block写入到flash中，大量减少了in-place update的随机写入和擦除的动作。虽然在读取时，需要做一个merge的操作，但是因为数据和日志存放在一起，而且SSD的随机读取能力很高，in-page logging可以提高整体的性能。</p>
<p>　　SSD作为写cache-append write</p>
<p>　　SSD可以作为磁盘的写cache，因为SSD连续写比随机写性能好，比如：1M顺序写比128个8K的随机写要好很多，我们可以将大量随机写合并成为少量顺序写，增加IO的大小，减少IO(擦除)的次数，提高写入性能。这个方法与很多NoSQL产品的append write类似，即不改写数据，只追加数据，需要时做合并处理。</p>
<p>　　基本原理：当dirty block需要写入到数据文件时，并不直接更新原来的数据文件，而是首先进行IO合并，将很多个8K的dirty block合并为一个512KB的写入单元，并采用append write的方式写入到一个cache file中(保存在SSD上)，避免了擦除的动作，提高了写入性能。cache file中的数据采用循环的方式顺序写入，当cache file空间不足够时，后台进程会将cache file中的数据写入到真正的数据文件中(保存在磁盘上)，这时进行第二次IO合并，将cache file内的数据进行合并，整合成为少量的顺序写入，对于磁盘来说，最终的IO是1M的顺序写入，顺序写入只会影响吞吐量，而磁盘的吞吐量不会成为瓶颈，将IOPS的瓶颈转化为吞吐量的瓶颈，从而提升了整体系统能力。</p>
<p>　　读取数据时，必须首先读取cache file，而cache file中的数据是无序存放的，为了快速检索cache file中的数据，一般会在内存中为cache file建立一个索引，读取数据时会先查询这个索引，如果命中查询cache file，如果没有命中，再读取data file(普通磁盘)，所以，这种方法实际不仅仅是写cache，同时也起到了读cache的作用。</p>
<p>　　但是这种方法并不适合日志文件的写cache，虽然日志文件也是append write，但是因为日志文件的IO size比较小，而且必须同步写入，无法做合并处理，所以性能提升有限。</p>
<p>　　SSD作为读cache-flashcache</p>
<p>　　因为大部分数据库都是读多写少的类型，所以SSD作为数据库flashcache是优化方案中最简单的一种，它可以充分利用SSD读性能的优势，又避免了SSD写入的性能问题。实现的方法有很多种，可以在读取数据时，将数据同时写入SSD，也可以在数据被刷出buffer时，写入到SSD。读取数据时，首先在buffer中查询，然后在flashcache中查询，最后读取datafile。</p>
<p>　　SSD作为flashcache与memcache作为数据库外部cache的最大区别在于，SSD掉电后数据是不丢失的，这也引起了另外一个思考，当数据库发生故障重启后，flashcache中的数据是有效还是无效？如果是有效的，那么就必须时刻保证flashcache中数据的一致性，如果是无效的，那么flashcache同样面临一个预热的问题(这与memcache掉电后的问题一样)。目前，据我所知，基本上都认为是无效的，因为要保持flashcache中数据的一致性，非常困难。</p>
<p>　　flashcache作为内存和磁盘之间的二级cache，除了性能的提升以外，从成本的角度看，SSD的价格介于memory和disk之间，作为两者之间的一层cache，可以在性能和价格之间找到平衡。</p>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/03/01/跟踪innodb_flush_method代码/" class="pre">跟踪innodb_flush_method代码</a><a href="/2019/03/01/Percona源码安装/" class="next">Percona源码安装</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SSD与数据库"><span class="toc-text">SSD与数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三大特性"><span class="toc-text">三大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库IO特点分析"><span class="toc-text">数据库IO特点分析</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（三）——valgrind/">性能分析工具（三）——valgrind</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（二）——perf/">性能分析工具（二）——perf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/MysqlTuner使用/MysqlTuner使用/">MysqlTuner使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（一）——gprof/">性能分析工具（一）——gprof</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/Oracle 12c 的使用和学习/">Oracle 12c 的使用和学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/事务进阶/">事务进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/跟踪innodb_flush_method代码/">跟踪innodb_flush_method代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/SSD与数据库/">SSD与数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/Percona源码安装/">Percona源码安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/Linux环境下源码安装Mysql/">Linux环境下源码安装Mysql</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能分析/">性能分析</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Stockdean Mu.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>