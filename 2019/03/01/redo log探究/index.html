<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>redo log探究 | MyBlog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">redo log探究</h1><a id="logo" href="/.">MyBlog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">redo log探究</h1><div class="post-meta"><a href="/2019/03/01/redo log探究/#comments" class="comment-count"></a><p><span class="date">Mar 01, 2019</span><span><a href="/categories/database/" class="category">Database</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><hr>
<h2 id="redo-log探究"><a href="#redo-log探究" class="headerlink" title="redo log探究"></a>redo log探究</h2><p><strong>概要：</strong> 这篇文章主要的思路是redo log是如何从物理上保证页面的信息不受损失的，分别从<strong>update写入到mtr的redo log</strong>、<strong>mtr的提交</strong>和<strong>redo log写盘</strong>三部分来说明这个整体过程。</p>
<hr>
<h2 id="redo-log-整体流程"><a href="#redo-log-整体流程" class="headerlink" title="redo log 整体流程"></a>redo log 整体流程</h2><h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p><strong>实验目的：</strong>跟踪一条完整的redo日志更新流程主要分为三个流程：</p>
<ol>
<li>从 DML 操作 到 mini-transaction buffer</li>
<li>从 mini-transaction buffer 到 redo log_buffer;</li>
<li>redo log_sys buffer 的写盘。<br><strong>实验代码：</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table table_tredo(</span><br><span class="line"> dept_no int,</span><br><span class="line"> from_join_time int,</span><br><span class="line"> dept_descript varchar(50),</span><br><span class="line"> primary key (dept_no)</span><br><span class="line">);</span><br><span class="line">insert into table_tredo values (0, 2, &apos;huangxiaodong&apos;);</span><br></pre></td></tr></table></figure>
<h3 id="update-写入到mtr的redo-log"><a href="#update-写入到mtr的redo-log" class="headerlink" title="update 写入到mtr的redo log"></a>update 写入到mtr的redo log</h3><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table_tredo</span><br><span class="line"><span class="keyword">set</span> from_join_time = <span class="number">4</span></span><br><span class="line"><span class="keyword">where</span> dept_no = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>由于我们做的是<code>optimisstic update</code>并且是原地更新，因此我们直接跟踪 <code>btr_cur_update_in_place</code> 函数中间的一个片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">is_hashed = (block-&gt;index != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (is_hashed) &#123;</span><br><span class="line"> <span class="comment">/* TO DO: Can we skip this if none of the fields  index-&gt;search_info-&gt;curr_n_fields  are being updated? */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* The function row_upd_changes_ord_field_binary works only if the update vector was built for a clustered index, we must  NOT call it if index is secondary */</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (!dict_index_is_clust(index)</span><br><span class="line"> || row_upd_changes_ord_field_binary(index, update, thr,</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"> <span class="comment">/* Remove possible hash index pointer to this record */</span></span><br><span class="line"> btr_search_update_hash_on_delete(cursor);</span><br><span class="line"> &#125;</span><br><span class="line"> rw_lock_x_lock(btr_get_search_latch(index));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这是 adaptive hash 的代码，重点关注第一行的 <code>is_hashed = (block-&gt;index ! =NULL)</code> 这里面涉及到 <code>block-&gt;index</code> 也就是 block-&gt;index 和adaptive hash 密切相 关，这里需要注意下。</p>
<h4 id="update-in-place-修改了哪些页面，并且修改了这些页面的哪些位置的记录？"><a href="#update-in-place-修改了哪些页面，并且修改了这些页面的哪些位置的记录？" class="headerlink" title="update in place 修改了哪些页面，并且修改了这些页面的哪些位置的记录？"></a>update in place 修改了哪些页面，并且修改了这些页面的哪些位置的记录？</h4><p>这里我们主要说明update修改了页面的哪些东西，首先我们看 <code>btr_cur_update_in_place</code> 的关于页面更新和redo log的代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(flags &amp; BTR_KEEP_SYS_FLAG)</span><br><span class="line"> &amp;&amp; !dict_table_is_intrinsic(index-&gt;table)) &#123;</span><br><span class="line"> row_upd_rec_sys_fields(rec, <span class="literal">NULL</span>, index, offsets,</span><br><span class="line"> thr_get_trx(thr), roll_ptr);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* other code */</span></span><br><span class="line"></span><br><span class="line">row_upd_rec_in_place(rec, index, offsets, update, page_zip);</span><br><span class="line"><span class="keyword">if</span> (is_hashed) &#123;</span><br><span class="line"> rw_lock_x_unlock(btr_get_search_latch(index));</span><br><span class="line"> &#125;</span><br><span class="line">btr_cur_update_in_place_log(flags, rec, index, update,</span><br><span class="line"> trx_id, roll_ptr, mtr);</span><br></pre></td></tr></table></figure>
<p>其中 <code>row_upd_rec_in_place</code> 是update in place 的主要的写页面数据的过程，后面的 <code>btr_cur_update_in_place_log</code> 则是redo log的过程，先看update操作向页面中写了哪些 东西：</p>
<ol>
<li>更新了记录的transaction ID, Roll Pointer。</li>
<li>更新了记录中更新列的数据的长度和数据本身。</li>
<li>正如之前所看到的如果更新的列是一个hash索引并且如果该索引不是一个聚簇索引或者该 次更新导致索引的二进制顺序发生变化，则可能会移除该索引。<h4 id="update-in-place-中redo形成过程"><a href="#update-in-place-中redo形成过程" class="headerlink" title="update in place 中redo形成过程"></a>update in place 中redo形成过程</h4>在update 记录之后通过:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btr_cur_update_in_place_log(flags, rec, index, update,trx_id, roll_ptr, mtr);&#125;</span><br></pre></td></tr></table></figure>
<p>来更新redo日志，下面我们来重点分析这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************//**Writes a redo log record of updating a record in-place. */</span><br><span class="line">void</span><br><span class="line">btr_cur_update_in_place_log(</span><br><span class="line">/*========================*/</span><br><span class="line"> ulint flags, /*!&lt; in: flags */</span><br><span class="line"> const rec_t* rec, /*!&lt; in: record */</span><br><span class="line"> dict_index_t* index, /*!&lt; in: index of the record */</span><br><span class="line"> const upd_t* update, /*!&lt; in: update vector */</span><br><span class="line"> trx_id_t trx_id, /*!&lt; in: transaction id */</span><br><span class="line"> roll_ptr_t roll_ptr, /*!&lt; in: roll ptr */</span><br><span class="line"> mtr_t* mtr) /*!&lt; in: mtr */</span><br><span class="line">&#123;</span><br><span class="line"> byte* log_ptr;</span><br><span class="line"> const page_t* page = page_align(rec);</span><br><span class="line"> ut_ad(flags &lt; 256);</span><br><span class="line"> ut_ad(!!page_is_comp(page) == dict_table_is_comp(index-&gt;table));</span><br><span class="line"> log_ptr = mlog_open_and_write_index(mtr, rec, index, page_is_comp(page)</span><br><span class="line">  ? MLOG_COMP_REC_UPDATE_IN_PLACE</span><br><span class="line"> : MLOG_REC_UPDATE_IN_PLACE,</span><br><span class="line"> 1 + DATA_ROLL_PTR_LEN + 14 + 2</span><br><span class="line"> + MLOG_BUF_MARGIN);</span><br><span class="line"> if (!log_ptr) &#123;</span><br><span class="line"> /* Logging in mtr is switched off during crash recovery */</span><br><span class="line"> return;</span><br><span class="line"> &#125;</span><br><span class="line"> /* For secondary indexes, we could skip writing the dummy system fields to the redo log but we have to change redo log parsing ofMLOG_REC_UPDATE_IN_PLACE/MLOG_COMP_REC_UPDATE_IN_PLACE or we have to addnew redo log record. For now, just write dummy sys fields to the redolog if we are updating a secondary index record.*/</span><br><span class="line"> mach_write_to_1(log_ptr, flags);</span><br><span class="line"> log_ptr++;</span><br><span class="line"> if (dict_index_is_clust(index)) &#123;</span><br><span class="line"> log_ptr = row_upd_write_sys_vals_to_log(</span><br><span class="line"> index, trx_id, roll_ptr, log_ptr, mtr);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> /* Dummy system fields for a secondary index */</span><br><span class="line"> /* TRX_ID Position */</span><br><span class="line"> log_ptr += mach_write_compressed(log_ptr, 0);</span><br><span class="line"> /* ROLL_PTR */</span><br><span class="line"> trx_write_roll_ptr(log_ptr, 0);</span><br><span class="line"> log_ptr += DATA_ROLL_PTR_LEN;</span><br><span class="line"> /* TRX_ID */</span><br><span class="line"> log_ptr += mach_u64_write_compressed(log_ptr, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> mach_write_to_2(log_ptr, page_offset(rec));</span><br><span class="line"> log_ptr += 2;</span><br><span class="line"> row_upd_index_write_log(update, log_ptr, mtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ol>
<li>获取其页面的开始地址</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const page_t* page = page_align(rec);</span><br></pre></td></tr></table></figure>
<p>其中最核心的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ptr: rec所在的内存地址；align_no: 页面对齐大小这里是0x4000，即页面大小16KB*/</span></span><br><span class="line">((<span class="keyword">void</span>*)((((ulint) ptr)) &amp; ~(align_no - <span class="number">1</span>)));</span><br></pre></td></tr></table></figure>
<p>获取其页面的开始地址</p>
<ol start="2">
<li>redo日志初始化</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_ptr = mlog_open_and_write_index(mtr, rec, index, page_is_comp(page)</span><br><span class="line"> ? MLOG_COMP_REC_UPDATE_IN_PLACE</span><br><span class="line"> : MLOG_REC_UPDATE_IN_PLACE,</span><br><span class="line"> <span class="number">1</span> + DATA_ROLL_PTR_LEN + <span class="number">14</span> + <span class="number">2</span></span><br><span class="line"> + MLOG_BUF_MARGIN);</span><br></pre></td></tr></table></figure>
<p>先查看该函数的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************/</span><span class="comment">/**Opens a buffer for mlog, writes the initial log record and,if needed, the field lengths of an index.@return buffer, NULL if log mode MTR_LOG_NONE */</span></span><br><span class="line"></span><br><span class="line">byte*</span><br><span class="line">mlog_open_and_write_index(</span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"> <span class="keyword">mtr_t</span>* mtr, <span class="comment">/*!&lt; in: mtr */</span></span><br><span class="line"> <span class="keyword">const</span> byte* rec, <span class="comment">/*!&lt; in: index record or page */</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">dict_index_t</span>* index, <span class="comment">/*!&lt; in: record descriptor */</span></span><br><span class="line"> <span class="keyword">mlog_id_t</span> type, <span class="comment">/*!&lt; in: log item type */</span></span><br><span class="line"> ulint size) <span class="comment">/*!&lt; in: requested buffer size in bytes</span></span><br><span class="line"><span class="comment"> (if 0, calls mlog_close() and</span></span><br><span class="line"><span class="comment"> returns NULL) */</span></span><br><span class="line">&#123;</span><br><span class="line"> byte* log_ptr;</span><br><span class="line"> <span class="keyword">const</span> byte* log_start;</span><br><span class="line"> <span class="keyword">const</span> byte* log_end;</span><br><span class="line"> ut_ad(!!page_rec_is_comp(rec) == dict_table_is_comp(index-&gt;table));</span><br><span class="line"><span class="keyword">if</span> (!page_rec_is_comp(rec)) &#123;</span><br><span class="line"> log_start = log_ptr = mlog_open(mtr, <span class="number">11</span> + size);</span><br><span class="line"> <span class="keyword">if</span> (!log_ptr) &#123;</span><br><span class="line"> <span class="keyword">return</span>(<span class="literal">NULL</span>); <span class="comment">/* logging is disabled */</span></span><br><span class="line"> &#125;</span><br><span class="line"> log_ptr = mlog_write_initial_log_record_fast(rec, type,</span><br><span class="line"> log_ptr, mtr);</span><br><span class="line"> log_end = log_ptr + <span class="number">11</span> + size;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> ulint i;</span><br><span class="line"> ulint n = dict_index_get_n_fields(index);</span><br><span class="line"> ulint total = <span class="number">11</span> + size + (n + <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line"> ulint alloc = total;</span><br><span class="line"> <span class="keyword">if</span> (alloc &gt; <span class="keyword">mtr_buf_t</span>::MAX_DATA_SIZE) &#123;</span><br><span class="line"> alloc = <span class="keyword">mtr_buf_t</span>::MAX_DATA_SIZE;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* For spatial index, on non-leaf page, we just keep2 fields, MBR and page no. */</span></span><br><span class="line"> <span class="keyword">if</span> (dict_index_is_spatial(index)</span><br><span class="line"> &amp;&amp; !page_is_leaf(page_align(rec))) &#123;</span><br><span class="line"> n = DICT_INDEX_SPATIAL_NODEPTR_SIZE;</span><br><span class="line"> &#125;</span><br><span class="line"> log_start = log_ptr = mlog_open(mtr, alloc);</span><br><span class="line"> <span class="keyword">if</span> (!log_ptr) &#123;</span><br><span class="line"> <span class="keyword">return</span>(<span class="literal">NULL</span>); <span class="comment">/* logging is disabled */</span></span><br><span class="line"> &#125;</span><br><span class="line"> log_end = log_ptr + alloc;</span><br><span class="line"> log_ptr = mlog_write_initial_log_record_fast(</span><br><span class="line"> rec, type, log_ptr, mtr);</span><br><span class="line"> mach_write_to_2(log_ptr, n);</span><br><span class="line"> log_ptr += <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">if</span> (page_is_leaf(page_align(rec))) &#123;</span><br><span class="line"> mach_write_to_2(</span><br><span class="line"> log_ptr, dict_index_get_n_unique_in_tree(index));</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> mach_write_to_2(</span><br><span class="line"> log_ptr,</span><br><span class="line"> dict_index_get_n_unique_in_tree_nonleaf(index));</span><br><span class="line"> &#125;</span><br><span class="line"> log_ptr += <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"> <span class="keyword">dict_field_t</span>* field;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">dict_col_t</span>* col;</span><br><span class="line"> ulint len;</span><br><span class="line"> field = dict_index_get_nth_field(index, i);</span><br><span class="line"> col = dict_field_get_col(field);</span><br><span class="line"> len = field-&gt;fixed_len;</span><br><span class="line"> ut_ad(len &lt; <span class="number">0x7fff</span>);</span><br><span class="line"> <span class="keyword">if</span> (len == <span class="number">0</span></span><br><span class="line"> &amp;&amp; (DATA_BIG_COL(col))) &#123;</span><br><span class="line"> <span class="comment">/* variable-length fieldwith maximum length &gt; 255 */</span></span><br><span class="line"> len = <span class="number">0x7fff</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (col-&gt;prtype &amp; DATA_NOT_NULL) &#123;</span><br><span class="line"> len |= <span class="number">0x8000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (log_ptr + <span class="number">2</span> &gt; log_end) &#123;</span><br><span class="line"> mlog_close(mtr, log_ptr);</span><br><span class="line"> ut_a(total &gt; (ulint) (log_ptr - log_start));</span><br><span class="line"> total -= log_ptr - log_start;</span><br><span class="line"> alloc = total;</span><br><span class="line"> <span class="keyword">if</span> (alloc &gt; <span class="keyword">mtr_buf_t</span>::MAX_DATA_SIZE) &#123;</span><br><span class="line"> alloc = <span class="keyword">mtr_buf_t</span>::MAX_DATA_SIZE;</span><br><span class="line"> &#125;</span><br><span class="line"> log_start = log_ptr = mlog_open(mtr, alloc);</span><br><span class="line"> <span class="keyword">if</span> (!log_ptr) &#123;</span><br><span class="line"> <span class="keyword">return</span>(<span class="literal">NULL</span>); <span class="comment">/* logging is disabled */</span></span><br><span class="line"> &#125;</span><br><span class="line"> log_end = log_ptr + alloc;</span><br><span class="line"> &#125;</span><br><span class="line"> mach_write_to_2(log_ptr, len);</span><br><span class="line"> log_ptr += <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"> mlog_close(mtr, log_ptr);</span><br><span class="line"> log_ptr = <span class="literal">NULL</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log_ptr + size &gt; log_end) &#123;</span><br><span class="line"> mlog_close(mtr, log_ptr);</span><br><span class="line"> log_ptr = mlog_open(mtr, size);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span>(log_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对compact记录类型和redundant记录类型做了区分如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!page_rec_is_comp(rec)) &#123;</span><br><span class="line"> <span class="comment">// redundant record type redo log index</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// compact record type redo log index</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>由于我们的类型是compact因此我们只关注下面的分支。<br> <strong>从mtr中的log buffer获取redo buffer</strong><br>将重点放在<code>comapct record type</code>上面，刚开始可以看到从mtr的log buffer中获取缓冲块:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ulint i;</span><br><span class="line">ulint n = dict_index_get_n_fields(index);</span><br><span class="line">ulint total = <span class="number">11</span> + size + (n + <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">ulint alloc = total;</span><br><span class="line"><span class="keyword">if</span> (alloc &gt; <span class="keyword">mtr_buf_t</span>::MAX_DATA_SIZE) &#123;</span><br><span class="line"> alloc = <span class="keyword">mtr_buf_t</span>::MAX_DATA_SIZE;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* For spatial index, on non-leaf page, we just keep2 fields, MBR and page no. */</span></span><br><span class="line"><span class="keyword">if</span> (dict_index_is_spatial(index)</span><br><span class="line"> &amp;&amp; !page_is_leaf(page_align(rec))) &#123;</span><br><span class="line"> n = DICT_INDEX_SPATIAL_NODEPTR_SIZE;</span><br><span class="line"> &#125;</span><br><span class="line">log_start = log_ptr = mlog_open(mtr, alloc);</span><br><span class="line"><span class="keyword">if</span> (!log_ptr) &#123;</span><br><span class="line"> <span class="keyword">return</span>(<span class="literal">NULL</span>); <span class="comment">/* logging is disabled */</span></span><br><span class="line"> &#125;</span><br><span class="line">log_end = log_ptr + alloc;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ol>
<li><p>total的大小来源于几个方面:</p>
<ul>
<li>11bytes的作用？</li>
<li>size分配大小的意义？</li>
<li>(n + 2) * 2，这其中n是rec中列的个数，这又是什么意思？<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">1</span> + DATA_ROLL_PTR_LEN + <span class="number">14</span> + <span class="number">2</span> + MLOG_BUF_MARGIN;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>从mtr中的log buffer中获取缓冲块，其中log buffer是一个个block buffer以list形式 组织起来，具体可见mtr中的log类型的实现。</p>
<p><strong>mlog write initial log record fast</strong><br>接下来我们重点来看<code>srcC++{logptr = mlog_write_initial_log_record_fast(rec, type, logptr, mtr);}</code>在其中写了哪些东西。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/********************************************************/</span><span class="comment">/**Writes the initial part of a log record (3..11 bytes).If the implementation of this function is changed, allsize parameters to mlog_open() should be adjusted accordingly!@return new value of log_ptr */</span></span><br><span class="line">UNIV_INLINE</span><br><span class="line">byte*</span><br><span class="line">mlog_write_initial_log_record_fast(</span><br><span class="line"><span class="comment">/*===============================*/</span></span><br><span class="line"> <span class="keyword">const</span> byte* ptr, <span class="comment">/*!&lt; in: pointer to (inside) a buffer</span></span><br><span class="line"><span class="comment"> frame holding the file page where</span></span><br><span class="line"><span class="comment"> modification is made */</span></span><br><span class="line"> <span class="keyword">mlog_id_t</span> type, <span class="comment">/*!&lt; in: log item type: MLOG_1BYTE, ... */</span></span><br><span class="line"> byte* log_ptr,<span class="comment">/*!&lt; in: pointer to mtr log which has</span></span><br><span class="line"><span class="comment"> been opened */</span></span><br><span class="line"> <span class="keyword">mtr_t</span>* mtr) <span class="comment">/*!&lt; in/out: mtr */</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">const</span> byte* page;</span><br><span class="line"> ulint space;</span><br><span class="line"> ulint offset;</span><br><span class="line"> ut_ad(log_ptr);</span><br><span class="line"> ut_d(mtr-&gt;memo_modify_page(ptr));</span><br><span class="line"> page = (<span class="keyword">const</span> byte*) ut_align_down(ptr, UNIV_PAGE_SIZE);</span><br><span class="line"> space = mach_read_from_4(page + FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID);</span><br><span class="line"> offset = mach_read_from_4(page + FIL_PAGE_OFFSET);</span><br><span class="line"> <span class="comment">/* check whether the page is in the doublewrite buffer;the doublewrite buffer is located in pagesFSP_EXTENT_SIZE, ..., 3 * FSP_EXTENT_SIZE - 1 in thesystem tablespace */</span></span><br><span class="line"> <span class="keyword">if</span> (space == TRX_SYS_SPACE</span><br><span class="line"> &amp;&amp; offset &gt;= FSP_EXTENT_SIZE &amp;&amp; offset &lt; <span class="number">3</span> * FSP_EXTENT_SIZE) &#123;</span><br><span class="line"> <span class="keyword">if</span> (buf_dblwr_being_created) &#123;</span><br><span class="line"> <span class="comment">/* Do nothing: we only come to this branch in an  InnoDB database creation. We do not redo log  anything for the doublewrite buffer pages. */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>(log_ptr);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> ib::error() &lt;&lt; <span class="string">"Trying to redo log a record of type "</span></span><br><span class="line"> &lt;&lt; type &lt;&lt; <span class="string">" on page "</span></span><br><span class="line"> &lt;&lt; <span class="keyword">page_id_t</span>(space, offset) &lt;&lt; <span class="string">"in the"</span></span><br><span class="line"> <span class="string">" doublewrite buffer, continuing anyway."</span></span><br><span class="line"><span class="string">" Please post a bug report to"</span></span><br><span class="line"><span class="string">" bugs.mysql.com."</span>;</span><br><span class="line"> ut_ad(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span>(mlog_write_initial_log_record_low(type, space, offset,</span><br><span class="line"> log_ptr, mtr));</span><br></pre></td></tr></table></figure>
<p>这里我有一个疑问即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Do nothing: we only come to this branch in an InnoDB database creation. We do not redo loganything for the doublewrite buffer pages. */</span></span><br></pre></td></tr></table></figure>
<p>他说这里的<code>doublewrite buffer pages</code>不需要redo log,为什么不要？ 接下来再看</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Writes a log record about an operation.param[in] type redo log record type*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@param[in] space_id tablespace identifier</span></span><br><span class="line"><span class="comment">//@param[in] page_no page number</span></span><br><span class="line"><span class="comment">//@param[in,out] log_ptr current end of mini-transaction log</span></span><br><span class="line"><span class="comment">//@param[in,out] mtr mini-transaction</span></span><br><span class="line"><span class="comment">//@return end of mini-transaction log </span></span><br><span class="line"></span><br><span class="line">UNIV_INLINE</span><br><span class="line">byte*</span><br><span class="line">mlog_write_initial_log_record_low(</span><br><span class="line"> <span class="keyword">mlog_id_t</span> type,</span><br><span class="line"> ulint space_id,</span><br><span class="line"> ulint page_no,</span><br><span class="line"> byte* log_ptr,</span><br><span class="line"> <span class="keyword">mtr_t</span>* mtr)</span><br><span class="line">&#123;</span><br><span class="line"> ut_ad(type &lt;= MLOG_BIGGEST_TYPE);</span><br><span class="line"> ut_ad(type == MLOG_FILE_NAME</span><br><span class="line"> || type == MLOG_FILE_DELETE</span><br><span class="line"> || type == MLOG_FILE_CREATE2</span><br><span class="line"> || type == MLOG_FILE_RENAME2</span><br><span class="line"> || type == MLOG_INDEX_LOAD</span><br><span class="line"> || type == MLOG_TRUNCATE</span><br><span class="line"> || mtr-&gt;is_named_space(space_id));</span><br><span class="line"> mach_write_to_1(log_ptr, type);</span><br><span class="line"> log_ptr++;</span><br><span class="line"> log_ptr += mach_write_compressed(log_ptr, space_id);</span><br><span class="line"> log_ptr += mach_write_compressed(log_ptr, page_no);</span><br><span class="line"> mtr-&gt;added_rec();</span><br><span class="line"> <span class="keyword">return</span>(log_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入事务的类型，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spaceid, pageno.</span><br></pre></td></tr></table></figure>
<p>这里仍有疑问：即在开始为什么要这样断言？</p>
<ul>
<li>表示日志不能超过其上限srcC++{ MLOGBIGGESTTYPE}</li>
<li>下面的断言说明了事务的各种情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ut_ad(</span><br><span class="line"> /** note the first use of a tablespace file since checkpoint */</span><br><span class="line"> type == MLOG_FILE_NAME</span><br><span class="line"> /** delete a tablespace file that starts with (space_id,page_no) */</span><br><span class="line"> || type == MLOG_FILE_DELETE</span><br><span class="line"> /** log record about creating an .ibd file, with format */</span><br><span class="line"> || type == MLOG_FILE_CREATE2</span><br><span class="line"> /** rename a tablespace file that starts with (space_id,page_no) */</span><br><span class="line"> || type == MLOG_FILE_RENAME2</span><br><span class="line"> /** notify that an index tree is being loaded without writing</span><br><span class="line"> redo log about individual pages */</span><br><span class="line"> || type == MLOG_INDEX_LOAD</span><br><span class="line"> /** Table is being truncated. (Marked only for file-per-table) */</span><br><span class="line"> || type == MLOG_TRUNCATE</span><br><span class="line"> /*Check if a tablespace is associated with the mini-transaction(needed for generating a MLOG_FILE_NAME record)*/</span><br><span class="line"> || mtr-&gt;is_named_space(space_id));</span><br></pre></td></tr></table></figure>
<p>下面是长度的压缩算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*********************************************************/</span><span class="comment">/**Writes a ulint in a compressed form where the first byte codes thelength of the stored ulint. We look at the most significant bits ofthe byte. If the most significant bit is zero, it means 1-byte storage,else if the 2nd bit is 0, it means 2-byte storage, else if 3rd is 0,it means 3-byte storage, else if 4th is 0, it means 4-byte storage,else the storage is 5-byte.@return compressed size in bytes */</span></span><br><span class="line"> </span><br><span class="line">UNIV_INLINE</span><br><span class="line">ulint</span><br><span class="line">mach_write_compressed(</span><br><span class="line"><span class="comment">/*==================*/</span></span><br><span class="line"> byte* b, <span class="comment">/*!&lt; in: pointer to memory where to store */</span></span><br><span class="line"> ulint n) <span class="comment">/*!&lt; in: ulint integer (&lt; 2^32) to be stored */</span></span><br><span class="line">&#123;</span><br><span class="line"> ut_ad(b);</span><br><span class="line"> <span class="keyword">if</span> (n &lt; <span class="number">0x80</span>) &#123;</span><br><span class="line"> <span class="comment">/* 0nnnnnnn(7 bits) */</span></span><br><span class="line"> mach_write_to_1(b, n);</span><br><span class="line"> <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0x4000</span>) &#123;</span><br><span class="line"> <span class="comment">/* 10nnnnnn nnnnnnnn (14 bits) */</span></span><br><span class="line"> mach_write_to_2(b, n | <span class="number">0x8000</span>);</span><br><span class="line"> <span class="keyword">return</span>(<span class="number">2</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0x200000</span>) &#123;</span><br><span class="line"> <span class="comment">/* 110nnnnn nnnnnnnn nnnnnnnn (21 bits) */</span></span><br><span class="line"> mach_write_to_3(b, n | <span class="number">0xC00000</span>);</span><br><span class="line"> <span class="keyword">return</span>(<span class="number">3</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0x10000000</span>) &#123;</span><br><span class="line"> <span class="comment">/* 1110nnnn nnnnnnnn nnnnnnnn nnnnnnnn (28 bits) */</span></span><br><span class="line"> mach_write_to_4(b, n | <span class="number">0xE0000000</span>);</span><br><span class="line"> <span class="keyword">return</span>(<span class="number">4</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">/* 11110000 nnnnnnnn nnnnnnnn nnnnnnnn nnnnnnnn (32 bits) */</span></span><br><span class="line"> mach_write_to_1(b, <span class="number">0xF0</span>);</span><br><span class="line"> mach_write_to_4(b + <span class="number">1</span>, n);</span><br><span class="line"> <span class="keyword">return</span>(<span class="number">5</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>写入redo 记录个数和唯一性列的个数</strong><br>接下来的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mach_write_to_2(log_ptr, n);</span><br><span class="line">log_ptr += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (page_is_leaf(page_align(rec))) &#123;</span><br><span class="line"> mach_write_to_2(</span><br><span class="line"> log_ptr, dict_index_get_n_unique_in_tree(index));</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> mach_write_to_2(</span><br><span class="line"> log_ptr,</span><br><span class="line"> dict_index_get_n_unique_in_tree_nonleaf(index));</span><br><span class="line"> &#125;</span><br><span class="line">log_ptr += <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>两步：</p>
<ol>
<li>写入记录的个数。</li>
<li>写入 srcC++{index-&gt;nuniq/<em>!&lt; number of fields from the beginning which are enough to determine an index entry uniquely </em>/} 但是不知道： 这个域的作用是什么？ 以及为什么要写入？ 回去查资料发现这个srcC++{nuniq}代表的是记录中唯一性列的个数</li>
</ol>
<blockquote>
<p>写入行记录上决定唯一性的列的个数，占两个字节 (dictindexgetnuniqueintree) 对于聚集索引，就是PK上的列数；对于二级索引，就是二级索引列+PK列个数</p>
</blockquote>
<p> <strong>写入redo记录中各列的长度</strong><br>如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"> <span class="keyword">dict_field_t</span>* field;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">dict_col_t</span>* col;</span><br><span class="line"> ulint len;</span><br><span class="line"> field = dict_index_get_nth_field(index, i);</span><br><span class="line"> col = dict_field_get_col(field);</span><br><span class="line"> len = field-&gt;fixed_len;</span><br><span class="line"> ut_ad(len &lt; <span class="number">0x7fff</span>);</span><br><span class="line"> <span class="keyword">if</span> (len == <span class="number">0</span></span><br><span class="line"> &amp;&amp; (DATA_BIG_COL(col))) &#123;</span><br><span class="line"> <span class="comment">/* variable-length field  with maximum length &gt; 255 */</span></span><br><span class="line"> len = <span class="number">0x7fff</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (col-&gt;prtype &amp; DATA_NOT_NULL) &#123;</span><br><span class="line"> len |= <span class="number">0x8000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (log_ptr + <span class="number">2</span> &gt; log_end) &#123;</span><br><span class="line"> mlog_close(mtr, log_ptr);</span><br><span class="line"> ut_a(total &gt; (ulint) (log_ptr - log_start));</span><br><span class="line"> total -= log_ptr - log_start;</span><br><span class="line"> alloc = total;</span><br><span class="line"> <span class="keyword">if</span> (alloc &gt; <span class="keyword">mtr_buf_t</span>::MAX_DATA_SIZE) &#123;</span><br><span class="line"> alloc = <span class="keyword">mtr_buf_t</span>::MAX_DATA_SIZE;</span><br><span class="line"> &#125;</span><br><span class="line"> log_start = log_ptr = mlog_open(mtr, alloc);</span><br><span class="line"> <span class="keyword">if</span> (!log_ptr) &#123;</span><br><span class="line"> <span class="keyword">return</span>(<span class="literal">NULL</span>); <span class="comment">/* logging is disabled */</span></span><br><span class="line"> &#125;</span><br><span class="line"> log_end = log_ptr + alloc;</span><br><span class="line"> &#125;</span><br><span class="line"> mach_write_to_2(log_ptr, len);</span><br><span class="line"> log_ptr += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则主要是写入记录中每个列的长度值得注意的是：</p>
<ul>
<li>当是TEXT,BLOG等大记录时：len = 0x7fff</li>
<li>这里的 col-&gt;prtype 决定了一个列的精确类型：<blockquote>
<p>数据类型varchar,char,int等等。<br>charset code（字符集编码）<br>是否可以为NULL<br>是否是有符号的<br>是否是一个binary string<br>是否是两个字节存储的varchar类型</p>
</blockquote>
</li>
</ul>
<p>另外这里的 <code>DATA_NOT_NULL</code> 是说明该类型是否为NULL的掩码。<br>最后是如果由于记录中的列的数目过多，从而导致一个block buffer装不下，则分配一个新的块。<br> <strong>最后的判断</strong><br>接下来是最后的 <code>log_ptr</code> 的长度判断，主要这里的 size 的定义为请求的buffer size</p>
<ul>
<li>如果为0则 <code>log_ptr=NULL</code></li>
<li>如果 <code>log_ptr + size &gt; log_end</code> ，则表示当前缓冲无法分配 size 的内存大小， 重新分配一个block buffer。</li>
<li><strong>写入redo log body</strong><br><strong>写入flag标志</strong><br>接下来我们可以看到：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For secondary indexes, we could skip writing the dummy system fields to the redo log but we have to change redo log parsing ofMLOG_REC_UPDATE_IN_PLACE/MLOG_COMP_REC_UPDATE_IN_PLACE or we have to addnew redo log record. For now, just write dummy sys fields to the redo log if we are updating a secondary index record.*/</span></span><br><span class="line">mach_write_to_1(log_ptr, flags);</span><br><span class="line">log_ptr++;</span><br></pre></td></tr></table></figure>
<p>这个 flags 说的是：在 <code>btr_cur</code> 上面的操作类型，但是它的具体作用这里也是未知？<br> <strong>写入记录的域中的TRXID,ROLLID</strong><br>代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************/</span><span class="comment">/**Writes into the redo log the values of trx id and roll ptr and enough infoto determine their positions within a clustered index record.@return new pointer to mlog */</span></span><br><span class="line"></span><br><span class="line">byte*</span><br><span class="line">row_upd_write_sys_vals_to_log(</span><br><span class="line"><span class="comment">/*==========================*/</span></span><br><span class="line"> <span class="keyword">dict_index_t</span>* index, <span class="comment">/*!&lt; in: clustered index */</span></span><br><span class="line"> <span class="keyword">trx_id_t</span> trx_id, <span class="comment">/*!&lt; in: transaction id */</span></span><br><span class="line"> <span class="keyword">roll_ptr_t</span> roll_ptr,<span class="comment">/*!&lt; in: roll ptr of the undo log record */</span></span><br><span class="line"> byte* log_ptr,<span class="comment">/*!&lt; pointer to a buffer of size &gt; 20 openedin mlog */</span></span><br><span class="line"> <span class="keyword">mtr_t</span>* mtr MY_ATTRIBUTE((unused))) <span class="comment">/*!&lt; in: mtr */</span></span><br><span class="line">&#123;</span><br><span class="line"> ut_ad(dict_index_is_clust(index));</span><br><span class="line"> ut_ad(mtr);</span><br><span class="line"> log_ptr += mach_write_compressed(log_ptr,</span><br><span class="line"> dict_index_get_sys_col_pos(</span><br><span class="line"> index, DATA_TRX_ID));</span><br><span class="line"> trx_write_roll_ptr(log_ptr, roll_ptr);</span><br><span class="line"> log_ptr += DATA_ROLL_PTR_LEN;</span><br><span class="line"> log_ptr += mach_u64_write_compressed(log_ptr, trx_id);</span><br><span class="line"> <span class="keyword">return</span>(log_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分三步进行：</p>
<ol>
<li>使用压缩方式写入 DATA_TRX_ID 在物理存储中的的位置（从0开始）</li>
<li>写入Roll ID</li>
<li>以压缩方式写入Trx ID</li>
</ol>
<p><strong>写入记录在页中的偏移</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mach_write_to_2(log_ptr, page_offset(rec));</span><br><span class="line">log_ptr += 2;</span><br></pre></td></tr></table></figure>
<p>写入当前记录在页中的相对偏移。</p>
<p><strong>写入更新列的infobits和更新列的总数</strong><br>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n_fields = upd_get_n_fields(update);</span><br><span class="line">buf_end = log_ptr + MLOG_BUF_MARGIN;</span><br><span class="line">mach_write_to_1(log_ptr, update-&gt;info_bits);</span><br><span class="line">log_ptr++;</span><br><span class="line">log_ptr += mach_write_compressed(log_ptr, n_fields);</span><br></pre></td></tr></table></figure>
<p> <strong>写入更新列的在记录中的次序和更新列的大小和更新的列</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">upd_field = upd_get_nth_field(update, i);</span><br><span class="line">new_val = &amp;(upd_field-&gt;new_val);</span><br><span class="line">len = dfield_get_len(new_val);</span><br><span class="line"><span class="comment">/* If this is a virtual column, mark it using specialfield_no */</span></span><br><span class="line">ulint field_no = upd_fld_is_virtual_col(upd_field)</span><br><span class="line"> ? REC_MAX_N_FIELDS + upd_field-&gt;field_no</span><br><span class="line"> : upd_field-&gt;field_no;</span><br><span class="line">log_ptr += mach_write_compressed(log_ptr, field_no);</span><br><span class="line">log_ptr += mach_write_compressed(log_ptr, len);</span><br></pre></td></tr></table></figure>
<p>接下来是写入记录了，如果记录过大则需要几个block buffer来装载。</p>
<p> <strong>总结</strong><br>此时在mtr中的<code>redo log buffer</code>中此时的数据为（一共为<em>0x29bytes</em>）：<br><img src="/2019/03/01/redo log探究/1531298477216.png" alt="Alt text"><br><img src="/2019/03/01/redo log探究/1531298483668.png" alt="Alt text"><br>总结为下表：<br><img src="/2019/03/01/redo log探究/1531298504791.png" alt="Alt text"></p>
<h3 id="mtr的提交-mtr-rede-log-buffer-写入redo-log-sys-buffer"><a href="#mtr的提交-mtr-rede-log-buffer-写入redo-log-sys-buffer" class="headerlink" title="mtr的提交 - mtr rede log buffer 写入redo log_sys buffer"></a>mtr的提交 - mtr rede log buffer 写入redo log_sys buffer</h3><h4 id="mtr的提交过程"><a href="#mtr的提交过程" class="headerlink" title="mtr的提交过程"></a>mtr的提交过程</h4><p>上面的redo log过程完毕之后从 <code>row_upd_clust_rec</code> 函数中的 <code>btr_cur_optimistic_update</code> 转到 <code>mtr_commit</code> 来提交事务，先看 <code>mtr_commit</code> 的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Commit a mini-transaction. */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="keyword">mtr_t</span>::commit()</span><br><span class="line">&#123;</span><br><span class="line"> ut_ad(is_active());</span><br><span class="line"> ut_ad(!is_inside_ibuf());</span><br><span class="line"> ut_ad(m_impl.m_magic_n == MTR_MAGIC_N);</span><br><span class="line"> m_impl.m_state = MTR_STATE_COMMITTING;</span><br><span class="line"> <span class="comment">/* This is a dirty read, for debugging. */</span></span><br><span class="line"> ut_ad(!recv_no_log_write);</span><br><span class="line"> <span class="function">Command <span class="title">cmd</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"> <span class="keyword">if</span> (m_impl.m_modifications</span><br><span class="line"> &amp;&amp; (m_impl.m_n_log_recs &gt; <span class="number">0</span></span><br><span class="line"> || m_impl.m_log_mode == MTR_LOG_NO_REDO)) &#123;</span><br><span class="line"> ut_ad(!srv_read_only_mode</span><br><span class="line"> || m_impl.m_log_mode == MTR_LOG_NO_REDO);</span><br><span class="line"> cmd.execute();</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> cmd.release_all();</span><br><span class="line"> cmd.release_resources();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注的几个方面是：</p>
<ul>
<li><code>m_impl.m_state</code> : 说明事务的状态，它有以下几个状态：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum mtr_state_t &#123;</span><br><span class="line"> MTR_STATE_INIT = 0,</span><br><span class="line"> MTR_STATE_ACTIVE = 12231,</span><br><span class="line"> MTR_STATE_COMMITTING = 56456,</span><br><span class="line"> MTR_STATE_COMMITTED = 34676</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Class Command</code> 作为 <code>mtr_t</code> 的内部类，它的作用是什么？为什么要这样设计？基于什 么样的原理？另外还要提到的一点是：为什么要在<code>mtr_t</code> 中将 <code>m_impl</code> 作为一个结构 体设计？</li>
<li><code>cmd.execute()</code> 是事务提交的主要函数，在下面将详细分析先看其代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Write the redo log record, add dirty pages to the flush list and releasethe resources. */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="keyword">mtr_t</span>::Command::execute()</span><br><span class="line">&#123;</span><br><span class="line"> ut_ad(m_impl-&gt;m_log_mode != MTR_LOG_NONE);</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">const</span> ulint len = prepare_write()) &#123;</span><br><span class="line"> finish_write(len);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (m_impl-&gt;m_made_dirty) &#123;</span><br><span class="line"> log_flush_order_mutex_enter();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* It is now safe to release the log mutex because theflush_order mutex will ensure that we are the first oneto insert into the flush list. */</span></span><br><span class="line"> log_mutex_exit();</span><br><span class="line"> m_impl-&gt;m_mtr-&gt;m_commit_lsn = m_end_lsn;</span><br><span class="line"> release_blocks();</span><br><span class="line"> <span class="keyword">if</span> (m_impl-&gt;m_made_dirty) &#123;</span><br><span class="line"> log_flush_order_mutex_exit();</span><br><span class="line"> &#125;</span><br><span class="line"> release_latches();</span><br><span class="line"> release_resources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="提交准备：-mtr-t-Command-prepare-write"><a href="#提交准备：-mtr-t-Command-prepare-write" class="headerlink" title="提交准备： mtr_t::Command::prepare_write()"></a>提交准备： mtr_t::Command::prepare_write()</h4><p><strong>1. 代码1</strong> ：定义了各种不同的日志模式下日志的写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (m_impl-&gt;m_log_mode) &#123;</span><br><span class="line"><span class="keyword">case</span> MTR_LOG_SHORT_INSERTS:</span><br><span class="line"> ut_ad(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">/* fall through (write no redo log) */</span></span><br><span class="line"><span class="keyword">case</span> MTR_LOG_NO_REDO:</span><br><span class="line"><span class="keyword">case</span> MTR_LOG_NONE:</span><br><span class="line"> ut_ad(m_impl-&gt;m_log.size() == <span class="number">0</span>);</span><br><span class="line"> log_mutex_enter();</span><br><span class="line"> m_end_lsn = m_start_lsn = log_sys-&gt;lsn;</span><br><span class="line"> <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">case</span> MTR_LOG_ALL:</span><br><span class="line"> <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 代码2 ：</strong>如果redo log sys buffer空间不足的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ulint len = m_impl-&gt;m_log.size();</span><br><span class="line">ulint n_recs = m_impl-&gt;m_n_log_recs;</span><br><span class="line">ut_ad(len &gt; <span class="number">0</span>);</span><br><span class="line">ut_ad(n_recs &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (len &gt; log_sys-&gt;buf_size / <span class="number">2</span>) &#123;</span><br><span class="line"> log_buffer_extend((len + <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line"> &#125;</span><br><span class="line">ut_ad(m_impl-&gt;m_n_log_recs == n_recs);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>log_sys-&gt;buf_size</code> 是 redo log可用buffer的大小么？ 暂时认为就是可用的log buffer的大小 ，可以看到当一个mini-transaction提交的redo log 日志大小大于当前redo logsys的buffer的一半时，需要扩展logsys的buffer大小至 <code>(len+1)*2</code> 。那么接下需要关注的是： <code>log_buffer_extend</code> 做了哪些动作，它的内存是向谁申请的呢？</p>
<p>由于目前程序无法运行该分支，具体的细节可能不是特别清楚，但是可以知道的大概步骤是 首先刷盘，并且有可能重新分配redo logsys 的buffer的大小。<br><strong>3. 代码3 ：</strong>当space id为system tablespace 或者 undo tablespace 的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fil_space_t</span>* space = m_impl-&gt;m_user_space;</span><br><span class="line"><span class="keyword">if</span> (space != <span class="literal">NULL</span> &amp;&amp; is_system_or_undo_tablespace(space-&gt;id)) &#123;</span><br><span class="line"> <span class="comment">/* Omit MLOG_FILE_NAME for predefined tablespaces. */</span></span><br><span class="line"> space = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断当前的 <code>space-&gt;id</code> 是否属于undo段或者system的表空间，在调试中发现以下几点：</p>
<ul>
<li>system space id 为0</li>
<li>此时好像并没有分配undo的表空间，但是之前已经写了undo log，但是在代码里发现： <code>srv_undo_space_id_start</code> 为0，这是说明没有为 undo log 分配table space么？</li>
</ul>
<p><strong>4. 代码4 ：</strong>检查当前mtr所操纵的Tablespace是否为第一次修改，如果是则写入 MLOGFILENAME日志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fil_names_write_if_was_clean(space, m_impl-&gt;m_mtr)) &#123;</span><br><span class="line"> <span class="comment">/* This mini-transaction was the first one to modifythis tablespace since the latest checkpoint, so some MLOG_FILE_NAME records were appended to m_log. */</span></span><br><span class="line"> ut_ad(m_impl-&gt;m_n_log_recs &gt; n_recs);</span><br><span class="line"> mlog_catenate_ulint(</span><br><span class="line"> &amp;m_impl-&gt;m_log, MLOG_MULTI_REC_END, MLOG_1BYTE);</span><br><span class="line"> len = m_impl-&gt;m_log.size();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>分两步：</p>
<ol>
<li><code>fil_names_write_if_was_clean</code> 的判断。</li>
<li>写mtr日志结束标记</li>
</ol>
<p><strong><code>fil_names_write_if_was_clean</code> 检查该space是否从last checkpoint 第一次修改</strong><br>该函数会形成一个比较深的调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fil_op_write_log</span><br><span class="line">fil_name_write</span><br><span class="line">fil_name_write</span><br><span class="line">fil_names_write</span><br><span class="line">fil_names_dirty_and_write</span><br><span class="line">fil_names_write_if_was_clean</span><br></pre></td></tr></table></figure>
<p>这些调用链主要做了以下几个事情：</p>
<ol>
<li>检测该页是否是刷出之后第一次修改<code>(func:fil_names_write_if_was_clean</code>)：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="keyword">bool</span> was_clean = space-&gt;max_lsn == <span class="number">0</span>;</span><br><span class="line">ut_ad(space-&gt;max_lsn &lt;= log_sys-&gt;lsn);</span><br><span class="line">space-&gt;max_lsn = log_sys-&gt;lsn;</span><br><span class="line"><span class="keyword">if</span> (was_clean) &#123;</span><br><span class="line"> fil_names_dirty_and_write(space, mtr);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们可以得知：每次脏页被刷盘之后，其页面上的LSN 都会被标记为 0， 上面正是通过判断一个Tablespace 的最大的LSN是否为0，来判断该Tablespace是否为第 一次修改。</p>
<ol start="2">
<li>将当前的space相关的描述加入到 <code>fil_system-&gt;named_spaces</code> 的链表上面 (<code>func:fil_names_dirty_and_write</code>)</li>
<li>我们分析函数: <code>fil_op_write_log</code> 向 <code>mtr redo log buffer</code>中写入了哪些东西，其中大 部分函数之前都接触过，因此这里不再该函数，不过需要额外注意的是该函数中对 redo log 类型为 <code>MLOG_FILE_RENAME2</code> 做了很多额外的判断，这点在以后需要多加注意 ，下面 给出该函数的具体的写的数据：<br><img src="/2019/03/01/redo log探究/1531299617932.png" alt="Alt text"><br>该函数的注释则说明了该函数的作用：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This mini-transaction was the first one to modifythis tablespace since the latest checkpoint, sosome MLOG_FILE_NAME records were appended to m_log. */</span></span><br></pre></td></tr></table></figure>
<p>这样方便在recovery的时候，方便读入所需的表空间文件，减少redo。<br><strong>第一次修改该Tablespace时的mtr redo 结束标记</strong><br>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This mini-transaction was the first one to modifythis tablespace since the latest checkpoint, sosome MLOG_FILE_NAME records were appended to m_log. */</span></span><br><span class="line">ut_ad(m_impl-&gt;m_n_log_recs &gt; n_recs);</span><br><span class="line">mlog_catenate_ulint(</span><br><span class="line"> &amp;m_impl-&gt;m_log, MLOG_MULTI_REC_END, MLOG_1BYTE);</span><br><span class="line">len = m_impl-&gt;m_log.size();</span><br></pre></td></tr></table></figure>
<p>可以看到其在<code>mtr redo log buffer</code>中写入了类型为 <code>MLOG_MULTI_REC_END</code> 的日志。<br><img src="/2019/03/01/redo log探究/1531299829285.png" alt="Alt text"><br><strong>5. 代码5 ：如果不是第一次修改该页面时的mtr redo log结束标记</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* This was not the first time of dirtying atablespace since the latest checkpoint. */</span></span><br><span class="line"> ut_ad(n_recs == m_impl-&gt;m_n_log_recs);</span><br><span class="line"><span class="keyword">if</span> (n_recs &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> ut_ad(n_recs == <span class="number">1</span>);</span><br><span class="line"> <span class="comment">/* Flag the single log record as theonly record in this mini-transaction. */</span></span><br><span class="line"> *m_impl-&gt;m_log.front()-&gt;begin()</span><br><span class="line"> |= MLOG_SINGLE_REC_FLAG;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;<span class="comment">/* Because this mini-transaction comprisesmultiple log records, append MLOG_MULTI_REC_END at the end. */</span></span><br><span class="line"> mlog_catenate_ulint(</span><br><span class="line"> &amp;m_impl-&gt;m_log, MLOG_MULTI_REC_END,</span><br><span class="line"> MLOG_1BYTE);</span><br><span class="line"> len++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑很简单：</p>
<ul>
<li>如果该mtr只有单条redo log record(这里我很好奇的是为什么undo log写的redo log不算在 内？)，则修改之前的日志类型<br>为： <code>type|MLOG_SINGLE_REC_FLAG</code> 。</li>
<li>如果该mtr为多条redo log record，则在末尾写入： <code>MLOG_MULTI_REC_END</code> 。<h4 id="检查-redo-log-sys-buffer-的空间是否足够-void-log-margin-checkpoint-age"><a href="#检查-redo-log-sys-buffer-的空间是否足够-void-log-margin-checkpoint-age" class="headerlink" title="检查 redo log_sys buffer 的空间是否足够 - void log_margin_checkpoint_age"></a>检查 redo log_sys buffer 的空间是否足够 - <code>void log_margin_checkpoint_age</code></h4>首先通过 <code>ulint margin = log_calculate_actual_len(len)</code>; 来计算mtr产生的redo 日志的长度，这里附加了每个<code>redo log block</code> 的 header 和 tailer 的长度。<br><strong>1. 代码1 ：</strong> 检查mtr的redo log length是否超过 redo log group的长度：96M<br>这里 <code>log_sys-&gt;log_group_capacity</code> 是日志组两个file：iblogfile0,iblogfile1的总 长度，这两个文件的长度均为：48M</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (margin &gt; log_sys-&gt;log_group_capacity) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* return with warning output to avoid deadlock */</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (!log_has_printed_chkp_margine_warning</span><br><span class="line"> || difftime(time(<span class="literal">NULL</span>),</span><br><span class="line"> log_last_margine_warning_time) &gt; <span class="number">15</span>) &#123;</span><br><span class="line"> log_has_printed_chkp_margine_warning = <span class="literal">true</span>;</span><br><span class="line"> log_last_margine_warning_time = time(<span class="literal">NULL</span>);</span><br><span class="line"> ib::error() &lt;&lt; <span class="string">"The transaction log files are too"</span></span><br><span class="line"> <span class="string">" small for the single transaction log (size="</span></span><br><span class="line"> &lt;&lt; len &lt;&lt; <span class="string">"). So, the last checkpoint age"</span></span><br><span class="line"> <span class="string">" might exceed the log group capacity "</span></span><br><span class="line"> &lt;&lt; log_sys-&gt;log_group_capacity &lt;&lt; <span class="string">"."</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.  代码2 ：</strong> 如果mtr的 redo log length + LSN - checkpointLSN超过了 redo log group 的总长度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Our margin check should ensure that we never reach this condition.Try to do checkpoint once. We cannot keep waiting here as it mightresult in hang in case the current mtr has latch on oldest lsn */</span></span><br><span class="line"><span class="keyword">if</span> (log_sys-&gt;lsn - log_sys-&gt;last_checkpoint_lsn + margin</span><br><span class="line"> &gt; log_sys-&gt;log_group_capacity) &#123;</span><br><span class="line"> <span class="comment">/* The log write of 'len' might overwrite the transaction logafter the last checkpoint. Makes checkpoint. */</span></span><br><span class="line"> <span class="keyword">bool</span> flushed_enough = <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">if</span> (log_sys-&gt;lsn - log_buf_pool_get_oldest_modification()</span><br><span class="line"> + margin</span><br><span class="line"> &lt;= log_sys-&gt;log_group_capacity) &#123;</span><br><span class="line"> flushed_enough = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> log_sys-&gt;check_flush_or_checkpoint = <span class="literal">true</span>;</span><br><span class="line"> log_mutex_exit();</span><br><span class="line"> DEBUG_SYNC_C(<span class="string">"margin_checkpoint_age_rescue"</span>);</span><br><span class="line"> <span class="keyword">if</span> (!flushed_enough) &#123;</span><br><span class="line"> os_thread_sleep(<span class="number">100000</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> log_checkpoint(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"> log_mutex_enter();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先可以看到 <code>log_sys-&gt;lsn - log_sys-&gt;last_checkpoint_lsn + margin &gt;log_sys-&gt;log_group_capacity</code> 表示至上次checkpoint开始，产生的redo log 超过redo log group 的长度，这可能会导致持久化时，redo日志不能刷盘，因此这时必须先将buffer pool里最先修改的page刷盘，因此这里做了一次检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (log_sys-&gt;lsn - log_buf_pool_get_oldest_modification()</span><br><span class="line"> + margin&lt;= log_sys-&gt;log_group_capacity) &#123;</span><br><span class="line">  flushed_enough = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>检查 logsys的LSN减去bufferpool 此时<em>oldest modification</em> 的LSN的小于redo log group的长度，这样可以不用刷buffer pool 中的页面到磁盘，减少开销。另外此时的需要 对部分的redo log buffer 刷盘见 <code>log_checkpoint</code> 函数。<br><strong>3. 代码3 ：</strong> redo log checkpoint 简述<br>由于代码里面跟不到该分支，因此这里简析上面的 <code>log_checkpoint</code> 步骤如下：</p>
<ul>
<li><code>fil_names_clear</code> ：</li>
</ul>
<ol>
<li>如果当前有事务正在提交，则追加一个redo 记录，但是这里不太清楚为什么要这样做？</li>
<li>将mtr的redo log buffer写入到redo logsys的buffer中，关键函数： log_write_low</li>
<li>开启一个mtr将当前所有打开的并且需要刷盘的Tablespace写一个 <code>MLOG_FILE_NAME</code> 类型的日志到 mtr的redo log buffer中，如果一次提交到mtr redo log buffer的日志过多，可能会分多次提交。每次提交都会提交一个mtr redo log结束标记: <code>MLOG_MULTI_REC_END</code> , <code>MLOG_SINGLE_REC_FLAG</code> ，并且会额外写入 一个 <code>MLOG_CHECKPOINT</code> 和8byte的checkpoint LSN。</li>
<li>之后会用下面的两条语句做：写日志到日志缓冲和释放资源等动作。</li>
</ol>
<ul>
<li>将日志刷盘： <code>log_write_up_to</code> : 主要是redo log的刷盘操作，将在稍后分析。</li>
<li>最后在 log group header 写入此次checkpoint 的相关信息 ： <code>log_write_checkpoint_info(sync);</code> 写入此次的 checkpoint 的<code>checkpoint_lsn</code>, <code>checkpoint_no</code> 等信息。<h4 id="至此-prepare-write-完毕，接下来看-mtr-t-Command-finish-write"><a href="#至此-prepare-write-完毕，接下来看-mtr-t-Command-finish-write" class="headerlink" title="至此 prepare_write 完毕，接下来看 mtr_t::Command::finish_write"></a>至此 prepare_write 完毕，接下来看 <code>mtr_t::Command::finish_write</code></h4>这是将mtr redo log buffer 里面的redo log record 写入 redo logsys buffer 的主要函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Append the redo log records to the redo log buffer@param[in] len number of bytes to write */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="keyword">mtr_t</span>::Command::finish_write(</span><br><span class="line"> ulint len)</span><br><span class="line">&#123;</span><br><span class="line"> ut_ad(m_impl-&gt;m_log_mode == MTR_LOG_ALL);</span><br><span class="line"> ut_ad(log_mutex_own());</span><br><span class="line"> ut_ad(m_impl-&gt;m_log.size() == len);</span><br><span class="line"> ut_ad(len &gt; <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (m_impl-&gt;m_log.is_small()) &#123;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">mtr_buf_t</span>::<span class="keyword">block_t</span>* front = m_impl-&gt;m_log.front();</span><br><span class="line"> ut_ad(len &lt;= front-&gt;used());</span><br><span class="line"> m_end_lsn = log_reserve_and_write_fast(</span><br><span class="line"> front-&gt;begin(), len, &amp;m_start_lsn);</span><br><span class="line"> <span class="keyword">if</span> (m_end_lsn &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* Open the database log for log_write_low */</span></span><br><span class="line"> m_start_lsn = log_reserve_and_open(len);</span><br><span class="line"> <span class="keyword">mtr_write_log_t</span> write_log;</span><br><span class="line"> m_impl-&gt;m_log.for_each_block(write_log);</span><br><span class="line"> m_end_lsn = log_close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分为两个分支：</p>
<ol>
<li>mtr 中的redo log buffer没有写满一个block(508byte)时；</li>
<li>mtr 中的redo log buffer写入到了多个block时。</li>
</ol>
<p>这里暂时只看了第一部分，当 <code>redo log_sys buffer</code> 只写入了一个 block 时的情况。</p>
<ol>
<li>mtr redo log buffer 中只有第一个block被写入了 redo log record<br>代码：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_impl-&gt;m_log.is_small()) &#123;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">mtr_buf_t</span>::<span class="keyword">block_t</span>* front = m_impl-&gt;m_log.front();</span><br><span class="line"> ut_ad(len &lt;= front-&gt;used());</span><br><span class="line"> m_end_lsn = log_reserve_and_write_fast(</span><br><span class="line"> front-&gt;begin(), len, &amp;m_start_lsn);</span><br><span class="line"> <span class="keyword">if</span> (m_impl-&gt;m_log.is_small()) &#123;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">mtr_buf_t</span>::<span class="keyword">block_t</span>* front = m_impl-&gt;m_log.front();</span><br><span class="line"> ut_ad(len &lt;= front-&gt;used());</span><br><span class="line"> m_end_lsn = log_reserve_and_write_fast(</span><br><span class="line"> front-&gt;begin(), len, &amp;m_start_lsn);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>log_reserve_and_write_fast</code> 是将mtr redo log buffer中存储的redo log record写入redo logsys buffer。下面我们来分析这个函数。这里提取该函数的关键代码 段，这里去掉了 <code>#ifdef UNIV_LOG_LSN_DEBUG /*code*/ #endif /* UNIV_LOG_LSN_DEBUG*/</code> 的代码段，由此可见一个mtr的redo log 并不会写LSN到redo logsysbuffer 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNIV_HOTBACKUP</span></span><br><span class="line"><span class="comment">/** Append a string to the log.*/</span></span><br><span class="line"><span class="comment">// @param[in] str string</span></span><br><span class="line"> <span class="comment">//@param[in] len string length</span></span><br><span class="line"><span class="comment">// @param[out] start_lsn start LSN of the log record</span></span><br><span class="line"><span class="comment">// @return end lsn of the log record, zero if did not succeed</span></span><br><span class="line"></span><br><span class="line">UNIV_INLINE</span><br><span class="line"><span class="keyword">lsn_t</span></span><br><span class="line">log_reserve_and_write_fast(</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">void</span>* str,</span><br><span class="line"> ulint len,</span><br><span class="line"> <span class="keyword">lsn_t</span>* start_lsn)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">const</span> ulint data_len = len</span><br><span class="line"> + log_sys-&gt;buf_free % OS_FILE_LOG_BLOCK_SIZE;</span><br><span class="line"> <span class="keyword">if</span> (data_len &gt;= OS_FILE_LOG_BLOCK_SIZE - LOG_BLOCK_TRL_SIZE) &#123;</span><br><span class="line"> <span class="comment">/* The string does not fit within the current log block  or the log block would become full */</span></span><br><span class="line"> <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> *start_lsn = log_sys-&gt;lsn;</span><br><span class="line"> <span class="built_in">memcpy</span>(log_sys-&gt;buf + log_sys-&gt;buf_free, str, len);</span><br><span class="line"> <span class="comment">//更新log_sys buffer block 的 LOG_BLOCK_HDR_DATA_LEN</span></span><br><span class="line"> log_block_set_data_len(</span><br><span class="line"> <span class="keyword">reinterpret_cast</span>&lt;byte*&gt;(ut_align_down(</span><br><span class="line"> log_sys-&gt;buf + log_sys-&gt;buf_free,</span><br><span class="line"> OS_FILE_LOG_BLOCK_SIZE)),</span><br><span class="line"> data_len);</span><br><span class="line"> log_sys-&gt;buf_free += len;</span><br><span class="line"> log_sys-&gt;lsn += len;</span><br><span class="line"> <span class="keyword">return</span>(log_sys-&gt;lsn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************/</span><span class="comment">/**Sets the log block data length. */</span></span><br><span class="line">UNIV_INLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">log_block_set_data_len(</span><br><span class="line"><span class="comment">/*===================*/</span></span><br><span class="line"> byte* log_block, <span class="comment">/*!&lt; in/out: log block */</span></span><br><span class="line"> ulint len) <span class="comment">/*!&lt; in: data length */</span></span><br><span class="line">&#123;</span><br><span class="line"> mach_write_to_2(log_block + LOG_BLOCK_HDR_DATA_LEN, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="此时-redo-log-sys-buffer-中的数据"><a href="#此时-redo-log-sys-buffer-中的数据" class="headerlink" title="此时 redo log_sys buffer 中的数据"></a>此时 redo log_sys buffer 中的数据</h4><p>之后还会做一些释放资源的动作。 由此，我们可以总结下缓冲中的数据：</p>
<ol>
<li><code>redo record of update in place</code> ;</li>
<li><code>first modify the tablespace</code>;</li>
<li><code>mtr multi redo rec end</code>.<h3 id="redo-log-写盘"><a href="#redo-log-写盘" class="headerlink" title="redo log 写盘"></a>redo log 写盘</h3>首先我们应该确认的是：所有触发redo logsysbuffer 刷盘的情况。 接下来说下方法通过观察那些函数调用了 redo log 写盘的核心函数，这里我选择了：</li>
<li><code>log_checkpoint</code></li>
<li><code>log_write_up_to</code><br>以下是我在代码中看到的各种情况：<h4 id="情形1：当redo-日志数量在短期增多超过-log-group-的大小"><a href="#情形1：当redo-日志数量在短期增多超过-log-group-的大小" class="headerlink" title="情形1：当redo 日志数量在短期增多超过 log group 的大小"></a>情形1：当redo 日志数量在短期增多超过 log group 的大小</h4>如下面的代码所述，这种情况只存在于在短期内redo log井喷式增加。 先看代码(<code>func: log_margin_checkpoint_age</code> )</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func: log_margin_checkpoint_age</span></span><br><span class="line"><span class="comment">/* Our margin check should ensure that we never reach this condition.Try to do checkpoint once. We cannot keep waiting here as it might result in hang in case the current mtr has latch on oldest lsn */</span></span><br><span class="line"><span class="keyword">if</span> (log_sys-&gt;lsn - log_sys-&gt;last_checkpoint_lsn + margin</span><br><span class="line"> &gt; log_sys-&gt;log_group_capacity) &#123;</span><br><span class="line"> <span class="comment">/*code*/</span></span><br><span class="line"> log_sys-&gt;check_flush_or_checkpoint = <span class="literal">true</span>;</span><br><span class="line"> log_checkpoint(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里：</p>
<ol>
<li><code>log_sys-&gt;lsn: logsys</code>当前buffer更新的最新的lsn。</li>
<li><code>log_sys-&gt;last_checkpoint_lsn: latest checkpoint lsn</code>，是指 ~buffer pool~里面的 数据刷新到的最新的lsn。</li>
<li>margin: 当前要插入的redo log record的长度。</li>
<li><code>log_sys-&gt;log_group_capacity</code>: 当前redo log group的容量，这里是指iblogfile0和 iblogfile1的总容量，我的机子上是48M+48M=96M。<br><strong>这里的 <code>log_sys-&gt;check_flush_or_checkpoint = true</code> 会激发主线程来执行 <code>log_free_check(void)</code> 来执行脏页的刷新和日志的刷新等相关的检查</strong><br>因此的代码说明了redo checkpoint 的一种情况：</li>
</ol>
<p><strong>结论1：如果当前的drity page所产生的redo log大于整个 redo log group 的容量则会将 redolog_sys buffer 里面的日志刷盘checkpoint</strong></p>
<h4 id="情形2：当事务提交时，会将-redo-logsysbuffer-刷盘"><a href="#情形2：当事务提交时，会将-redo-logsysbuffer-刷盘" class="headerlink" title="情形2：当事务提交时，会将 redo logsysbuffer 刷盘"></a>情形2：当事务提交时，会将 redo logsysbuffer 刷盘</h4><p>代码<code>(func: trx_flush_log_if_needed_low)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">switch (srv_flush_log_at_trx_commit) &#123;</span><br><span class="line">case 2:</span><br><span class="line"> /* Write the log but do not flush it to disk */</span><br><span class="line"> flush = false;</span><br><span class="line"> /* fall through */</span><br><span class="line">case 1:</span><br><span class="line"> /* Write the log and optionally flush it to disk */</span><br><span class="line"> log_write_up_to(lsn, flush);</span><br><span class="line"> return;</span><br><span class="line">case 0: //每隔1s将redo写盘</span><br><span class="line"> /* Do nothing */</span><br><span class="line"> return;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>说明当 <code>srv_flush_log_at_trx_commit</code> 值不同刷新方式也会有所不同：</p>
<ul>
<li>0:表示Master Thread 每隔1s将redo log sys buffer刷盘</li>
<li>1:写入日志文件并刷新，在每次事务提交时</li>
<li>2:写入日志文件但不刷新，在每次事务提交时<br>而这个在提交过程中的的堆栈流程则为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_write_up_to(lsn_t lsn, bool flush_to_disk)</span><br><span class="line">trx_flush_log_if_needed_low(lsn_t lsn)</span><br><span class="line">trx_flush_log_if_needed(lsn_t lsn, trx_t * trx)</span><br><span class="line">trx_commit_complete_for_mysql(trx_t * trx)</span><br><span class="line">innobase_commit(handlerton * hton, THD * thd, bool commit_trx)</span><br></pre></td></tr></table></figure>
<p>这个事务提交包含了</p>
<ol>
<li>普通事务提交： <code>trx_commit_complete_for_mysql</code></li>
<li>临时表事务的提交 <code>trx_commit_in_memory</code></li>
<li><p>与group commit 相关: <code>trx_prepare</code><br>其中 <code>srv_flush_log_at_trx_commit==0</code> 时的刷盘会在下面说到，而另外两种刷盘的实现则是在 <code>log_write_up_to</code> 中进行。<br>由此我们可以确定的是:<br><strong>结论2： 当事务提交时，会将redo logsysbuffer 里面的日志刷盘</strong></p>
<ol>
<li><code>srv_flush_log_at_trx_commit==0</code> 时的实现<br>该参数为0，说明每隔1s提交一次redo日志。 (func: <code>srv_master_do_active_tasks</code>, <code>srv_master_do_idle_tasks</code>,<br><code>srv_master_do_shutdown_tasks</code>)</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************/</span><span class="comment">/**The master thread is tasked to ensure that flush of log file happens once every second in the background. This is to ensure that not more than one second of trxs are lost in case of crash when innodb_flush_logs_at_trx_commit != 1 */</span></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">srv_sync_log_buffer_in_background(<span class="keyword">void</span>)</span><br><span class="line"><span class="comment">/*===================================*/</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">time_t</span> current_time = time(<span class="literal">NULL</span>);</span><br><span class="line"> srv_main_thread_op_info = <span class="string">"flushing log"</span>;</span><br><span class="line"> <span class="comment">//这里srv_flush_log_at_timeout</span></span><br><span class="line"> <span class="keyword">if</span> (difftime(current_time, srv_last_log_flush_time)</span><br><span class="line"> &gt;= srv_flush_log_at_timeout) &#123;</span><br><span class="line"> log_buffer_sync_in_background(<span class="literal">true</span>);</span><br><span class="line"> srv_last_log_flush_time = current_time;</span><br><span class="line"> srv_log_writes_and_flush++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要两次刷新的时间差超过1s则立即做刷新动作。</p>
<h4 id="3-情形3：主线程写盘"><a href="#3-情形3：主线程写盘" class="headerlink" title="3 情形3：主线程写盘"></a>3 情形3：主线程写盘</h4><p>代码-1<code>(func: os_thread_ret_t DECLARE_THREAD(srv_master_thread))：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (srv_check_activity(old_activity_count)) &#123;</span><br><span class="line"> old_activity_count = srv_get_activity_count();</span><br><span class="line"> srv_master_do_active_tasks();</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> srv_master_do_idle_tasks();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>主线程在 activity 和 idle 均会将redo logsysbuffer 刷盘</p>
<ol>
<li><code>srv_master_do_active_tasks</code> 中的代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* Make a new checkpoint */</span><br><span class="line">//</span><br><span class="line">if (cur_time % SRV_MASTER_CHECKPOINT_INTERVAL == 0) &#123;</span><br><span class="line"> srv_main_thread_op_info = &quot;making checkpoint&quot;;</span><br><span class="line"> log_checkpoint(TRUE, FALSE);</span><br><span class="line"> MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line"> MONITOR_SRV_CHECKPOINT_MICROSECOND, counter_time);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其频率是7s刷一次盘。</p>
<ol start="2">
<li><code>srv_master_do_idle_tasks</code> 中的代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Make a new checkpoint */</span><br><span class="line">srv_main_thread_op_info = &quot;making checkpoint&quot;;</span><br><span class="line">log_checkpoint(TRUE, FALSE);</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(MONITOR_SRV_CHECKPOINT_MICROSECOND,</span><br><span class="line"> counter_time);</span><br></pre></td></tr></table></figure>
<p>则是每时每刻都在做提交动作。<br>另外，还需提到的是由于在事务提交采用不同的参数提交时，会导致redo logsys buffer的 增长，master线程还采用了其他的方式，来实现redo logsys buffer的刷盘。</p>
<p> <strong>结论3： 主线程会间隔一段时间将日志刷盘并checkpoint</strong></p>
<h4 id="情形4：由-log-sys-的标记刷盘-log-sys-gt-check-flush-or-checkpoint"><a href="#情形4：由-log-sys-的标记刷盘-log-sys-gt-check-flush-or-checkpoint" class="headerlink" title="情形4：由 log_sys 的标记刷盘 - log_sys-&gt;check_flush_or_checkpoint"></a>情形4：由 log_sys 的标记刷盘 - log_sys-&gt;check_flush_or_checkpoint</h4><p>当这个标记会引起主线程执行 <code>log_free_check</code> 函数的里面的检查，从而引起日志刷盘， 这时可能触发日志和脏页的刷新。</p>
<h2 id="redo-日志模型的说明"><a href="#redo-日志模型的说明" class="headerlink" title="redo 日志模型的说明"></a>redo 日志模型的说明</h2><p>这一节主要集中来讲redo日志的模型相关</p>
<h3 id="redo-日志类型及其作用"><a href="#redo-日志类型及其作用" class="headerlink" title="redo 日志类型及其作用"></a>redo 日志类型及其作用</h3><p>这一节主要集中来讲redo日志的模型相关（目前只统计我们用到的日志类型）： ,#+NAME: redo log record type<br><img src="/2019/03/01/redo log探究/1531301531444.png" alt="Alt text"><br><img src="/2019/03/01/redo log探究/1531301538672.png" alt="Alt text"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p> <a href="http://mysql.taobao.org/monthly/2015/05/01/" target="_blank" rel="noopener">数据库内核月报 － 2015 / 05-MySQL · 引擎特性 · InnoDB redo log漫游</a></p>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/03/01/存储/存储/" class="pre">存储</a><a href="/2019/03/01/研究消除随机写的手段/" class="next">研究消除随机写的手段</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log探究"><span class="toc-text">redo log探究</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log-整体流程"><span class="toc-text">redo log 整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实验准备"><span class="toc-text">实验准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update-写入到mtr的redo-log"><span class="toc-text">update 写入到mtr的redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实验"><span class="toc-text">实验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-in-place-修改了哪些页面，并且修改了这些页面的哪些位置的记录？"><span class="toc-text">update in place 修改了哪些页面，并且修改了这些页面的哪些位置的记录？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-in-place-中redo形成过程"><span class="toc-text">update in place 中redo形成过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mtr的提交-mtr-rede-log-buffer-写入redo-log-sys-buffer"><span class="toc-text">mtr的提交 - mtr rede log buffer 写入redo log_sys buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mtr的提交过程"><span class="toc-text">mtr的提交过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提交准备：-mtr-t-Command-prepare-write"><span class="toc-text">提交准备： mtr_t::Command::prepare_write()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检查-redo-log-sys-buffer-的空间是否足够-void-log-margin-checkpoint-age"><span class="toc-text">检查 redo log_sys buffer 的空间是否足够 - void log_margin_checkpoint_age</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#至此-prepare-write-完毕，接下来看-mtr-t-Command-finish-write"><span class="toc-text">至此 prepare_write 完毕，接下来看 mtr_t::Command::finish_write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#此时-redo-log-sys-buffer-中的数据"><span class="toc-text">此时 redo log_sys buffer 中的数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-写盘"><span class="toc-text">redo log 写盘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#情形1：当redo-日志数量在短期增多超过-log-group-的大小"><span class="toc-text">情形1：当redo 日志数量在短期增多超过 log group 的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情形2：当事务提交时，会将-redo-logsysbuffer-刷盘"><span class="toc-text">情形2：当事务提交时，会将 redo logsysbuffer 刷盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-情形3：主线程写盘"><span class="toc-text">3 情形3：主线程写盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#情形4：由-log-sys-的标记刷盘-log-sys-gt-check-flush-or-checkpoint"><span class="toc-text">情形4：由 log_sys 的标记刷盘 - log_sys-&gt;check_flush_or_checkpoint</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-日志模型的说明"><span class="toc-text">redo 日志模型的说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-日志类型及其作用"><span class="toc-text">redo 日志类型及其作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ref"><span class="toc-text">Ref</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/剑指offer刷题笔记（一）/">剑指offer刷题笔记（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Socket编程/">Socket编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Effective C++ Note/">Effective C++ Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Aurora Multi-Master 解读/">Aurora Multi-Master 解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Make学习/">Make学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Shell编程/">Shell编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/CMAKE 学习/">CMAKE 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（三）——valgrind/">性能分析工具（三）——valgrind</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（二）——perf/">性能分析工具（二）——perf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/MysqlTuner使用/MysqlTuner使用/">MysqlTuner使用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">CPP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">Database</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/oj/">OJ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能分析/">性能分析</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Stockdean Mu.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>