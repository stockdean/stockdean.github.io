<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>InnoDB索引部分代码阅读 | MyBlog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">InnoDB索引部分代码阅读</h1><a id="logo" href="/.">MyBlog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">InnoDB索引部分代码阅读</h1><div class="post-meta"><a href="/2019/03/01/InnoDB索引部分代码阅读/#comments" class="comment-count"></a><p><span class="date">Mar 01, 2019</span><span><a href="/categories/database/" class="category">Database</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><hr>
<h2 id="InnoDB索引部分代码阅读"><a href="#InnoDB索引部分代码阅读" class="headerlink" title="InnoDB索引部分代码阅读"></a>InnoDB索引部分代码阅读</h2><p>​    本次阅读的目的是要看下索引分裂的过程和MTR的关系。入口是innodb创建系统表空间的代码，位于innobase_start_or_create_for_mysql()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (create_new_db) &#123;</span><br><span class="line">	mtr_start(&amp;mtr);</span><br><span class="line">	<span class="keyword">bool</span> ret = fsp_header_init(<span class="number">0</span>, sum_of_new_sizes, &amp;mtr);	<span class="comment">//创建系统表空间！</span></span><br><span class="line">	mtr_commit(&amp;mtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    由上面的代码可以看到，整个系统表空间的header初始化过程都使用的一个MTR来贯穿，以保证原子性。</p>
<h3 id="InnoDB中的行数据类型"><a href="#InnoDB中的行数据类型" class="headerlink" title="InnoDB中的行数据类型"></a>InnoDB中的行数据类型</h3><h5 id="数据类型描述：dtype-t"><a href="#数据类型描述：dtype-t" class="headerlink" title="数据类型描述：dtype_t"></a>数据类型描述：dtype_t</h5><p>InnoDB中的数据类型是指InnoDB所支持的SQL数据类型在内部代码的实现。这部分的内容主要在<code>data0type.*</code>文件中。在InnoDB中所有的数据类型都以<code>dtype_t</code>表示，该结构体的声明如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtype_t</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span>	prtype:<span class="number">32</span>;	<span class="comment">/*!&lt; precise type; MySQL data</span></span><br><span class="line"><span class="comment">					type, charset code, flags to</span></span><br><span class="line"><span class="comment">					indicate nullability,</span></span><br><span class="line"><span class="comment">					signedness, whether this is a</span></span><br><span class="line"><span class="comment">					binary string, whether this is</span></span><br><span class="line"><span class="comment">					a true VARCHAR where MySQL</span></span><br><span class="line"><span class="comment">					uses 2 bytes to store the length */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	mtype:<span class="number">8</span>;	<span class="comment">/*!&lt; main data type */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the remaining fields do not affect alphabetical ordering: */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span>	len:<span class="number">16</span>;		<span class="comment">/*!&lt; length; for MySQL data this</span></span><br><span class="line"><span class="comment">					is field-&gt;pack_length(),</span></span><br><span class="line"><span class="comment">					except that for a &gt;= 5.0.3</span></span><br><span class="line"><span class="comment">					type true VARCHAR this is the</span></span><br><span class="line"><span class="comment">					maximum byte length of the</span></span><br><span class="line"><span class="comment">					string data (in addition to</span></span><br><span class="line"><span class="comment">					the string, MySQL uses 1 or 2</span></span><br><span class="line"><span class="comment">					bytes to store the string length) */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	mbminmaxlen:<span class="number">5</span>;	<span class="comment">/*!&lt; minimum and maximum length of a</span></span><br><span class="line"><span class="comment">					character, in bytes;</span></span><br><span class="line"><span class="comment">					DATA_MBMINMAXLEN(mbminlen,mbmaxlen);</span></span><br><span class="line"><span class="comment">					mbminlen=DATA_MBMINLEN(mbminmaxlen);</span></span><br><span class="line"><span class="comment">					mbmaxlen=DATA_MBMINLEN(mbminmaxlen) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由上面的定义可以看到，在InnoDB的内部实现中，数据类型分为主类型（mtype）和精确类型（prtype）。主类型说明了一个数据类型的大类，例如该类型是数据类型还是字符串类型等，而精确类型则说明了例如是否为空，字符串的字符集等信息。在<code>data0type.h</code>中有对<code>prtype</code>各个字节含义的说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MySQL用户创建的表具有以下约定：</span><br><span class="line"></span><br><span class="line">- 在精确类型的最低有效字节中，我们存储MySQL的数据类型码（不适用于系统列）。</span><br><span class="line"></span><br><span class="line">- 在第二个最低有效字节中，我们标记DATA_NOT_NULL，DATA_UNSIGNED，DATA_BINARY_TYPE。</span><br><span class="line"></span><br><span class="line">- 在精确类型的字符串类型的第三个最低有效字节中，我们存储MySQL‘charset-collation（字符集排序）’代码。在使用&lt;<span class="number">4.0</span><span class="number">.14</span>创建的DATA_BLOB列中，我们实际上并不知道它是BLOB还是TEXT列。由于&lt;<span class="number">4.0</span><span class="number">.14</span>中的BLOB或TEXT列的前缀没有索引，因此这没有问题。</span><br><span class="line"></span><br><span class="line">请注意，版本&lt;<span class="number">4.1</span><span class="number">.2</span>或&lt;<span class="number">5.0</span><span class="number">.1</span>未将charset代码存储到精确类型，因为charset始终是MySQL安装的默认字符集。如果InnoDB的系统表SYS_COLUMNS中存储的字符集代码为<span class="number">0</span>，则表示应使用此MySQL安装的默认字符集。</span><br><span class="line"></span><br><span class="line">当将表定义从系统表加载到主存储器中的InnoDB数据字典高速缓存时，InnoDB版本&gt; = <span class="number">4.1</span><span class="number">.2</span>和&gt; = <span class="number">5.0</span><span class="number">.1</span>检查存储的字符集整理是否为<span class="number">0</span>，如果是这种情况，则type是非二进制字符串，用此MySQL安装的默认charset-collation代码替换<span class="number">0</span>。简而言之，在旧表中，磁盘上系统表中的charset-collation代码可以为<span class="number">0</span>，但在内存数据结构（<span class="keyword">dtype_t</span>）中，对于非二进制字符串类型，charset-collation代码始终为！= <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">在新表中，在二进制字符串类型中，charset-collation代码是'binary charset'的MySQL代码，即！= 0。</span><br><span class="line"></span><br><span class="line">对于二进制字符串类型和DATA_CHAR，DATA_VARCHAR以及那些二进制或具有charset-collation latin1_swedish_ci的DATA_BLOB，InnoDB在内部执行所有比较，而不依赖于MySQL比较函数。这是为了节省CPU时间。</span><br><span class="line"></span><br><span class="line">InnoDB自己的内部系统表的列有不同的精确类型，对于它们，通常根本不使用精确类型。</span><br></pre></td></tr></table></figure>
<h5 id="列类型描述：dict-col-t"><a href="#列类型描述：dict-col-t" class="headerlink" title="列类型描述：dict_col_t"></a>列类型描述：dict_col_t</h5><p><code>dict_col_t</code>是对表中一列的元数据类型进行描述，包括：列的数据类型（dtype_t来定义），该列在表中的位置（第多少列，index），是否是参与索引排序的列，最大的索引前缀长度。<code>dict_col_t</code>的定义如下，可以清楚的看到每个成员的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Data structure for a column in a table */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict_col_t</span>&#123;</span></span><br><span class="line">	<span class="comment">/*----------------------*/</span></span><br><span class="line">	<span class="comment">/** The following are copied from dtype_t,</span></span><br><span class="line"><span class="comment">	so that all bit-fields can be packed tightly. */</span></span><br><span class="line">	<span class="comment">/* @&#123; */</span></span><br><span class="line">			...该部分和<span class="keyword">dtype_t</span>的内容相同，该列的数据类型信息...</span><br><span class="line">	<span class="comment">/*----------------------*/</span></span><br><span class="line">	<span class="comment">/* End of definitions copied from dtype_t */</span></span><br><span class="line">	<span class="comment">/* @&#125; */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span>	ind:<span class="number">10</span>;		<span class="comment">/*!&lt; table column position</span></span><br><span class="line"><span class="comment">					(starting from 0) */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	ord_part:<span class="number">1</span>;	<span class="comment">/*!&lt; nonzero if this column</span></span><br><span class="line"><span class="comment">					appears in the ordering fields</span></span><br><span class="line"><span class="comment">					of an index */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	max_prefix:<span class="number">12</span>;	<span class="comment">/*!&lt; maximum index prefix length on</span></span><br><span class="line"><span class="comment">					this column. Our current max limit is</span></span><br><span class="line"><span class="comment">					3072 for Barracuda table */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="索引字段类型描述：dict-field-t"><a href="#索引字段类型描述：dict-field-t" class="headerlink" title="索引字段类型描述：dict_field_t"></a>索引字段类型描述：dict_field_t</h5><p><code>dict_field_t</code>用来描述索引的一个字段信息，<strong>这里要说明的是，表的信息是由列(dict_col_t)信息组成的，而索引信息是通过字段(dict_field_t)信息组成的</strong>。<code>dict_field_t</code>的定义如下，可以看到每个字段都关联到一个数据列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Data structure for a field in an index */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict_field_t</span>&#123;</span></span><br><span class="line">	<span class="keyword">dict_col_t</span>*	col;		<span class="comment">/*!&lt; pointer to the table column */</span></span><br><span class="line">	<span class="keyword">id_name_t</span>	name;		<span class="comment">/*!&lt; name of the column */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	prefix_len:<span class="number">12</span>;	<span class="comment">/*!&lt; 参与索引排序的前缀长度</span></span><br><span class="line"><span class="comment">					0 or the length of the column</span></span><br><span class="line"><span class="comment">					prefix in bytes in a MySQL index of</span></span><br><span class="line"><span class="comment">					type, e.g., INDEX (textcol(25));</span></span><br><span class="line"><span class="comment">					must be smaller than</span></span><br><span class="line"><span class="comment">					DICT_MAX_FIELD_LEN_BY_FORMAT;</span></span><br><span class="line"><span class="comment">					NOTE that in the UTF-8 charset, MySQL</span></span><br><span class="line"><span class="comment">					sets this to (mbmaxlen * the prefix len)</span></span><br><span class="line"><span class="comment">					in UTF-8 chars */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	fixed_len:<span class="number">10</span>;	<span class="comment">/*!&lt; 固定字段的长度</span></span><br><span class="line"><span class="comment">					0 or the fixed length of the</span></span><br><span class="line"><span class="comment">					column if smaller than</span></span><br><span class="line"><span class="comment">					DICT_ANTELOPE_MAX_INDEX_COL_LEN */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B+树的查找"></a>B+树的查找</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="page-cur-t"><a href="#page-cur-t" class="headerlink" title="page_cur_t"></a>page_cur_t</h5><p>索引页游标结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Index page cursor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_cur_t</span>&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">dict_index_t</span>*	index;</span><br><span class="line">	<span class="keyword">rec_t</span>*		rec;	<span class="comment">/*!&lt; pointer to a record on page */</span></span><br><span class="line">	ulint*		offsets;</span><br><span class="line">	<span class="keyword">buf_block_t</span>*	block;	<span class="comment">/*!&lt; pointer to the block containing rec */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>####关键函数</p>
<h5 id="row-ins-clust-index-entry"><a href="#row-ins-clust-index-entry" class="headerlink" title="row_ins_clust_index_entry"></a>row_ins_clust_index_entry</h5><p>该函数用于聚簇索引的插入操作，会首先进行乐观插入，接着进行悲观插入。函数在[row 3280 @ row0ins.cc]。</p>
<p>函数的大致流程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">row_ins_clust_index_entry()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步：进行外键约束检查</span></span><br><span class="line">    <span class="keyword">if</span> (!index-&gt;table-&gt;foreign_set.empty()) &#123;</span><br><span class="line">		err = row_ins_check_foreign_constraints(</span><br><span class="line">			index-&gt;table, index, entry, thr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Try first optimistic descent to the B-tree */</span></span><br><span class="line">	<span class="comment">//尝试进行乐观更新，加BTR_MODIFY_LEAF锁</span></span><br><span class="line">	<span class="keyword">if</span> (!dict_table_is_intrinsic(index-&gt;table)) &#123;</span><br><span class="line">		log_free_check();</span><br><span class="line">		flags = dict_table_is_temporary(index-&gt;table)</span><br><span class="line">			? BTR_NO_LOCKING_FLAG</span><br><span class="line">			: <span class="number">0</span>;</span><br><span class="line">		... ...</span><br><span class="line">		err = row_ins_clust_index_entry_low(</span><br><span class="line">			flags, BTR_MODIFY_LEAF, index, n_uniq, entry,</span><br><span class="line">			n_ext, thr, dup_chk_only);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果乐观更新没有成功，则开始进行悲观更新！加BTR_MODIFY_TREE锁*/</span></span><br><span class="line">	<span class="comment">/* Try then pessimistic descent to the B-tree */</span></span><br><span class="line">	<span class="keyword">if</span> (!dict_table_is_intrinsic(index-&gt;table)) &#123;</span><br><span class="line">		log_free_check();</span><br><span class="line">		... ...</span><br><span class="line">		err = row_ins_clust_index_entry_low(</span><br><span class="line">			flags, BTR_MODIFY_TREE, index, n_uniq, entry,</span><br><span class="line">			n_ext, thr, dup_chk_only);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DBUG_RETURN(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="btr-attach-half-pages"><a href="#btr-attach-half-pages" class="headerlink" title="btr_attach_half_pages()"></a>btr_attach_half_pages()</h5><p>该函数是在索引页分裂时，向中间节点页上加一个node ptr记录，用来记录新加入的数据页。该函数导致递归分裂。递归过程如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">row_ins_index_entry_low </span><br><span class="line">	-&gt; btr_cur_pessimistic_insert  &lt;------------------|</span><br><span class="line">		-&gt; btr_page_split_and_insert				|</span><br><span class="line">			-&gt; btr_attach_half_pages				|</span><br><span class="line">				-&gt; btr_insert_on_non_leaf_level ------</span><br></pre></td></tr></table></figure>
<h5 id="btr-page-split-and-insert"><a href="#btr-page-split-and-insert" class="headerlink" title="btr_page_split_and_insert()"></a>btr_page_split_and_insert()</h5><p>该函数是进行B+树分裂的主体函数。</p>
<h5 id="btr-cur-search-to-nth-level"><a href="#btr-cur-search-to-nth-level" class="headerlink" title="btr_cur_search_to_nth_level()"></a>btr_cur_search_to_nth_level()</h5><p>该函数是用来检索B+树，并在指定位置放置一个cursor。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">## 如果是要进行B树结构的调整，则是以下流程</span><br><span class="line"><span class="number">1.</span> 根据请求的latch mode设置branch节点的锁类型：</span><br><span class="line">	如果是BTR_MODIFY_TREE，则对branch页加x-latch；</span><br><span class="line">	如果是BTR_SEARCH_TREE或BTR_MODIFY_LEAF，则对branch页加s-latch；</span><br><span class="line">	如果是只读模式（srv_read_only_mode=<span class="literal">true</span>）,则对branch页不加latch；</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span> 根据请求的latch mode设置对index的加锁类型：</span><br><span class="line">	如果是BTR_MODIFY_TREE，则对index加x-lock；</span><br><span class="line">	如果是BTR_SEARCH_TREE或BTR_MODIFY_LEAF，则对index加s-lock；</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 根据请求的latch mode设置对root页的加锁类型：</span><br><span class="line">	BTR_SEARCH_* =&gt; S-LATCH</span><br><span class="line">	BTR_MODIFY_* =&gt; X-LATCH</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 设置对branch页的检索方式：采用PAGE_CUR_LE匹配方式</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span></span><br></pre></td></tr></table></figure>
<h5 id="MySQL5-0-15中对B-树的检索方式"><a href="#MySQL5-0-15中对B-树的检索方式" class="headerlink" title="MySQL5.0.15中对B+树的检索方式"></a>MySQL5.0.15中对B+树的检索方式</h5><h5 id="WL-6326-InnoDB-fix-index-gt-lock-contention"><a href="#WL-6326-InnoDB-fix-index-gt-lock-contention" class="headerlink" title="WL#6326:InnoDB:fix index-&gt;lock contention"></a>WL#6326:InnoDB:fix index-&gt;lock contention</h5><p>在InnoDB中，对于中间节点页latch的获取是受到index-&gt;lock保护的。</p>
<p>在WL#6326之前，index-&gt;lock以S和X两种模式来保护中间节点的latch，在这种情况下，检索B+树不会获取任何中间节点的lock。</p>
<p>在WL#6326之后，中间节点的受到block-&gt;lock的保护（s-latch或x-latch）。为了防止死锁，在获取中间节点的latch之前要先获得index-&gt;lock的latch。</p>
<p><strong>（0）定义：B树的层数</strong></p>
<p>（0.1）B树的叶子节点处于第0层；</p>
<p>（0.2）第L层节点的父亲节点在L+1层；</p>
<p>（0.3）index-&gt;lock处于（树高+1）层，也就是说，index-&gt;lock是root页的父亲。</p>
<p>在WL#6326中，index-&gt;lock有三种模式：</p>
<p><strong>（1）当持有index-&gt;lock的S-latch的情况：</strong></p>
<p>（1.1）页面latch必须以层数降序的方式来获取；（level n-&gt;level n-1-&gt;level … -&gt;level 1）</p>
<p>（1.2）当要获取给定层上的一个节点页时，必须持有其父亲页的latch；</p>
<p>（1.3）如果已经持有一个中间节点页的latch，那么我们只能获取右兄弟页的latch；（防止死锁）</p>
<p>（1.4）中间节点页的latch释放必须遵循先释放孩子节点再释放父亲节点的顺序（这里主要是防止和index-&gt;lock SX-latch的情况发生死锁）：</p>
<p>（1.4.1）要释放一个L层中间节点页的latch，必须保证所有小于L层的页锁已经释放，或者</p>
<p>（1.4.2）所有中间节点页的latch必须一次释放，释放的期间不能请求获取其他任何latch。</p>
<p>（1.5）从1.1和1.2可以推出，第一个获取latch一定是root页的。</p>
<p><strong>（2）当持有index-&gt;lock的SX-latch的情况：</strong></p>
<p>规则1.2和1.3在此模式下可以放宽，并整合到规则2.2中，规则1.4可以移除。这意味着，我们可以不获取某些层上数据页的latch，可以以一个更为宽松的规则获取latch。</p>
<p>（2.1）[和1.1相同]：页面的latch必须以层数降序的方式来获取；（level n-&gt;level n-1-&gt;level … -&gt;level 1）</p>
<p>（2.2）当要获取L层上中间节点页的latch时，必须先持有其左兄弟节点的latch（L层），或着持有其祖先页的latch（&gt; L层）；</p>
<p>（2.3）[由2.1和2.2] 第一个获取的latch可以是任何中间节点页；</p>
<p><strong>（3）当持有index-&gt;lock的X-latch的情况：</strong></p>
<p>在获取索引的X-latch时，我们可以以任意方式获取中间节点的页的latch；</p>
<p>NOTE：WL#6326不会影响对叶子节点的加锁顺序：</p>
<p>读需要获取index-&gt;lock的S-latch，一旦到达叶子层，我们可以释放index-&gt;lock和中间节点页的latch。一旦到达叶子节点，我们可以放心地获取右兄弟节点的latch，释放老页的latch，进行从左往右的索引扫描。</p>
<p>对叶子节点修改（BTR_MODIFY_LEAF）要获取index-&gt;lock的S-latch；</p>
<p>如果发生页面分裂或合并（BTR_MODIFY_TREE）或进行页面分配，则要获取index-&gt;lock的X-latch。</p>
<p><strong>几个例子</strong></p>
<p>[1]</p>
<h3 id="读写锁（read-write-latch）"><a href="#读写锁（read-write-latch）" class="headerlink" title="读写锁（read-write latch）"></a>读写锁（read-write latch）</h3><p><strong>文档目标：</strong>InnoDB内建rw_lock的实现机制|使用方式。</p>
<p>读写锁是innodb用来保证资源的一致性的机制。看本部分代码的原因是在MA项目中日志应用和数据页临时拷贝都会应用到读写锁机制，在从机应用索引分裂的日志时，也会使用到。所以，搞清楚这部分代码可以在MA中使用innodb内建的读写锁。</p>
<h4 id="读写锁结构：rw-lock-t"><a href="#读写锁结构：rw-lock-t" class="headerlink" title="读写锁结构：rw_lock_t"></a>读写锁结构：rw_lock_t</h4><p>innodb中读写锁的实现是<code>rw_lock_t</code>，该结构体中包含了一个读写锁的状态变量、条件变量等内容，下面看一下这个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_lock_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/** 记录该RW锁状态. */</span></span><br><span class="line">	<span class="keyword">volatile</span> lint	lock_word;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当有等待该锁的线程时置为1 */</span></span><br><span class="line">	<span class="keyword">volatile</span> ulint	waiters;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 是否为递归锁，如果为TRUE，则writer_thread是记录的写线程的id，否则</span></span><br><span class="line"><span class="comment">	writer_thread的值无意义！*/</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">bool</span>	recursive;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 当前SX的锁数量. */</span></span><br><span class="line">	<span class="keyword">volatile</span> ulint	sx_recursive;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** This is TRUE if the writer field is RW_LOCK_X_WAIT; this field</span></span><br><span class="line"><span class="comment">	is located far from the memory update hotspot fields which are at</span></span><br><span class="line"><span class="comment">	the start of this struct, thus we can peek this field without</span></span><br><span class="line"><span class="comment">	causing much memory bus traffic */</span></span><br><span class="line">	<span class="keyword">bool</span>		writer_is_wait_ex;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** recursive = TRUE时，该值为写线程的线程id（可能该线程已经持有该锁</span></span><br><span class="line"><span class="comment">	也可能正在等待） */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">os_thread_id_t</span>	writer_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果是buf block的锁，则此成员值为：1 */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	is_block_lock:<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/** 线程等待队列信号量 */</span></span><br><span class="line">	<span class="keyword">os_event_t</span>	event;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 写请求等待的信号量，一个线程必须先递减lock_word，再等待。*/</span></span><br><span class="line">	<span class="keyword">os_event_t</span>	wait_ex_event;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Count of os_waits. May not be accurate */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	count_os_wait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 系统中所有的RW锁都保存在rw_lock_list全局变量中。用于诊断。 */</span></span><br><span class="line">	UT_LIST_NODE_T(<span class="keyword">rw_lock_t</span>) <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 保护此rw_lock_t的锁 */</span></span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">ib_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，innodb中的RW锁就是基于经典的读写锁实现。在此基础上，innodb的RW锁还加入了等待队列，和可重入特性。</p>
<h5 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h5><p>首先看一下innodb中等待队列的实现介绍，下面摘自其代码注释：</p>
<blockquote>
<p>在innodb中，等待队列是通过wait array数组实现的，其中wait array的每个数组元素都有一个信号量。当一个线程等待一个锁时，可以在wait array中申请一个元素空间（cell），并让自己在该元素上的信号量上等待。</p>
<p>当使用等待队列时，必须要保证持有该锁的线程知道有其他线程在等待这个锁，这样在释放锁时可以通知这些等待的现车结束等待。</p>
<p>为什么要实现一个等待队列？主要是为了使锁效率更高。</p>
<p>在5.0.30版本及以后，由于现代操作系统可以很高效的处理大量的信号量，不再需要在每个等待队列的cell里包含一个信号量。相反，现在在每个锁内部都加入了一个信号量，等待线程可以在此信号量上等待。现在innodb中保留全局等待队列（wait array）的原因是为了诊断和避免无限等待。error_monitor thread 可以通过扫描全局 wait array来避免等待线程错过某些信号量。</p>
</blockquote>
<p>从代码上，看是有两个等待队列：一个是在<code>rw_lock_t-&gt;event</code>上的队列，另一个是在<code>sync_wait_array</code>的等待队列。但是这两个队列是共享一个条件变量的（即系统都是通过<code>rw_lock_t-&gt;event</code>信号量来通知的），具体做法是<code>sync_wait_array</code>中的每个成员会保存一个指向本成员所绑定锁的<code>rw_lock_t-&gt;event</code>的指针。</p>
<p>之所以还保留<code>sync_wait_array</code>的原因是error_monitor线程可以通过扫描全局的等待队列，来判断是否有等待线程错过某些信号量。</p>
<p>####InnoDB内建读写锁的使用</p>
<p>下面的所有代码都已经过测试，可以在MySQL中正确运行。</p>
<h5 id="头文件包含（-include）"><a href="#头文件包含（-include）" class="headerlink" title="头文件包含（#include）"></a>头文件包含（#include）</h5><p>使用InnoDB内建的读写锁时需要包含下列头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sync0sync.h"</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sync0types.h"</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sync0rw.h"</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sync0arr.h"</span>;</span></span><br></pre></td></tr></table></figure>
<h5 id="创建锁"><a href="#创建锁" class="headerlink" title="创建锁"></a>创建锁</h5><p>创建并初始化一个锁可以用innodb中预先定义的宏。用于创建锁的宏有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">说明：</span><br><span class="line">1）K为PSI KEY，可以设置为PSI_NOT_INSTRUMENTED，则该锁不会被performance schema跟踪。</span><br><span class="line">2）L是锁变量的地址，用于创建和初始化rw_lock_t。</span><br><span class="line">3）level是用来Debug的，可以设置为SYNC_NO_ORDER_CHECK，则该锁不会被检查。</span><br><span class="line">*/</span><br><span class="line">#define rw_lock_create(K, L, level);</span><br></pre></td></tr></table></figure>
<p>例：</p>
<p>如何定义并初始化一个读写锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//定义计数器类型 counter</span><br><span class="line">struct counter&#123;</span><br><span class="line">    rw_lock_t lock;</span><br><span class="line">    __int64 count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static counter count;</span><br><span class="line"></span><br><span class="line">//初始化count</span><br><span class="line">void count_init() &#123;</span><br><span class="line">	count-&gt;count = 0;</span><br><span class="line">    //初始化读写锁</span><br><span class="line">	rw_lock_create(PFS_NOT_INSTRUMENTED, &amp;count-&gt;lock, SYNC_NO_ORDER_CHECK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####使用锁</p>
<p>读写锁的加锁和解锁都可以使用innodb定义的宏来实现，这些宏有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** 加锁的操作</span><br><span class="line">1）其中参数L的类型为：rw_lock_t*</span><br><span class="line">*/</span><br><span class="line">#define rw_lock_s_lock(L)</span><br><span class="line">#define rw_lock_sx_lock(L)	</span><br><span class="line">#define rw_lock_x_lock(L)</span><br><span class="line">    </span><br><span class="line">/** 解锁的操作</span><br><span class="line">1）其中参数L的类型为：rw_lock_t*</span><br><span class="line">*/</span><br><span class="line">#define rw_lock_s_unlock(L)</span><br><span class="line">#define rw_lock_x_unlock(L)</span><br><span class="line">#define rw_lock_sx_unlock(L)</span><br></pre></td></tr></table></figure>
<p>例：</p>
<p>使用读写锁控制的方式来读取上面定义count中的值，有两个写（writer）线程，两个读线程（read）。读线程会对count对象加s-lock来读取其中的count成员的值；写线程会相应的加x-lock，并执行count-&gt;count++;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//第一个写线程</span><br><span class="line">/**</span><br><span class="line">WRITE THREAD function</span><br><span class="line">*/</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">os_thread_ret_t</span><br><span class="line">DECLARE_THREAD(write_thread)(</span><br><span class="line">void*	arg MY_ATTRIBUTE((unused))) &#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	while (i &lt; 500000)</span><br><span class="line">	&#123;</span><br><span class="line">		rw_lock_x_lock(&amp;count-&gt;lock);</span><br><span class="line">		count-&gt;count++;</span><br><span class="line">		i++;</span><br><span class="line">		rw_lock_x_unlock(&amp;count-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line">	OS_THREAD_DUMMY_RETURN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二个写线程和第一个线程的代码相同。</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">os_thread_ret_t</span><br><span class="line">DECLARE_THREAD(write_thread_2)(</span><br><span class="line">    void*	arg MY_ATTRIBUTE((unused)))&#123;    </span><br><span class="line">    /*......*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//读线程</span><br><span class="line">/**</span><br><span class="line">READ THREAD function</span><br><span class="line">*/</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">os_thread_ret_t</span><br><span class="line">DECLARE_THREAD(read_thread)(</span><br><span class="line">void*	arg MY_ATTRIBUTE((unused))) &#123;</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		rw_lock_s_lock(&amp;count-&gt;lock);</span><br><span class="line">		std::cout &lt;&lt; count-&gt;count &lt;&lt; std::endl;</span><br><span class="line">		rw_lock_s_unlock(&amp;count-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line">	OS_THREAD_DUMMY_RETURN;</span><br></pre></td></tr></table></figure>
<p>执行这四个线程后，count-&gt;count的值会正确的加到1000000，读写锁可以正常使用。</p>
<h5 id="销毁读写锁"><a href="#销毁读写锁" class="headerlink" title="销毁读写锁"></a>销毁读写锁</h5><p>以上面的count对象为例，不能通过直接delete count来销毁读写锁，需要调用专门的宏函数来实现。因为读写锁中包含的信号量需要单独销毁，且由于所有的读写锁都会加入到全局的<code>rw_lock_list</code>中，销毁时需要把读写锁从这个链表中移除。</p>
<p>用户销毁读写锁的宏函数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*销毁一个读写锁。</span><br><span class="line">1)参数M为rw_lock_t*类型。</span><br><span class="line">*/</span><br><span class="line"># define rw_lock_free(M)</span><br></pre></td></tr></table></figure>
<p>例：</p>
<p>以上面的代码为例，当要销毁count对象时，需要像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** 销毁count对象*/</span><br><span class="line">void count_free()&#123;</span><br><span class="line">    rw_lock_free(&amp;count-&gt;lock);</span><br><span class="line">    delete count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="行锁及表锁部分代码阅读"><a href="#行锁及表锁部分代码阅读" class="headerlink" title="行锁及表锁部分代码阅读"></a>行锁及表锁部分代码阅读</h2><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>行锁就是记录锁，与rw-latch不同，行锁是逻辑层的锁，是InnoDB用来实现2PL协议的组件，下面主要看一下其基本数据结构和维护过程。</p>
<h4 id="行锁结构（lock-rec-t）"><a href="#行锁结构（lock-rec-t）" class="headerlink" title="行锁结构（lock_rec_t）"></a>行锁结构（lock_rec_t）</h4><p>表示行锁结构的类型是<code>lock_rec_t</code>(<a href="mailto:row76@lock0priv.h" target="_blank" rel="noopener">row76@lock0priv.h</a>)，其详细结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Record lock for a page */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_rec_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">ib_uint32_t</span>	space;		<span class="comment">/*!&lt; space id */</span></span><br><span class="line">	<span class="keyword">ib_uint32_t</span>	page_no;	<span class="comment">/*!&lt; page number */</span></span><br><span class="line">	<span class="keyword">ib_uint32_t</span>	n_bits;		<span class="comment">/*!&lt; number of bits in the lock</span></span><br><span class="line"><span class="comment">					bitmap; <span class="doctag">NOTE:</span> the lock bitmap is</span></span><br><span class="line"><span class="comment">					placed immediately after the</span></span><br><span class="line"><span class="comment">					lock struct */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总的来说一个行锁是由表空间号（space_id）、页面号（page_no）和一个位图（bitmap）组成，位图是用来标记该行锁对应页面中的哪个记录（record），是用heap_no表示的，heap_no可以认为是一个记录在页面内的物理偏移。</p>
<h4 id="事务锁（lock-t）"><a href="#事务锁（lock-t）" class="headerlink" title="事务锁（lock_t）"></a>事务锁（lock_t）</h4><p>事务锁是一个事务执行过程中需要管理的锁，有表锁和行锁两种，这两种锁都是保存在一个<code>lock_t</code>结构中。一个事务所有的lock_t对象都保存在了<code>trx-&gt;lock</code>中。<code>lock_t</code>结构如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lock struct; protected by lock_sys-&gt;mutex */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">trx_t</span>*		trx;		<span class="comment">/*!&lt; transaction owning the</span></span><br><span class="line"><span class="comment">					lock */</span></span><br><span class="line">	UT_LIST_NODE_T(<span class="keyword">lock_t</span>)</span><br><span class="line">			trx_locks;	<span class="comment">/*!&lt; list of the locks of the</span></span><br><span class="line"><span class="comment">					transaction */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">dict_index_t</span>*	index;		<span class="comment">/*!&lt; index for a record lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">lock_t</span>*		hash;		<span class="comment">/*!&lt; hash chain node for a record</span></span><br><span class="line"><span class="comment">					lock. The link node in a singly linked</span></span><br><span class="line"><span class="comment">					list, used during hashing. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">lock_table_t</span>	tab_lock;<span class="comment">/*!&lt; table lock */</span></span><br><span class="line">		<span class="keyword">lock_rec_t</span>	rec_lock;<span class="comment">/*!&lt; record lock */</span></span><br><span class="line">	&#125; un_member;			<span class="comment">/*!&lt; lock details */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">ib_uint32_t</span>	type_mode;	<span class="comment">/*!&lt; lock type, mode, LOCK_GAP or</span></span><br><span class="line"><span class="comment">					LOCK_REC_NOT_GAP,</span></span><br><span class="line"><span class="comment">					LOCK_INSERT_INTENTION,</span></span><br><span class="line"><span class="comment">					wait flag, ORed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="用于创建记录锁的RecLock类"><a href="#用于创建记录锁的RecLock类" class="headerlink" title="用于创建记录锁的RecLock类"></a>用于创建记录锁的RecLock类</h4><p><code>RecLock</code>[row <a href="mailto:607@lock0priv.h" target="_blank" rel="noopener">607@lock0priv.h</a>]类是用来创建记录锁的工具类。同时该类还有死锁检测和锁优先级的功能。下面主要看下它创建记录锁的逻辑。</p>
<h3 id="InnoDB锁实现概述"><a href="#InnoDB锁实现概述" class="headerlink" title="InnoDB锁实现概述"></a>InnoDB锁实现概述</h3><p>下面的文字翻译自<a href="mailto:`row265@lock0priv.h" target="_blank" rel="noopener">`row265@lock0priv.h</a>`:</p>
<p>[1] 一个显式的（explicit）记录锁会锁定一个记录和该记录之前的gap。一个隐式的（implicit）记录锁（x-lock）不会影响gap，而只会锁定该记录。</p>
<p>[2] 如果一个事务更新或插入了一个条索引记录，则它拥有一个隐式的x-lock在所修改的记录上。对于二级索引来说，如果一个事务修改了聚簇索引的记录，并且对应二级索引所在数据页的PAGE_MAX_TRX_ID大于当前事务的ID（或者正在进行崩溃恢复），并且没有显式的non-gap锁请求在该二级索引上，那么该事务拥有该二级索引的隐式x-lock。</p>
<p>[3] 二级索引上锁定义的复杂性主要是因为它的实现方式：我们想通过查看一个聚簇索引记录的最新值（而不是历史版本）来判断在一个二级索引上是否有隐式的x-lock。可以向用户解释复杂的定义，以便在回答查询时访问路径中存在不确定性：我们可能会或可能不会访问聚簇索引记录，因此可能会或可能不会碰到x锁在那里。</p>
<p>[3] 值得一提的是，不同的事务可以同时对于某个gap拥有冲突的锁。这时因为GAP锁的语义仅仅是<strong>“禁止”</strong>：如果事务T1拥有某个gap的x-lock，那么另外的事务则不能在gap内插入或进行查询。但是T1拥有的gap-lock并不能让T1直接在gap内插入记录（意思是即使T1拥有该gap的锁，但是如果要在该gap内插入记录还是需要申请记录锁）。</p>
<p>[4] 一个显式的（explicit）锁可以加在一条用户记录或supremum记录上。加在supremum记录上的锁总被认为是gap锁，虽然锁上的gap位没有set。当我们要更新一条记录，并且记录的空间大小发生变化时，我们会将该记录锁临时地保存在该页上的infimum记录，infimum记录只有在这种情况下会被加锁。</p>
<p>[5] 另外，一个waiting record lock可以也是gap锁。一个waiting record lock请求只有在该lock队列中的其他冲突请求被满足后才能得到满足。</p>
<p>[6] 在4.0.5版本中，我们还加入了另一个显式锁类型：LOCK_REC_NOT_GAP，它只锁定单条记录，不包括记录之前的记录。加入该中锁类型的原因是要模拟Oracle-like的读提交（RC）隔离级别。</p>
<p>[7] RULE 1：如果有一个隐式的x-lock在一个记录上，并且在该记录锁的等待队列中有non-gap锁请求，那么持有该隐式x-lock的事务也相当于持有一个显式的non-gap x-lock。因此，只要锁被释放了，我们可以仅仅根据请求队列中的显式锁请求来授予锁。</p>
<p>[8] RULE 3：不同的事务不能同时对同一条记录加冲突的non-gap锁，但是他们可以拥有冲突的gap-lock。</p>
<p>[9] RULE 4：如果有一个waiting lock request在一个队列中，没有其他锁请求可以被插入到等待队列头部。在记录删除或页面分裂时，数据库本身可以为一个事务创建一个新的gap类型的锁，如果没有RULE4，那么waits-for graph可能会出现环，而数据库本身不会处理这种死锁，因为死锁检测仅在一个事务请求一个锁时才进行（而不是数据库本身为事务创建一个锁对象时）。</p>
<p>[10] 如果下一条记录（next record）上的其他事务没有明确的锁定请求，则允许插入该gap。 无论这些锁定请求是被授予还是等待，是否设置了gap bit都没有关系，除非是由另一个事务设置的等待进行插入的gap类型请求被忽略。 另一方面，另一个事务的隐式x锁定不会阻止插入，当使用Oracle样式的序列号生成器作为主键并且许多事务同时执行插入时，这允许更多的并发性。</p>
<p>[11] 一个事务只有在获得记录的x-lock或者没有其他事务请求该记录的non-gap锁的情况下才能对一个记录进行修改。</p>
<p>[12] 如果一个事务拥有一个记录的non-gap explicit锁或是隐式锁，亦或是其他事务没有对该记录加锁，这时该事务才能通过cursor读取该记录。</p>
<p>[13] 总的来说，一个隐式锁（implicit lock）可以被看做授予在某条记录上的x-lock；一个显式的锁（explicit lock）但是没有设置gap bit则可以被看做对记录和gap共同上锁；而设置gap bit的锁则只能用来对gap 加锁。不同的事务不能同时拥有某条记录上相冲突的锁，但可以同时拥有某个gap上相冲突的锁。授予关于某个记录的锁表明可以修改该记录，而gap类型的锁则表示禁止操作。</p>
<p>[14] NOTE：找出某个事务是否在辅助索引记录上具有隐式x锁定可能很麻烦。 我们可能必须查看相应聚簇索引记录的先前版本，以查明删除标记的辅助索引记录是否被活动事务标记为删除，而不是由已提交的事务标记。</p>
<p>[15] FACT A：如果一个事务插入了一行，则可以在任何时候删除该记录，并且一定不会发生锁等待。</p>
<p>[16] FACT B：如果一个事务用cursor读了一些记录（结果集），则他可以再次读这些记录，并且读的结果集和原来的相同如果该事务没有修改其中的记录。所以，不会发生幻读。如果结果集中，字母序最大的记录被移除了，则会发送锁等待，否则的话则不会。</p>
<p>[17] PROOF：当一个read cursor前进时，它会对每条读到的用户记录加s-lock，并对每个supremum加gap类型的s-lock。该cursor必须等待直到获取了上面的锁。所以，其他事务没办法获取该结果集中任何一条记录的x-lock，更无法修改记录。因为cursor推进时还会对每条记录上gap锁，所以其他事务也无法插入该cursor扫描过的记录。页面的分裂或合并，或者老版本的记录被purge，并不会影响此结果。因为当一条用户记录或supremum记录被移除时，下个记录会继承该记录的锁，并设置为gap类型。另外，如果一个supremum记录被插入，则它会继承它的后继记录（successor）的锁。当cursor再次被定位到结果集的头部时，cursor所能访问的记录要么是上次记录访问的，要么是新插入的supremum记录。cursor可以不用等待访问所有的记录，当cursor到达最大的记录时，他会通知结果集已经遍历完成。如果最大的记录已经被移除，则会发生等待，因为next record仅继承了gap类型的锁。</p>
<p>[18] 如果一个索引记录要被修改或新插入，则我们必须检查在该条记录上是否有锁在该条记录上，和下一条记录上是否有（gap lock）。当一个cursor开始读取记录时，我们会为每个读取的记录加一个s-lock，除了cursor在的初始记录。这是因为根据我们index tree索引传统，cursor会被放置在第一个可能匹配的记录之前的位置。这里有可优化的地方：如果一个记录是由在唯一键上的等值条件索引得到的，那么我们没必要对该记录加gap lock锁，而仅仅加记录锁就可以了。在当前版本下，next-key锁会对记录加x-lock锁，并同时阻止在该记录之前的插入操作。</p>
<p>[19] 每个页面上有两条特殊的记录：infimum和supremum记录。一个read cursor可以对supremum记录加锁，supremum记录不能被修改，但是对supremum加锁可以防止在页尾插入记录。</p>
<p>[20] next-key lock可以阻止幻读的产生，防止幻读可以实现可串行化。</p>
<p>[21] 如果我们想插入一条新的记录，那么需要检查什么？只需要检查同一个页面上的next record即可，因为supremum记录也是可以带有锁信息的。s-lock可以阻止插入，那么如果是一个x-lock呢？比如说一个insert…select语句会对选择的记录加s-lock，这时插入会被阻止。如果我们的事务拥有next record的x-lock但是有一个waiting s-lock请求在next record会发生什么？如果该s-lock是由一个read cursor请求的，且该read cursor是按照递增的方向访问索引的，那么我们不能立即插入。因为如果我们提交了更改，则read cursor可以看到新插入的记录。我们应当移动read cursor到next record之前的位置，这样它可以读取到新插入的记录。当然，这种方式实现起来很麻烦。当我们处于上述情况时，我们仅仅在next record上为我们的事务申请第二个x-lock，这时死锁检测机制会注意到我们的事务和read cursor的事务已经发生死锁。这似乎是一个OK的解决方案。</p>
<p>[22] 我们可以设一个约定：被授予的显式记录锁（explicit lock）阻止记录修改的同时会锁记录前面的gap。一个waiting explicit lock请求会锁定gap。隐式的记录x锁（implicit x-lock）派生于聚簇索引中的事务id，它只锁记录不锁gap。</p>
<p>[23] 我们应该如何存储update locks？如果一个search查询是通过unique key进行的，则我们可以仅仅修改记录的trx id。不然的话，我们要在记录上加一个x-lock。如果更新更改了聚簇索引记录的排序字段，则插入的新记录在锁定表中不需要记录锁定，则trx id就足够了。 二级索引记录也是如此。 搜索删除类似于更新。</p>
<p>[24] PROBLEM：如果有waiting lock request怎么办？如果一个事务正在等待更新一条记录，而这条记录被另外一个未提交的事务修改，那么正在修改这条记录的事务如何发送“结束等待”信号给等待的事务？如果我们约定一个事务在某一时刻只能等待一个锁，那我们如何保护这个锁如果lock wait ends？</p>
<p>[25] PROBLEM：对一个二级索引来说，如果仅仅是修改，而不是做插入，那么还有必要检查二级索引记录的trx id字段吗？一个二级索引被修改其实只是指set和reset该二级索引记录的delete flag。一个二级索引记录包含了能唯一确定聚簇索引的字段（用来做“回表”）。一个二级索引只有在其聚簇索引发生被修改时才能被修改。在我们要修改二级索引之前，需要检查对应聚簇索引上的trx id字段。所以，当要delete mark或unmark一个二级索引时，我们不关心该二级索引的trx id字段，只需要看锁表中是否有对应的（聚簇索引记录）锁即可。在对一个二级索引做SELECT时，trx id至关重要，我们必须要检查对应的聚簇索引。</p>
<p>[26]PROBLEM：当页面发生分裂或合并、亦或是一个记录被删除或被更新时如何更新记录的锁信息？如果记录的长度发生变化，我们会用delete and insert的方式进行更新操作。在这种情况下，我们如何重新获得记录的锁，或在这条记录上等待锁？一个记录锁是使用bitmap来记录对应的记录在页面内的heap no，当我们要移除一条记录时，可能仍会保留lock bits。如果页面重新组织了，我们可以新建一张表，用来记录记录新、老heap no的对应关系，并相应地变换锁中bitmap的信息。接着，我们把更新的记录的结束为止加入到表中。如果更新不需要重组页面，我们可以简单的移除lock的bits，并更新为记录当前的heap no。（如果我们用完了当前lock的bitmap位，我们可能需要重新分配一个lock。）</p>
<p>[27] 一个更为复杂的情况时当要重新插入更新的记录时，需要分裂数据页（而不是页面重组），这时索引树的结构会发生变换。这就引出了下面的问题。</p>
<p>[28] PROBLEM：如果一个supremum记录在页面合并的时候被移除，或者一个记录被purge掉了，那么waiting lock requests如何处理？如果页面向右分裂，我们可以简单的将lock request加到新的supremum记录上。如果一个记录被移除，我们可以将waiting lock request放置到该记录的下一条记录上。在这种情况下，下一条记录上可能已有其他锁请求存在，所以新的死锁检测必须判断是否可以进行加锁。</p>
<p>[29] PROBLEM：如果一个记录被插入了，它应该从它的下一条记录获取什么锁？在页面分裂时，一个supremum总会被插入，而且总可以插入成功，但是插入一条用户记录需要其upper neighbor上没有其他事务持有的任何锁或锁请求。解决方案：我们可以将upper neighbor的锁拷贝过来作为gap类型的锁，这样waiting locks会被转换称为在插入记录上已授予的gap类型。</p>
<p>[30] 对于行来所，InnoDB只会获取S或X类型的锁，对于表来说，InnoDB通常获取IS或IX，只有在需要锁表的情况下才会获取S或X锁。自增锁（AI）在语句级别的binlog中是需要的。</p>
<h3 id="物理的LATCH和逻辑的锁如何配合保证事务的隔离性？"><a href="#物理的LATCH和逻辑的锁如何配合保证事务的隔离性？" class="headerlink" title="物理的LATCH和逻辑的锁如何配合保证事务的隔离性？"></a>物理的LATCH和逻辑的锁如何配合保证事务的隔离性？</h3><p>LATCH，即闩，大部分情况下是用来保证数据页访问的正确性。而锁（行锁、表锁）则是用来保证访问一条记录的正确性，是用来防止幻读等异常现象。这两者配合保证了事务执行的正确性。这里的问题是LATCH和锁如何交互的？首先，LATCH对一个事务（trx）来说应该是透明的，因为LATCH仅是为了保证页面的物理访问的正确性。但是一个事务是能感知到锁的存在的，而锁要依赖于页面中记录的位置信息。下面我们通过跟踪一条记录的插入过程，看下LATCH和记录锁如何交互。</p>
<p>btr_cur_optimistic_insert()函数是将一条记录以乐观方式插入到数据页上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//btr_cur_optimistic_insert的调用逻辑如下：</span></span><br><span class="line">	btr_cur_open() <span class="comment">//打开一个指向“待插入”位置的cursor，对数据页加latch</span></span><br><span class="line">          ↓↓</span><br><span class="line">btr_cur_optimistic_insert() <span class="comment">//执行乐观插入</span></span><br><span class="line">          ↓↓</span><br><span class="line">       释放LATCH</span><br></pre></td></tr></table></figure>
<p>btr_cur_optimistic_insert()函数的代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************/</span><span class="comment">/**</span></span><br><span class="line"><span class="comment">Tries to perform an insert to a page in an index tree, next to cursor.</span></span><br><span class="line"><span class="comment">It is assumed that mtr holds an x-latch on the page. The operation does</span></span><br><span class="line"><span class="comment">not succeed if there is too little space on the page. If there is just</span></span><br><span class="line"><span class="comment">one record on the page, the insert will always succeed; this is to</span></span><br><span class="line"><span class="comment">prevent trying to split a page with just one record.</span></span><br><span class="line"><span class="comment">@(Database)return DB_SUCCESS, DB_WAIT_LOCK, DB_FAIL, or error number */</span></span><br><span class="line"><span class="keyword">dberr_t</span></span><br><span class="line">btr_cur_optimistic_insert(</span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取要进行插入的数据页</span></span><br><span class="line">	block = btr_cur_get_block(cursor);</span><br><span class="line">	page = buf_block_get_frame(block);</span><br><span class="line">	index = cursor-&gt;index;</span><br><span class="line">	<span class="comment">//获取cursor，该cursor已被放置到要插入记录的前一条记录的位置</span></span><br><span class="line">	page_cursor = btr_cur_get_page_cur(cursor);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面开始尝试插入 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">rec_t</span>*	page_cursor_rec = page_cur_get_rec(page_cursor);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dict_table_is_intrinsic(index-&gt;table)) &#123;</span><br><span class="line"></span><br><span class="line">			index-&gt;rec_cache.rec_size = rec_size;</span><br><span class="line">			<span class="comment">//如果是临时表，则直接插入</span></span><br><span class="line">			*rec = page_cur_tuple_direct_insert(</span><br><span class="line">				page_cursor, entry, index, n_ext, mtr);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 如果不是临时表，则要检查锁信息，可能还要写UNDO信息 */</span></span><br><span class="line">			err = btr_cur_ins_lock_and_undo(flags, cursor, entry,</span><br><span class="line">							thr, mtr, &amp;inherit);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (err != DB_SUCCESS) &#123;</span><br><span class="line">				<span class="keyword">goto</span> fail_err;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 在数据页上写入记录 */</span></span><br><span class="line">			*rec = page_cur_tuple_insert(</span><br><span class="line">				page_cursor, entry, index, offsets, heap,</span><br><span class="line">				n_ext, mtr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 根据游标在页面内的位置判断是否发生了页面重组 */</span></span><br><span class="line">		reorg = page_cursor_rec != page_cur_get_rec(page_cursor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*rec) &#123;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (page_size.is_compressed()) &#123;</span><br><span class="line">		<span class="comment">/* Reset the IBUF_BITMAP_FREE bits, because</span></span><br><span class="line"><span class="comment">		page_cur_tuple_insert() will have attempted page</span></span><br><span class="line"><span class="comment">		reorganize before failing. */</span></span><br><span class="line">		<span class="keyword">if</span> (leaf</span><br><span class="line">		    &amp;&amp; !dict_index_is_clust(index)</span><br><span class="line">		    &amp;&amp; !dict_table_is_temporary(index-&gt;table)) &#123;</span><br><span class="line">			ibuf_reset_free_bits(block);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* For intrinsic table we take a consistent path</span></span><br><span class="line"><span class="comment">		to re-organize using pessimistic path. */</span></span><br><span class="line">		<span class="keyword">if</span> (dict_table_is_intrinsic(index-&gt;table)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ut_ad(!reorg);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 如果页面放不下记录，则尝试重组页面 */</span></span><br><span class="line">		<span class="keyword">if</span> (!btr_page_reorganize(page_cursor, index, mtr)) &#123;</span><br><span class="line">			ut_ad(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ut_ad(page_get_max_insert_size(page, <span class="number">1</span>) == max_size);</span><br><span class="line"></span><br><span class="line">		reorg = TRUE;</span><br><span class="line"></span><br><span class="line">		*rec = page_cur_tuple_insert(page_cursor, entry, index,</span><br><span class="line">					     offsets, heap, n_ext, mtr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(DB_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完待续！</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="https://dev.mysql.com/worklog/task/?id=6363WL#6363" target="_blank" rel="noopener">https://dev.mysql.com/worklog/task/?id=6363WL#6363</a> : InnoDB: implement SX-lock for rw_lock</p>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/03/01/Linux环境下源码安装Mysql/" class="pre">Linux环境下源码安装Mysql</a><a href="/2019/03/01/存储/存储/" class="next">存储</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB索引部分代码阅读"><span class="toc-text">InnoDB索引部分代码阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB中的行数据类型"><span class="toc-text">InnoDB中的行数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数据类型描述：dtype-t"><span class="toc-text">数据类型描述：dtype_t</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#列类型描述：dict-col-t"><span class="toc-text">列类型描述：dict_col_t</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#索引字段类型描述：dict-field-t"><span class="toc-text">索引字段类型描述：dict_field_t</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树的查找"><span class="toc-text">B+树的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#page-cur-t"><span class="toc-text">page_cur_t</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#row-ins-clust-index-entry"><span class="toc-text">row_ins_clust_index_entry</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#btr-attach-half-pages"><span class="toc-text">btr_attach_half_pages()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#btr-page-split-and-insert"><span class="toc-text">btr_page_split_and_insert()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#btr-cur-search-to-nth-level"><span class="toc-text">btr_cur_search_to_nth_level()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL5-0-15中对B-树的检索方式"><span class="toc-text">MySQL5.0.15中对B+树的检索方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WL-6326-InnoDB-fix-index-gt-lock-contention"><span class="toc-text">WL#6326:InnoDB:fix index-&gt;lock contention</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁（read-write-latch）"><span class="toc-text">读写锁（read-write latch）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#读写锁结构：rw-lock-t"><span class="toc-text">读写锁结构：rw_lock_t</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#等待队列"><span class="toc-text">等待队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#头文件包含（-include）"><span class="toc-text">头文件包含（#include）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#创建锁"><span class="toc-text">创建锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#销毁读写锁"><span class="toc-text">销毁读写锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行锁及表锁部分代码阅读"><span class="toc-text">行锁及表锁部分代码阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#行锁"><span class="toc-text">行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#行锁结构（lock-rec-t）"><span class="toc-text">行锁结构（lock_rec_t）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务锁（lock-t）"><span class="toc-text">事务锁（lock_t）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用于创建记录锁的RecLock类"><span class="toc-text">用于创建记录锁的RecLock类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB锁实现概述"><span class="toc-text">InnoDB锁实现概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#物理的LATCH和逻辑的锁如何配合保证事务的隔离性？"><span class="toc-text">物理的LATCH和逻辑的锁如何配合保证事务的隔离性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/剑指offer刷题笔记（一）/">剑指offer刷题笔记（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Socket编程/">Socket编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Effective C++ Note/">Effective C++ Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/13/Aurora Multi-Master 解读/">Aurora Multi-Master 解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Make学习/">Make学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Shell编程/">Shell编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/CMAKE 学习/">CMAKE 学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（三）——valgrind/">性能分析工具（三）——valgrind</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（二）——perf/">性能分析工具（二）——perf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/MysqlTuner使用/MysqlTuner使用/">MysqlTuner使用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">CPP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/database/">Database</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/oj/">OJ</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能分析/">性能分析</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Stockdean Mu.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>