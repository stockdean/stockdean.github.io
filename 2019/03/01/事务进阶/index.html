<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>事务进阶 | MyBlog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">事务进阶</h1><a id="logo" href="/.">MyBlog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">事务进阶</h1><div class="post-meta"><a href="/2019/03/01/事务进阶/#comments" class="comment-count"></a><p><span class="date">Mar 01, 2019</span><span><a href="/categories/Database/" class="category">Database</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><hr>
<h2 id="事务进阶"><a href="#事务进阶" class="headerlink" title="事务进阶"></a>事务进阶</h2><p><strong>这一部分通过sql语句的实践进一步了解事务的执行过程</strong></p>
<h2 id="跟踪SQL语句"><a href="#跟踪SQL语句" class="headerlink" title="跟踪SQL语句"></a>跟踪SQL语句</h2><h3 id="尝试跟踪一条select语句"><a href="#尝试跟踪一条select语句" class="headerlink" title="尝试跟踪一条select语句"></a>尝试跟踪一条select语句</h3><p>实验条件：</p>
<ul>
<li>隔离级别：RR；</li>
<li>autocommit=true，也就是说每一个sql语句都会被当作一个事务来对待；</li>
<li>SQL query：select <em> from trx;<br>`[trx0trx.cc]trx_commit_for_mysql(trx_t</em> trx)<code>--&gt;</code>[trx0trx.cc]trx_commit(trx_t* trx))<code>//函数中判断了事务是否修改了redo日志，本次select没有修改。--&gt;</code>[trx0trx.cc]trx_commit_low(trx, mtr)`&gt;//由于是select，mtr参数为NULL。–&gt;<blockquote>
<p>如果是一个执行了UPDATE的事务，mtr不再是NULL，此时会执行 <code>mtr_commit(mtr)</code> ，这个函数的注释解释如下：<br><code>mtr_commit</code>函数提交了mini­transaction，使得事务用当前LSN提交到文件系统中。事务的“持久化”是通过实际写入磁盘来保证的，但逻辑上的持久化操作就是从此函数开始的。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trx_commmit_in_memory()</span><br></pre></td></tr></table></figure>
<h3 id="跟踪事务流程"><a href="#跟踪事务流程" class="headerlink" title="跟踪事务流程"></a>跟踪事务流程</h3><p>从下面的函数开始跟踪</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************/</span></span><br><span class="line"><span class="comment">/**初始化同步变量，内存系统和线程*/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">srv_general_init(<span class="keyword">void</span>)</span><br><span class="line"><span class="comment">/*==================*/</span></span><br><span class="line">&#123;</span><br><span class="line">sync_check_init();</span><br><span class="line"><span class="comment">/* Reset the system variables in the recovery module. */</span></span><br><span class="line">recv_sys_var_init();</span><br><span class="line">os_thread_init();</span><br><span class="line">trx_pool_init();</span><br><span class="line">que_init();</span><br><span class="line">row_mysql_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="trx-pool-init函数阅读"><a href="#trx-pool-init函数阅读" class="headerlink" title="trx_pool_init函数阅读"></a>trx_pool_init函数阅读</h4><p>下面接着看一下其中的<code>trx_pool_init()</code>，其创建了<code>trx_t</code>的pool，<code>trx_t</code>就是我们上面说的描述一个事务的句柄。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Use explicit mutexes for the trx_t pool and its manager. */</span></span><br><span class="line"><span class="keyword">typedef</span> Pool&lt;<span class="keyword">trx_t</span>, TrxFactory, TrxPoolLock&gt; <span class="keyword">trx_pool_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> PoolManager&lt;<span class="keyword">trx_pool_t</span>, TrxPoolManagerLock &gt; <span class="keyword">trx_pools_t</span>;</span><br><span class="line"><span class="comment">/** The trx_t pool manager */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">trx_pools_t</span>* trx_pools;</span><br><span class="line"><span class="comment">/** 创建一个 trx_t的pool */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trx_pool_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">trx_pools = UT_NEW_NOKEY(<span class="keyword">trx_pools_t</span>(MAX_TRX_BLOCK_SIZE));</span><br><span class="line">ut_a(trx_pools != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="trx-pools类型阅读"><a href="#trx-pools类型阅读" class="headerlink" title="trx_pools类型阅读"></a>trx_pools类型阅读</h4><p><code>trx_pools</code>是一个<code>trx_pools_t</code>类型的指针，而<code>trx_pools_t</code>是一个模板类，如下：其功能是用来管理pool，如果pool不够，就每次增加一个pool。来请求时（比如申请一个<code>trx_t</code>），他会从Pool列表中选出一个，并执行<code>Pool‑&gt;get()</code>来获取一个<code>trx_t</code>。<code>trx_pools_t</code>的构造函数接收的值是创建一个新Pool的大小（4MB）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pool, <span class="keyword">typename</span> LockStrategy&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PoolManager</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> Pool PoolType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> PoolType::value_type value_type;</span><br><span class="line">PoolManager(<span class="keyword">size_t</span> size)</span><br><span class="line">:</span><br><span class="line">m_size(size)</span><br><span class="line">&#123;</span><br><span class="line">create();</span><br><span class="line">&#125;</span><br><span class="line">~PoolManager()</span><br><span class="line">&#123;</span><br><span class="line">destroy();</span><br><span class="line">ut_a(m_pools.empty());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Get an element from one of the pools.@return instance or NULL if pool is empty. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">value_type* <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> delay = <span class="number">1</span>;</span><br><span class="line">value_type* ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">m_lock_strategy.enter();</span><br><span class="line">ut_ad(!m_pools.empty());</span><br><span class="line"><span class="keyword">size_t</span> n_pools = m_pools.size();</span><br><span class="line">PoolType* pool = m_pools[index % n_pools];</span><br><span class="line">m_lock_strategy.<span class="built_in">exit</span>();</span><br><span class="line">ptr = pool-&gt;get();</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="number">0</span> &amp;&amp; (index / n_pools) &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!add_pool(n_pools)) &#123;</span><br><span class="line">ib::error() &lt;&lt; <span class="string">"Failed to allocate"</span></span><br><span class="line"><span class="string">" memory for a pool of size "</span></span><br><span class="line">&lt;&lt; m_size &lt;&lt; <span class="string">" bytes. Will"</span></span><br><span class="line"><span class="string">" wait for "</span> &lt;&lt; delay</span><br><span class="line">&lt;&lt; <span class="string">" seconds for a thread to"</span></span><br><span class="line"><span class="string">" free a resource"</span>;</span><br><span class="line"><span class="comment">/* There is nothing much we can do except crash and burn, however lets be a little optimistic and wait for a resource to be freed. */</span></span><br><span class="line">os_thread_sleep(delay * <span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">if</span> (delay &lt; <span class="number">32</span>) &#123;</span><br><span class="line">delay &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">delay = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++index;</span><br><span class="line">&#125; <span class="keyword">while</span> (ptr == <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mem_free</span><span class="params">(value_type* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PoolType::mem_free(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/** Add a new pool @param n_pools Number of pools that existed when the add pool was called. @return true on success */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_pool</span><span class="params">(<span class="keyword">size_t</span> n_pools)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> added = <span class="literal">false</span>;</span><br><span class="line">m_lock_strategy.enter();</span><br><span class="line"><span class="keyword">if</span> (n_pools &lt; m_pools.size()) &#123;</span><br><span class="line"><span class="comment">/* Some other thread already added a pool. */</span></span><br><span class="line">added = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PoolType* pool;</span><br><span class="line">ut_ad(n_pools == m_pools.size());</span><br><span class="line">pool = UT_NEW_NOKEY(PoolType(m_size));</span><br><span class="line"><span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123;</span><br><span class="line">ut_ad(n_pools &lt;= m_pools.size());</span><br><span class="line">m_pools.push_back(pool);</span><br><span class="line">ib::info() &lt;&lt; <span class="string">"Number of pools: "</span></span><br><span class="line">&lt;&lt; m_pools.size();</span><br><span class="line">added = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ut_ad(n_pools &lt; m_pools.size() || !added);</span><br><span class="line">m_lock_strategy.<span class="built_in">exit</span>();</span><br><span class="line"><span class="keyword">return</span>(added);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Create the pool manager. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ut_a(m_size &gt; <span class="keyword">sizeof</span>(value_type));</span><br><span class="line">m_lock_strategy.create();</span><br><span class="line">add_pool(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Release the resources. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typename</span> Pools::iterator it;</span><br><span class="line"><span class="keyword">typename</span> Pools::iterator end = m_pools.end();</span><br><span class="line"><span class="keyword">for</span> (it = m_pools.begin(); it != end; ++it) &#123;</span><br><span class="line">PoolType* pool = *it;</span><br><span class="line">UT_DELETE(pool);</span><br><span class="line">&#125;</span><br><span class="line">m_pools.clear();</span><br><span class="line">m_lock_strategy.destroy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// Disable copying</span></span><br><span class="line">PoolManager(<span class="keyword">const</span> PoolManager&amp;);</span><br><span class="line">PoolManager&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PoolManager&amp;);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PoolType*, ut_allocator&lt;PoolType*&gt; &gt; Pools;</span><br><span class="line"><span class="comment">/** Size of each block */</span></span><br><span class="line"><span class="keyword">size_t</span> m_size;</span><br><span class="line"><span class="comment">/** Pools managed this manager */</span></span><br><span class="line">Pools m_pools;</span><br><span class="line"><span class="comment">/** Lock strategy to use */</span></span><br><span class="line">LockStrategy m_lock_strategy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码中经常应用下面的宏定义来分配新对象，<code>new(std::nothrow)</code>是什么？和普通的new有何不同？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UT_NEW_NOKEY(expr) ::new(std::nothrow) expr</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>普通new一个异常的类型std::bad_alloc。这个是标准适应性态。 在早期C++的舞台上，这个性态和现在的非常不同；new将返回0来指出一个失败，和malloc()非常相似。 在内存不足时，<code>new (std::nothrow)</code>并不抛出异常，而是将指针置NULL。 在一定的环境下，返回一个NULL指针来表示一个失败依然是一个不错的选择。C++标准委员 会意识到这个问题，所以他们决定定义一个特别的new操作符版本，这个版本返回0表示失败。</p>
</blockquote>
<p><code>trx_pool_t</code>是一个Pool模板类实例，Pool模板类定义如下：<br>总的来说，Pool模板类接收一个参数，分配一块该参数大小的内存，然后转换成trx_t的一个数组。<br>我们接下来首先看Pool模板类的功能，接着看第二个模板参数<code>TrxFactory</code>完成什么功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**<span class="keyword">typedef</span> Pool <span class="keyword">trx_pool_t</span>;**</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span> Factory, <span class="keyword">typename</span> LockStrategy&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pool</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> Type value_type;</span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> Add an assertion to check alignment and offset is</span></span><br><span class="line"><span class="comment">// as we expect it. Also, sizeof(void*) can be 8, can we impove on this.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Element</span> &#123;</span></span><br><span class="line">Pool* m_pool;</span><br><span class="line">value_type m_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/** Constructor</span></span><br><span class="line"><span class="comment">@(Database)param size size of the memory block */</span></span><br><span class="line">Pool(<span class="keyword">size_t</span> size)</span><br><span class="line">:</span><br><span class="line">m_end(),</span><br><span class="line">m_start(),</span><br><span class="line">m_size(size),</span><br><span class="line">m_last()</span><br><span class="line">&#123;</span><br><span class="line">ut_a(size &gt;= <span class="keyword">sizeof</span>(Element));</span><br><span class="line">m_lock_strategy.create();</span><br><span class="line">ut_a(m_start == <span class="number">0</span>);</span><br><span class="line">m_start = <span class="keyword">reinterpret_cast</span>&lt;Element*&gt;(ut_zalloc_nokey(m_size));</span><br><span class="line">m_last = m_start;</span><br><span class="line">m_end = &amp;m_start[m_size / <span class="keyword">sizeof</span>(*m_start)];</span><br><span class="line"><span class="comment">/* Note: Initialise only a small subset, even though we have allocated all the memory. This is required only because PFS (MTR) results change if we instantiate too many mutexes up front. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init(ut_min(<span class="keyword">size_t</span>(<span class="number">16</span>), <span class="keyword">size_t</span>(m_end - m_start)));</span><br><span class="line">ut_ad(m_pqueue.size() &lt;= <span class="keyword">size_t</span>(m_last - m_start));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Destructor */</span></span><br><span class="line">~Pool()</span><br><span class="line">&#123;</span><br><span class="line">m_lock_strategy.destroy();</span><br><span class="line"><span class="keyword">for</span> (Element* elem = m_start; elem != m_last; ++elem) &#123;</span><br><span class="line">ut_ad(elem-&gt;m_pool == <span class="keyword">this</span>);</span><br><span class="line">Factory::destroy(&amp;elem-&gt;m_type);</span><br><span class="line">&#125;</span><br><span class="line">ut_free(m_start);</span><br><span class="line">m_end = m_last = m_start = <span class="number">0</span>;</span><br><span class="line">m_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Get an object from the pool.@retrun a free instance or NULL if exhausted. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">Type* <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Element* elem;</span><br><span class="line">m_lock_strategy.enter();</span><br><span class="line"><span class="keyword">if</span> (!m_pqueue.empty()) &#123;</span><br><span class="line">elem = m_pqueue.top();</span><br><span class="line">m_pqueue.pop();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_last &lt; m_end) &#123;</span><br><span class="line"><span class="comment">/* Initialise the remaining elements. */</span></span><br><span class="line">init(m_end - m_last);</span><br><span class="line">ut_ad(!m_pqueue.empty());</span><br><span class="line">elem = m_pqueue.top();</span><br><span class="line">m_pqueue.pop();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">elem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_lock_strategy.<span class="built_in">exit</span>();</span><br><span class="line"><span class="keyword">return</span>(elem != <span class="literal">NULL</span> ? &amp;elem-&gt;m_type : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Add the object to the pool.@param ptr object to free */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mem_free</span><span class="params">(value_type* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Element* elem;</span><br><span class="line">byte* p = <span class="keyword">reinterpret_cast</span>&lt;byte*&gt;(ptr + <span class="number">1</span>);</span><br><span class="line">elem = <span class="keyword">reinterpret_cast</span>&lt;Element*&gt;(p - <span class="keyword">sizeof</span>(*elem));</span><br><span class="line">elem-&gt;m_pool-&gt;put(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Disable copying</span></span><br><span class="line">Pool(<span class="keyword">const</span> Pool&amp;);</span><br><span class="line">Pool&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Pool&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/* We only need to compare on pointer address. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::priority_queue&lt;</span><br><span class="line">Element*,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Element*, ut_allocator&lt;Element*&gt; &gt;,</span><br><span class="line"><span class="built_in">std</span>::greater&lt;Element*&gt; &gt; <span class="keyword">pqueue_t</span>;</span><br><span class="line"><span class="comment">/** Release the object to the free pool @param elem element to free */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Element* elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_lock_strategy.enter();</span><br><span class="line">ut_ad(elem &gt;= m_start &amp;&amp; elem &lt; m_last);</span><br><span class="line">ut_ad(Factory::debug(&amp;elem-&gt;m_type));</span><br><span class="line">m_pqueue.push(elem);</span><br><span class="line">m_lock_strategy.<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Initialise the elements.@param n_elems Number of elements to initialise */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">size_t</span> n_elems)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ut_ad(<span class="keyword">size_t</span>(m_end - m_last) &gt;= n_elems);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n_elems; ++i, ++m_last) &#123;</span><br><span class="line">m_last-&gt;m_pool = <span class="keyword">this</span>;</span><br><span class="line">Factory::init(&amp;m_last-&gt;m_type);</span><br><span class="line">m_pqueue.push(m_last);</span><br><span class="line">&#125;</span><br><span class="line">ut_ad(m_last &lt;= m_end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/** Pointer to the last element */</span></span><br><span class="line">Element* m_end;</span><br><span class="line"><span class="comment">/** Pointer to the first element */</span></span><br><span class="line">Element* m_start;</span><br><span class="line"><span class="comment">/** Size of the block in bytes */</span></span><br><span class="line"><span class="keyword">size_t</span> m_size;</span><br><span class="line"><span class="comment">/** Upper limit of used space */</span></span><br><span class="line">Element* m_last;</span><br><span class="line"><span class="comment">/** Priority queue ordered on the pointer addresse. */</span></span><br><span class="line"><span class="keyword">pqueue_t</span> m_pqueue;</span><br><span class="line"><span class="comment">/** Lock strategy to use */</span></span><br><span class="line">LockStrategy m_lock_strategy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>TrxFactory</strong>是一个类，定义如下：<br>TrxFactory的功能是回收和创建<code>trx_t</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** For managing the life-cycle of the trx_t instance that we get</span></span><br><span class="line"><span class="comment">from the pool. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrxFactory</span> &#123;</span></span><br><span class="line"><span class="comment">/** Initializes a transaction object. It must be explicitly started with trx_start_if_not_started() before using it. The default isolation level is TRX_ISO_REPEATABLE_READ. @param trx Transaction instance to initialise */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">trx_t</span>* trx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* Explicitly call the constructor of the already allocated object. trx_t objects are allocated by ut_zalloc() in Pool::Pool() which would not call the constructors of the trx_t members. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>(&amp;trx-&gt;mod_tables) <span class="keyword">trx_mod_tables_t</span>();</span><br><span class="line"><span class="keyword">new</span>(&amp;trx-&gt;lock.rec_pool) <span class="keyword">lock_pool_t</span>();</span><br><span class="line"><span class="keyword">new</span>(&amp;trx-&gt;lock.table_pool) <span class="keyword">lock_pool_t</span>();</span><br><span class="line"><span class="keyword">new</span>(&amp;trx-&gt;lock.table_locks) <span class="keyword">lock_pool_t</span>();</span><br><span class="line"><span class="keyword">new</span>(&amp;trx-&gt;hit_list) <span class="keyword">hit_list_t</span>();</span><br><span class="line">trx_init(trx);</span><br><span class="line">trx-&gt;state = TRX_STATE_NOT_STARTED;</span><br><span class="line">trx-&gt;dict_operation_lock_mode = <span class="number">0</span>;</span><br><span class="line">trx-&gt;xid = UT_NEW_NOKEY(<span class="keyword">xid_t</span>());</span><br><span class="line">trx-&gt;detailed_error = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(</span><br><span class="line">ut_zalloc_nokey(MAX_DETAILED_ERROR_LEN));</span><br><span class="line">trx-&gt;lock.lock_heap = mem_heap_create_typed(</span><br><span class="line"><span class="number">1024</span>, MEM_HEAP_FOR_LOCK_HEAP);</span><br><span class="line">lock_trx_lock_list_init(&amp;trx-&gt;lock.trx_locks);</span><br><span class="line">UT_LIST_INIT(</span><br><span class="line">trx-&gt;trx_savepoints,</span><br><span class="line">&amp;<span class="keyword">trx_named_savept_t</span>::trx_savepoints);</span><br><span class="line">mutex_create(LATCH_ID_TRX, &amp;trx-&gt;mutex);</span><br><span class="line">mutex_create(LATCH_ID_TRX_UNDO, &amp;trx-&gt;undo_mutex);</span><br><span class="line">lock_trx_alloc_locks(trx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Release resources held by the transaction object. @param trx the transaction for which to release resources */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">trx_t</span>* trx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ut_ad(!trx-&gt;in_rw_trx_list);</span><br><span class="line">ut_ad(!trx-&gt;in_mysql_trx_list);</span><br><span class="line">ut_a(trx-&gt;lock.wait_lock == <span class="literal">NULL</span>);</span><br><span class="line">ut_a(trx-&gt;lock.wait_thr == <span class="literal">NULL</span>);</span><br><span class="line">ut_a(!trx-&gt;has_search_latch);</span><br><span class="line">ut_a(trx-&gt;dict_operation_lock_mode == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;lock.lock_heap != <span class="literal">NULL</span>) &#123;</span><br><span class="line">mem_heap_free(trx-&gt;lock.lock_heap);</span><br><span class="line">trx-&gt;lock.lock_heap = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">ut_a(UT_LIST_GET_LEN(trx-&gt;lock.trx_locks) == <span class="number">0</span>);</span><br><span class="line">UT_DELETE(trx-&gt;xid);</span><br><span class="line">ut_free(trx-&gt;detailed_error);</span><br><span class="line">mutex_free(&amp;trx-&gt;mutex);</span><br><span class="line">mutex_free(&amp;trx-&gt;undo_mutex);</span><br><span class="line">trx-&gt;mod_tables.~<span class="keyword">trx_mod_tables_t</span>();</span><br><span class="line">ut_ad(trx-&gt;read_view == <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!trx-&gt;lock.rec_pool.empty()) &#123;</span><br><span class="line"><span class="comment">/* See lock_trx_alloc_locks() why we only free the first element. */</span></span><br><span class="line"></span><br><span class="line">ut_free(trx-&gt;lock.rec_pool[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!trx-&gt;lock.table_pool.empty()) &#123;</span><br><span class="line"><span class="comment">/* See lock_trx_alloc_locks() why we only free the first element. */</span></span><br><span class="line"></span><br><span class="line">ut_free(trx-&gt;lock.table_pool[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">trx-&gt;lock.rec_pool.~<span class="keyword">lock_pool_t</span>();</span><br><span class="line">trx-&gt;lock.table_pool.~<span class="keyword">lock_pool_t</span>();</span><br><span class="line">trx-&gt;lock.table_locks.~<span class="keyword">lock_pool_t</span>();</span><br><span class="line">trx-&gt;hit_list.~<span class="keyword">hit_list_t</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Enforce any invariants here, this is called before the transaction is added to the pool. @return true if all OK */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">debug</span><span class="params">(<span class="keyword">const</span> <span class="keyword">trx_t</span>* trx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ut_a(trx-&gt;error_state == DB_SUCCESS);</span><br><span class="line">ut_a(trx-&gt;magic_n == TRX_MAGIC_N);</span><br><span class="line">ut_ad(!trx-&gt;read_only);</span><br><span class="line">ut_ad(trx-&gt;state == TRX_STATE_NOT_STARTED</span><br><span class="line">|| trx-&gt;state == TRX_STATE_FORCED_ROLLBACK);</span><br><span class="line">ut_ad(trx-&gt;dict_operation == TRX_DICT_OP_NONE);</span><br><span class="line">ut_ad(trx-&gt;mysql_thd == <span class="number">0</span>);</span><br><span class="line">ut_ad(!trx-&gt;in_rw_trx_list);</span><br><span class="line">ut_ad(!trx-&gt;in_mysql_trx_list);</span><br><span class="line">ut_a(trx-&gt;lock.wait_thr == <span class="literal">NULL</span>);</span><br><span class="line">ut_a(trx-&gt;lock.wait_lock == <span class="literal">NULL</span>);</span><br><span class="line">ut_a(!trx-&gt;has_search_latch);</span><br><span class="line">ut_a(trx-&gt;dict_operation_lock_mode == <span class="number">0</span>);</span><br><span class="line">ut_a(UT_LIST_GET_LEN(trx-&gt;lock.trx_locks) == <span class="number">0</span>);</span><br><span class="line">ut_ad(trx-&gt;autoinc_locks == <span class="literal">NULL</span>);</span><br><span class="line">ut_ad(trx-&gt;lock.table_locks.empty());</span><br><span class="line">ut_ad(!trx-&gt;<span class="built_in">abort</span>);</span><br><span class="line">ut_ad(trx-&gt;hit_list.empty());</span><br><span class="line">ut_ad(trx-&gt;killed_by == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再说一下关键字new，上面的init()函数里：<code>new(&amp;trx‑&gt;mod_tables) trx_mod_tables_t();</code>是什么用法？<br>这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void* operator</span><br><span class="line">new(size_t,void*); void operator delete(void,void);</span><br></pre></td></tr></table></figure></p>
<p>提示1：palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组。<br>提示2：placement new构造起来的对象或其数组，要显示的调用他们的析构函数来销毁，千万不要使用delete。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* p = new(nothrow) char[100]; long *q1 = new(p) long(100); int *q2 = new(p) int[100/sizeof(int)];</span><br></pre></td></tr></table></figure>
<p>具体查看此文：<a href="http://www.jb51.net/article/41524.htm" target="_blank" rel="noopener">C++中new关键字的三种用法</a></p>
<p><strong>函数trx_pool_init()总结</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/** Create the trx_t pool */</span><br><span class="line">void</span><br><span class="line">trx_pool_init()</span><br><span class="line">&#123;</span><br><span class="line">trx_pools = UT_NEW_NOKEY(trx_pools_t(MAX_TRX_BLOCK_SIZE));</span><br><span class="line">ut_a(trx_pools != 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数创建了一个<code>trx_pools</code>的静态变量，该变量是<code>trx_t</code>类型的Pool的管理器，括号中传入的<br><code>MAX_TRX_BLOCK_SIZE</code>是用来初始化创建新Pool的大小的，单位为byte，该值为4MB.</p>
<h3 id="执行一个UPDATE的函数调用"><a href="#执行一个UPDATE的函数调用" class="headerlink" title="执行一个UPDATE的函数调用"></a>执行一个UPDATE的函数调用</h3><p>语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE trx SET data=data+1 WHERE pk=1;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>获得表对象： <code>open_table(thd, tables, ot_ctx);</code></li>
</ul>
<ul>
<li>该函数首先会使用 <code>get_table()</code> 来获取TABLE对象<br>在执行UPDATE时，首先会执行上面的函数来获取一个TABLE对象。同时该函数会调用 <code>check_trx_exist(THD*thd)</code>来检测用于该UPDATE的用户线程是否拥有一个 <code>trx_t</code> ，如果没有(用户首次登陆时)，则会调用<code>innobase_trx_allocate()</code> 来分配一个；如果此时线程已经拥有一个 <code>trx_t</code> ，则会调用<code>innobase_trx_init()</code> 来初始化该 trx_t (重用)。</li>
<li>接着执行 <code>table‑&gt;init(thd, table_list);</code> 来初始化表对象<br>该函数在执行时仍然会重复上面的 <code>trx_t</code> 检查，再次执行 <code>check_trx_exist(THD* thd)</code> 。</li>
</ul>
<hr>
<ul>
<li>接着执行 <code>mysql_update()</code> 函数，该函数会依次执行下面几个函数<ul>
<li>执行 <code>mysql_lock_tables()</code>获得表锁<ul>
<li><code>mysql_lock_tables()</code> 会依次调用下面的函数完成加锁：</li>
<li><code>get_lock_data()</code> 获得锁的一个实例 （ <code>MYSQL_LOCK</code> *）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>该函数在执行时仍然会重复上面的 <code>trx_t</code> 检查，再次执行 <code>check_trx_exist(THD* thd)</code> 。</p>
<hr>
<ul>
<li>接着执行 ha_innobase::info() 来获得统计信息返回给MySQL接口层。<br>该函数在执行时仍然会重复上面的 <code>trx_t</code> 检查，再次执行 <code>check_trx_exist(THD* thd)</code> 。</li>
</ul>
<hr>
<ul>
<li>接下来开始真正的行更新<br>从 <code>btr_cur_upd_lock_and_undo()</code> 函数开始看，该函数的功能时检查加锁情况，并直接调用<code>trx_undo_report_row_operation()</code> 。</li>
</ul>
<p><strong>trx_undo_report_row_operation()</strong><br>该函数记录UPDATE、INSERT和DELETE操作的undo log用以回滚和一致性读。</p>
<blockquote>
<p>trx‑&gt;id=9988<br>trx‑&gt;commit_lsn=0<br>mtr‑&gt;commit_lsn=0<br>mtr‑&gt;m_log‑&gt;m_first_block‑&gt;m_used=37(日志大小)</p>
</blockquote>
<p><strong>commit()</strong><br>该函数执行完成后，<code>mtr‑&gt;commit_lsn=253065</code><br>应该还有更新redo日志</p>
<hr>
<ul>
<li>最后执行 <code>trans_commit_stmt(THD *thd)</code><br>该函数功能提交一个单语句事务。该函数判断传入用户线程thd关联的事务是否处于活动状态，如果是，则调用<code>trans_commit_stmt(THD *thd)</code> 来提交该事务，下面看一下该函数。</li>
</ul>
<p><strong>trans_commit_stmt(THD *thd)</strong><br>该函数判断了事务的锁信息和是否有子事务后，直接调用 <code>TC_LOG_DUMMY::commit()</code> 该函数没有做任何事，直接调用 <code>ha_commit_low()</code> 。</p>
<p><code>ha_commit_low()</code> 会接着调用 <code>innobase_commit_low()</code> , <code>innobase_commit_low()</code> 判断事务是否开始，开始的话调用 <code>trx_commit_for_mysql(trx);</code> 。</p>
<p><code>trx_commit_for_mysql(trx)</code> 会接着调用 <code>trx_commit()</code> 。 <code>trx_commit()</code> 在判断事务是否生成redo日志后执行 <code>trx_commit_low()</code> ， <code>trx_commit_low()</code> 做了类似的判断（先是判断是否修改了全文索引，再是判断是否产生了redo日志）之后执行 <code>trx_commit_in_memory()</code> 下面看下此函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************/</span></span><br><span class="line"><span class="comment">/**Commits a transaction in memory. */</span></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trx_commit_in_memory(</span><br><span class="line"><span class="comment">/*=================*/</span></span><br><span class="line"><span class="keyword">trx_t</span>* trx, <span class="comment">/*!&lt; in/out: transaction */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">mtr_t</span>* mtr, <span class="comment">/*!&lt; in: mini-transaction of</span></span><br><span class="line"><span class="comment">trx_write_serialisation_history(), or NULL if</span></span><br><span class="line"><span class="comment">the transaction did not modify anything */</span></span><br><span class="line"><span class="keyword">bool</span> serialised)<span class="comment">/*!&lt; in: true if serialisation log was written */</span></span><br><span class="line">&#123;</span><br><span class="line">trx-&gt;must_flush_log_later = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (trx_is_autocommit_non_locking(trx)) &#123;</span><br><span class="line">ut_ad(trx-&gt;id == <span class="number">0</span>);</span><br><span class="line">ut_ad(trx-&gt;read_only);</span><br><span class="line">ut_a(!trx-&gt;is_recovered);</span><br><span class="line">ut_ad(trx-&gt;rsegs.m_redo.rseg == <span class="literal">NULL</span>);</span><br><span class="line">ut_ad(!trx-&gt;in_rw_trx_list);</span><br><span class="line"><span class="comment">/* Note: We are asserting without holding the lock mutex. But that is OK because this transaction is not waiting and cannot be rolled back and no new locks can (or should not) be added becuase it is flagged as a non-locking read-only transaction. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ut_a(UT_LIST_GET_LEN(trx-&gt;lock.trx_locks) == <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* This state change is not protected by any mutex, therefore there is an inherent race here around state transition during printouts. We ignore this race for the sake of efficiency. However, the trx_sys_t::mutex will protect the trx_t instance and it cannot be removed from the mysql_trx_list and freed without first acquiring the trx_sys_t::mutex. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ut_ad(trx_state_eq(trx, TRX_STATE_ACTIVE));</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;read_view != <span class="literal">NULL</span>) &#123;</span><br><span class="line">trx_sys-&gt;mvcc-&gt;view_close(trx-&gt;read_view, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">MONITOR_INC(MONITOR_TRX_NL_RO_COMMIT);</span><br><span class="line"><span class="comment">/* AC-NL-RO transactions can't be rolled back asynchronously. */</span></span><br><span class="line">ut_ad(!trx-&gt;<span class="built_in">abort</span>);</span><br><span class="line">ut_ad(!(trx-&gt;in_innodb</span><br><span class="line">&amp; (TRX_FORCE_ROLLBACK | TRX_FORCE_ROLLBACK_ASYNC)));</span><br><span class="line">trx-&gt;state = TRX_STATE_NOT_STARTED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;id &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* For consistent snapshot, we need to remove current transaction from running transaction id list for mvcc before doing commit and releasing locks. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trx_erase_lists(trx, serialised);</span><br><span class="line">&#125;</span><br><span class="line">lock_trx_release_locks(trx);</span><br><span class="line"><span class="comment">/* Remove the transaction from the list of active transactions now that it no longer holds any user locks. */</span></span><br><span class="line"></span><br><span class="line">ut_ad(trx_state_eq(trx, TRX_STATE_COMMITTED_IN_MEMORY));</span><br><span class="line">DEBUG_SYNC_C(<span class="string">"after_trx_committed_in_memory"</span>);</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;read_only || trx-&gt;rsegs.m_redo.rseg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">MONITOR_INC(MONITOR_TRX_RO_COMMIT);</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;read_view != <span class="literal">NULL</span>) &#123;</span><br><span class="line">trx_sys-&gt;mvcc-&gt;view_close(</span><br><span class="line">trx-&gt;read_view, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ut_ad(trx-&gt;id &gt; <span class="number">0</span>);</span><br><span class="line">MONITOR_INC(MONITOR_TRX_RW_COMMIT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_redo.rseg != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">trx_rseg_t</span>* rseg = trx-&gt;rsegs.m_redo.rseg;</span><br><span class="line">mutex_enter(&amp;rseg-&gt;mutex);</span><br><span class="line">ut_ad(rseg-&gt;trx_ref_count &gt; <span class="number">0</span>);</span><br><span class="line">--rseg-&gt;trx_ref_count;</span><br><span class="line">mutex_exit(&amp;rseg-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mtr != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_redo.insert_undo != <span class="literal">NULL</span>) &#123;</span><br><span class="line">trx_undo_insert_cleanup(&amp;trx-&gt;rsegs.m_redo, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_noredo.insert_undo != <span class="literal">NULL</span>) &#123;</span><br><span class="line">trx_undo_insert_cleanup(&amp;trx-&gt;rsegs.m_noredo, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* NOTE that we could possibly make a group commit more efficient here: call os_thread_yield here to allow also other trxs to come to commit! */</span></span><br><span class="line"><span class="comment">/*-------------------------------------*/</span></span><br><span class="line"><span class="comment">/* Depending on the my.cnf options, we may now write the log buffer to the log files, making the transaction durable if the OS does not crash. We may also flush the log files to disk, making the transaction durable also at an OS crash or a power outage. The idea in InnoDB's group commit is that a group of transactions gather behind a trx doing a physical disk write transactions gather behind a trx doing a physical disk write one of those transactions does a write which commits the whole group. Note that this group commit will only bring benefit if there are &gt; 2 users in the database. Then at least 2 users can gather behind one doing the physical log write to disk. If we are calling trx_commit() under prepare_commit_mutex, we will delay possible log write and flush to a separate function trx_commit_complete_for_mysql(), which is only called when the thread has released the mutex. This is to make the group commit algorithm to work. Otherwise, the prepare_commit mutex would serialize all commits and prevent a group of transactions from gathering. */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">lsn_t</span> lsn = mtr-&gt;commit_lsn();</span><br><span class="line"><span class="keyword">if</span> (lsn == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Nothing to be done. */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (trx-&gt;flush_log_later) &#123;</span><br><span class="line"><span class="comment">/* Do nothing yet */</span></span><br><span class="line">trx-&gt;must_flush_log_later = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (srv_flush_log_at_trx_commit == <span class="number">0</span></span><br><span class="line">|| thd_requested_durability(trx-&gt;mysql_thd)</span><br><span class="line">== HA_IGNORE_DURABILITY) &#123;</span><br><span class="line"><span class="comment">/* Do nothing */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">trx-&gt;commit_lsn = lsn; <span class="comment">//把mtr提交的lsn赋值给事务trx</span></span><br><span class="line"><span class="comment">/* Tell server some activity has happened, since the trx does changes something. Background utility threads like master thread, purge thread or page_cleaner thread might have some work to do. */</span></span><br><span class="line"></span><br><span class="line">srv_active_wake_master_thread();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Free all savepoints, starting from the first. */</span></span><br><span class="line"><span class="keyword">trx_named_savept_t</span>* savep = UT_LIST_GET_FIRST(trx-&gt;trx_savepoints);</span><br><span class="line">trx_roll_savepoints_free(trx, savep);</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;fts_trx != <span class="literal">NULL</span>) &#123;</span><br><span class="line">trx_finalize_for_fts(trx, trx-&gt;undo_no != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">trx_mutex_enter(trx);</span><br><span class="line">trx-&gt;dict_operation = TRX_DICT_OP_NONE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Because we can rollback transactions asynchronously, we change the state at the last step. trx_t::abort cannot change once commit or rollback has started because we will have released the locks by the time we get here. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trx-&gt;<span class="built_in">abort</span>) &#123;</span><br><span class="line">trx-&gt;<span class="built_in">abort</span> = <span class="literal">false</span>;</span><br><span class="line">trx-&gt;state = TRX_STATE_FORCED_ROLLBACK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">trx-&gt;state = TRX_STATE_NOT_STARTED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* trx-&gt;in_mysql_trx_list would hold between trx_allocate_for_mysql() and trx_free_for_mysql(). It does not hold for recovered transactions or system transactions. */</span></span><br><span class="line">assert_trx_is_free(trx);</span><br><span class="line">trx_init(trx);</span><br><span class="line">trx_mutex_exit(trx);</span><br><span class="line">ut_a(trx-&gt;error_state == DB_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mtr和trx联系"><a href="#mtr和trx联系" class="headerlink" title="mtr和trx联系"></a>mtr和trx联系</h4><ul>
<li>在执行最后的 <code>trx_commit_in_memory()</code> 前，两者没有什么交互，各司其职：当trx需要写日志（比如undo log）时，会用一个mtr，将构造好undo log的内容传入<code>mtr‑&gt;m_log</code>。最后，trx会调用 <code>mtr_commit(&amp;mtr)</code> 将日志写盘.<code>mtr_commit()</code>是将日志写缓冲区,而不是写盘.写盘是 <code>innobase_commit()</code> 调用<code>trx_commit_complete_for_mysql()</code> 来实现.</li>
</ul>
<p>上述动作的代码一般是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mtr_t mtr; //构造一个mtr</span><br><span class="line">mtr_start(&amp;mtr); //开始一个mtr（仅初始化上面构造的mtr）</span><br><span class="line">...构造各种日志和需要落盘的数据，例如构造undo log的trx_undo_create...</span><br><span class="line">mtr_commit(&amp;mtr); //提交该mtr</span><br></pre></td></tr></table></figure>
<ul>
<li>当执行 <code>trx_commit_in_memory()</code> 时：<br>函数会将最后一个mtr的<code>mtr‑&gt;commit_lsn</code>赋值给trx，完成事务的提交。最后一个mtr在 <code>trx_commit()</code> 中构造，并在 <code>trx_commit_low()</code> 中提交。</li>
</ul>
<p>####几个关于MTR的问题</p>
<blockquote>
<ul>
<li>弄清楚mtr产生的规律？<br>上面实验中提到，当事务提交时需要一个mtr来完成持久化。通过查阅资料和调试，当需要进行持久化操作时都会进行mtr的提交。通过跟踪一条update语句，发现会执行三次mtr的提交，分别是：<br>1）为事务分配undo段，写入undo段时；<br>2）更新索引和记录时；<br>3）标记事务为提交状态时。</li>
<li>事务和lsn的关系？<br>通过跟踪调试，发现事务和lsn关系不大，唯一的联系是当事务在内存中标记提交时，系统会把事务产生的最后一个mtr提交的lsn赋给该事务，用于最后的日志刷盘。即lsn对于事务来说，只是用于标记事务提交时，应该把日志至少刷到lsn那个位置。事务id在innodb中是用来标记读写（RW）事务的只读（RO）事务的id永远是0.读写事务的id用于多版本中数据的可见性判断。<br>值得一提的是，redo日志中不直接记录事务id的。redo日志只记录页的修改！！<br>通过查阅资料[博客1、2]，因为undo log是存在回滚段中，所以redo记录undo log时和记录普通数据页十分相似。通过将undo log持久化，当需要崩溃回滚时，先用redo复原出undo段的信息，再通过undo段记录的事务的状态和事务提交前的数据，进行事务的回滚。事务提交时，也是通过标记undo的状态来实现。</li>
<li>trx_t如何分配给线程？<br>在打开表时，总会执行<code>ha_innobase::extra()</code>函数，该函数会调用<code>check_trx_exists()</code>，<code>check_trx_exists</code>会检查传入的thd是否关联一个事务句柄（trx_t），如果没有就创建一个，如果已经关联，则进行初始化，以重用。</li>
<li>ReadView何时分配？<br>前面实验提到，MVCC是在事务执行第一条SELECT语句时才分配。通过查看代码，其是在row_search_mvcc()-&gt;trx_assign_view()[row0sel.cc,5033 row]下分配的。</li>
</ul>
</blockquote>
<p><strong>相关博客</strong><br><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="noopener">MySQL·引擎特性InnoDB 事务系统</a><br><a href="http://www.4u4v.net/mysql-undo-ji-redo-xiang-jie.html" target="_blank" rel="noopener">InnoDB事务回滚中redo和undo的互动</a></p>
<h3 id="UNDO日志"><a href="#UNDO日志" class="headerlink" title="UNDO日志"></a>UNDO日志</h3><p>在 <code>row0undo.h</code> 文件中有undo结构体 <code>undo_node_t</code> 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Undo node structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">undo_node_t</span>&#123;</span></span><br><span class="line"><span class="keyword">que_common_t</span> common; <span class="comment">/*!&lt; node type: QUE_NODE_UNDO */</span></span><br><span class="line"><span class="keyword">enum</span> undo_exec state; <span class="comment">/*!&lt; node execution state */</span></span><br><span class="line"><span class="keyword">trx_t</span>* trx; <span class="comment">/*!&lt; trx for which undo is done */</span></span><br><span class="line"><span class="keyword">roll_ptr_t</span> roll_ptr;<span class="comment">/*!&lt; roll pointer to undo log record */</span></span><br><span class="line"><span class="keyword">trx_undo_rec_t</span>* undo_rec;<span class="comment">/*!&lt; undo log record */</span></span><br><span class="line"><span class="keyword">undo_no_t</span> undo_no;<span class="comment">/*!&lt; undo number of the record */</span></span><br><span class="line">ulint rec_type;<span class="comment">/*!&lt; undo log record type: TRX_UNDO_INSERT_REC, ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trx_id_t</span> new_trx_id; <span class="comment">/*!&lt; trx id to restore to clustered index record */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">btr_pcur_t</span> pcur; <span class="comment">/*!&lt; persistent cursor used in searching the clustered index record */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dict_table_t</span>* table; <span class="comment">/*!&lt; table where undo is done */</span></span><br><span class="line">ulint cmpl_info;<span class="comment">/*!&lt; compiler analysis of an update */</span></span><br><span class="line"><span class="keyword">upd_t</span>* update; <span class="comment">/*!&lt; update vector for a clustered index record */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dtuple_t</span>* ref; <span class="comment">/*!&lt; row reference to the next row to handle */</span></span><br><span class="line"><span class="keyword">dtuple_t</span>* row; <span class="comment">/*!&lt; a copy (also fields copied to heap) of the row to handle */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">row_ext_t</span>* ext; <span class="comment">/*!&lt; NULL, or prefixes of the externally stored columns of the row */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dtuple_t</span>* undo_row;<span class="comment">/*!&lt; NULL, or the row after undo */</span></span><br><span class="line"><span class="keyword">row_ext_t</span>* undo_ext;<span class="comment">/*!&lt; NULL, or prefixes of the externally stored columns of undo_row */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dict_index_t</span>* index; <span class="comment">/*!&lt; the next index whose record should be handled */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mem_heap_t</span>* heap; <span class="comment">/*!&lt; memory heap used as auxiliary storage for row; this must be emptied after undo is tried on a row */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="事务流程分析"><a href="#事务流程分析" class="headerlink" title="事务流程分析"></a>事务流程分析</h2><h3 id="实验一：包含select、update和insert的事务执行"><a href="#实验一：包含select、update和insert的事务执行" class="headerlink" title="实验一：包含select、update和insert的事务执行"></a>实验一：包含select、update和insert的事务执行</h3><p>执行下面sql语句，逐条跟踪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE trx(</span><br><span class="line"> pk INT NOT NULL,</span><br><span class="line"> DATA INT</span><br><span class="line">) ENGINE = innodb;</span><br><span class="line">SET AUTOCOMMIT = false;</span><br><span class="line">-- 从此处跟踪</span><br><span class="line">BEGIN;</span><br><span class="line">SELECT * FROM trx where pk = 1;</span><br><span class="line">UPDATE trx set data = data +1 where pk = 1;</span><br><span class="line">INSERT INTO trx VALUES(6,1);</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<h4 id="BEGIN；"><a href="#BEGIN；" class="headerlink" title="BEGIN；"></a>BEGIN；</h4><p><strong>BEGIN；</strong> 语句是不会进入InnoDB层的，在handler层就会被挡住，innobase层不会为其分配trx_t。其作用是：<br>1）提交上次未显式提交的事务；2）设置线程的状态变量；</p>
<blockquote>
<p><code>trans_begin(thd, lex‑&gt;start_transaction_opt)</code></p>
</blockquote>
<p>在Parse阶段， BEGIN 命令对应执行的函数为 <code>trans_begin(thd, lex‑&gt;start_transaction_opt)</code> ，下面看一下其代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*开启一个事务。另外，会隐式提交上个未完成的事务（或事务性的命令如 flush tables），并释放thd所拥有的表锁。*/</span></span><br><span class="line"><span class="comment">//@note Beginning a transaction implicitly commits any current</span></span><br><span class="line"><span class="comment">//transaction and releases existing locks.</span></span><br><span class="line"><span class="comment">//@param thd Current thread</span></span><br><span class="line"><span class="comment">//@param flags Transaction flags</span></span><br><span class="line"><span class="comment">//@retval FALSE Success</span></span><br><span class="line"><span class="comment">//@retval TRUE Failure</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">trans_begin</span><span class="params">(THD *thd, uint flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res= FALSE;</span><br><span class="line">Transaction_state_tracker *tst= <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* 本段代码设置thd的session_tracker变量，此变量功能后面阅读 &#123; */</span></span><br><span class="line"><span class="keyword">if</span> (thd-&gt;variables.session_track_transaction_info &gt; TX_TRACK_NONE)</span><br><span class="line">tst= (Transaction_state_tracker *)</span><br><span class="line">thd-&gt;session_tracker.get_tracker(TRANSACTION_INFO_TRACKER);</span><br><span class="line"><span class="comment">/*&#125; */</span></span><br><span class="line"><span class="comment">//释放此thd拥有的表锁</span></span><br><span class="line">thd-&gt;locked_tables_list.unlock_locked_tables(thd);</span><br><span class="line"><span class="comment">/* 检测thd是否处于`多语句事务状态`，处于该状态说明上一个事务，或事务性的命令（拥有表锁OPTION_TABLE_LOCK）没有提交，则调用ha_commit_trans()先提交该事务或命令。&#123; */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (thd-&gt;in_multi_stmt_transaction_mode() ||</span><br><span class="line">(thd-&gt;variables.option_bits &amp; OPTION_TABLE_LOCK))</span><br><span class="line">&#123;</span><br><span class="line">thd-&gt;variables.option_bits&amp;= ~OPTION_TABLE_LOCK;</span><br><span class="line">thd-&gt;server_status&amp;=</span><br><span class="line">~(SERVER_STATUS_IN_TRANS | SERVER_STATUS_IN_TRANS_READONLY);</span><br><span class="line">DBUG_PRINT(<span class="string">"info"</span>, (<span class="string">"clearing SERVER_STATUS_IN_TRANS"</span>));</span><br><span class="line">res= MY_TEST(ha_commit_trans(thd, TRUE));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125; */</span></span><br><span class="line"><span class="comment">//清除OPTION_BEGIN标识/reset unsafe_rollback_flags,</span></span><br><span class="line"><span class="comment">//unsafe_rollback_flag表明该事务可能修改了不支持事务的表</span></span><br><span class="line">thd-&gt;variables.option_bits&amp;= ~OPTION_BEGIN;</span><br><span class="line">thd-&gt;get_transaction()-&gt;reset_unsafe_rollback_flags(Transaction_ctx::SESSION);</span><br><span class="line"><span class="comment">//如果res != FALSE，则说明上一个事务已经正常提交，则直接返回。</span></span><br><span class="line"><span class="comment">//这里直接返回是什么意思？也就是这个begin语句只是提交上个事务？后面再看</span></span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line">DBUG_RETURN(TRUE);</span><br><span class="line"><span class="comment">/*释放已提交事务的transactional metadata locks。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thd-&gt;mdl_context.release_transactional_locks();</span><br><span class="line"><span class="comment">/* 根据传入的flags判断开启的是RO还是RW事务 *&#123; */</span></span><br><span class="line"><span class="comment">//如果以显式的READ_ONLY开启，则设置线程thd的RO属性</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; MYSQL_START_TRANS_OPT_READ_ONLY)</span><br><span class="line">&#123;</span><br><span class="line">thd-&gt;tx_read_only= <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (tst)</span><br><span class="line">tst-&gt;set_read_flags(thd, TX_READ_ONLY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果以显式的READ_WRITE开启，则设置线程thd的RW属性</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MYSQL_START_TRANS_OPT_READ_WRITE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*Explicitly starting a RW transaction when the server is in read-only mode, is not allowed unless the user has SUPER priv.Implicitly starting a RW transaction is allowed for backward compatibility. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (check_readonly(thd, <span class="literal">true</span>))</span><br><span class="line">DBUG_RETURN(<span class="literal">true</span>);</span><br><span class="line">thd-&gt;tx_read_only= <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*This flags that tx_read_only was set explicitly, rather than just from the session's default.*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tst)</span><br><span class="line">tst-&gt;set_read_flags(thd, TX_READ_WRITE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置thd的标志位，标识事务开始</span></span><br><span class="line">thd-&gt;variables.option_bits|= OPTION_BEGIN;</span><br><span class="line">thd-&gt;server_status|= SERVER_STATUS_IN_TRANS;</span><br><span class="line"><span class="keyword">if</span> (thd-&gt;tx_read_only)</span><br><span class="line">thd-&gt;server_status|= SERVER_STATUS_IN_TRANS_READONLY;</span><br><span class="line">DBUG_PRINT(<span class="string">"info"</span>, (<span class="string">"setting SERVER_STATUS_IN_TRANS"</span>));</span><br><span class="line"><span class="keyword">if</span> (tst)</span><br><span class="line">tst-&gt;add_trx_state(thd, TX_EXPLICIT);</span><br><span class="line"><span class="comment">/* ha_start_consistent_snapshot() relies on OPTION_BEGIN flag set. */</span></span><br><span class="line"><span class="comment">/* 如果以START TRANSACTION WITH consistent snapshot 开启事务*/</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; MYSQL_START_TRANS_OPT_WITH_CONS_SNAPSHOT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tst)</span><br><span class="line">tst-&gt;add_trx_state(thd, TX_WITH_SNAPSHOT);</span><br><span class="line"><span class="comment">//下面这句代码分配ReadView？</span></span><br><span class="line">res= ha_start_consistent_snapshot(thd);</span><br><span class="line">&#125;</span><br><span class="line">DBUG_RETURN(MY_TEST(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>trans_commit_stmt(THD *thd)</strong><br>MySQL层，每条语句执行结束时，都会执行此函数，上面的 BEGIN; 语句在执行完上述 <code>trans_begin(thd,lex‑&gt;start_transaction_opt)</code>函数后，也会执行此函数。下面阅读此函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**提交单语句事务.*/</span></span><br><span class="line"><span class="comment">//@note Note that if the autocommit is on, then the following call</span></span><br><span class="line"><span class="comment">//inside InnoDB will commit or rollback the whole transaction</span></span><br><span class="line"><span class="comment">//(= the statement). The autocommit mechanism built into InnoDB</span></span><br><span class="line"><span class="comment">//is based on counting locks, but if the user has used LOCK</span></span><br><span class="line"><span class="comment">//TABLES then that mechanism does not know to do the commit.</span></span><br><span class="line"><span class="comment">//@param thd Current thread</span></span><br><span class="line"><span class="comment">//@retval FALSE Success</span></span><br><span class="line"><span class="comment">//@retval TRUE Failure</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">trans_commit_stmt</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBUG_ENTER(<span class="string">"trans_commit_stmt"</span>);</span><br><span class="line"><span class="keyword">int</span> res= FALSE;</span><br><span class="line"><span class="comment">/*We currently don't invoke commit/rollback at end of a sub-statement. In future, we perhaps should take a savepoint for each nested statement, and release the savepoint when statement has succeeded.*/</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DBUG_ASSERT(! thd-&gt;in_sub_stmt);</span><br><span class="line"><span class="comment">/*Some code in MYSQL_BIN_LOG::commit and ha_commit_low() is not safefor attachable transactions.*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DBUG_ASSERT(!thd-&gt;is_attachable_ro_transaction_active());</span><br><span class="line">thd-&gt;get_transaction()-&gt;merge_unsafe_rollback_flags();</span><br><span class="line"><span class="comment">/* 如果是单语句事务则调用下面的if提交，因为单语句事务没有显式的commit命令，所有要在最后统一提交&#123;*/</span></span><br><span class="line"><span class="keyword">if</span> (thd-&gt;get_transaction()-&gt;is_active(Transaction_ctx::STMT))</span><br><span class="line">&#123;</span><br><span class="line">res= ha_commit_trans(thd, FALSE);</span><br><span class="line"><span class="keyword">if</span> (! thd-&gt;in_active_multi_stmt_transaction())</span><br><span class="line">trans_reset_one_shot_chistics(thd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tc_log)</span><br><span class="line">tc_log-&gt;commit(thd, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (res == FALSE &amp;&amp; !thd-&gt;in_active_multi_stmt_transaction())</span><br><span class="line"><span class="keyword">if</span> (thd-&gt;rpl_thd_ctx.session_gtids_ctx().</span><br><span class="line">notify_after_transaction_commit(thd))</span><br><span class="line">sql_print_warning(<span class="string">"Failed to collect GTID to send in the response packet!"</span>);</span><br><span class="line"><span class="comment">/* In autocommit=1 mode the transaction should be marked as complete in P_S */</span></span><br><span class="line">DBUG_ASSERT(thd-&gt;in_active_multi_stmt_transaction() ||</span><br><span class="line">thd-&gt;m_transaction_psi == <span class="literal">NULL</span>);</span><br><span class="line">thd-&gt;get_transaction()-&gt;reset(Transaction_ctx::STMT);</span><br><span class="line">DBUG_RETURN(MY_TEST(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>innobase_commit()</strong><br><code>innobase_commit()</code>函数是MySQL层向innodb层提交事务的入口函数。根据传入的参数 <code>bool commit_trx</code>决定是提交该事务，还是进行语句结束标记（记录<code>trx_t‑&gt;last_sql_stat_start</code>，一个undo_no)，具体逻辑见以下代码。</p>
<p>调用本函数的情况如下：</p>
<ul>
<li>当为单语句事务状态时（<code>autocommit = true</code>），在SQL_COM switch的finish默认执行代码<code>trans_commit_stmt(THD* thd)</code>中会调用（间接调用，依次调用：<code>ha_commit_trans()‑&gt;commit()‑&gt;ha_commit_low()</code>）下面的函数。</li>
<li>当为多语句事务状态时，由 <code>case SQLCOM_COMMIT</code>; 下的<code>trans_commit(THD *thd)</code>调用<br><code>ha_commit_trans（）</code>执行下面函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span></span><br><span class="line"><span class="comment">/**Commits a transaction in an InnoDB database or marks an SQL statement ended.*/</span></span><br><span class="line"><span class="comment">//@return 0 or deadlock error if the transaction was aborted by another</span></span><br><span class="line"><span class="comment">//higher priority transaction. </span></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">innobase_commit(</span><br><span class="line"><span class="comment">/*============*/</span></span><br><span class="line">handlerton* hton, <span class="comment">/*!&lt; in: InnoDB handlerton */</span></span><br><span class="line">THD* thd, <span class="comment">/*!&lt; in: MySQL thread handle of the</span></span><br><span class="line"><span class="comment">user for whom the transaction should</span></span><br><span class="line"><span class="comment">be committed */</span></span><br><span class="line"><span class="keyword">bool</span> commit_trx) <span class="comment">/*!&lt; in: true - commit transaction</span></span><br><span class="line"><span class="comment">false - the current SQL statement</span></span><br><span class="line"><span class="comment">ended */</span></span><br><span class="line">&#123;</span><br><span class="line">DBUG_ENTER(<span class="string">"innobase_commit"</span>);</span><br><span class="line">DBUG_ASSERT(hton == innodb_hton_ptr);</span><br><span class="line">DBUG_PRINT(<span class="string">"trans"</span>, (<span class="string">"ending transaction"</span>));</span><br><span class="line"><span class="keyword">trx_t</span>* trx = check_trx_exists(thd);</span><br><span class="line"><span class="function">TrxInInnoDB <span class="title">trx_in_innodb</span><span class="params">(trx)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (trx_in_innodb.is_aborted()) &#123;</span><br><span class="line">innobase_rollback(hton, thd, commit_trx);</span><br><span class="line">DBUG_RETURN(convert_error_code_to_mysql(</span><br><span class="line">DB_FORCED_ABORT, <span class="number">0</span>, thd));</span><br><span class="line">&#125;</span><br><span class="line">ut_ad(trx-&gt;dict_operation_lock_mode == <span class="number">0</span>);</span><br><span class="line">ut_ad(trx-&gt;dict_operation == TRX_DICT_OP_NONE);</span><br><span class="line"><span class="comment">/* Transaction is deregistered only in a commit or a rollback. If it is deregistered we know there cannot be resources to be freed and we could return immediately. For the time being, we play safe and do the cleanup though there should be nothing to clean up. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!trx_is_registered_for_2pc(trx) &amp;&amp; trx_is_started(trx)) &#123;</span><br><span class="line">sql_print_error(<span class="string">"Transaction not registered for MySQL 2PC,"</span></span><br><span class="line"><span class="string">" but transaction is active"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> read_only = trx-&gt;read_only || trx-&gt;id == <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**下面这个段代码实现了单语句事务和多语句事务（BEGIN...COMMIT）之间提交的区别。大致流程如下：1）if判断是否提交（commit_trx针对多语句事务）或是否autocommit = 1如果有一个满足，则进入提交流程。2）否则，则用trx_mark_sql_stat_end(trx)标记本条语句结束。&#123;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (commit_trx</span><br><span class="line">|| (!thd_test_options(thd, OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))) &#123;</span><br><span class="line"><span class="comment">/* We were instructed to commit the whole transaction, or this is an SQL statement end and autocommit is on */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We need current binlog position for mysqlbackup to work. */</span></span><br><span class="line"><span class="keyword">if</span> (!read_only) &#123;</span><br><span class="line"><span class="keyword">while</span> (innobase_commit_concurrency &gt; <span class="number">0</span>) &#123;</span><br><span class="line">mysql_mutex_lock(&amp;commit_cond_m);</span><br><span class="line">++commit_threads;</span><br><span class="line"><span class="keyword">if</span> (commit_threads</span><br><span class="line">&lt;= innobase_commit_concurrency) &#123;</span><br><span class="line">mysql_mutex_unlock(&amp;commit_cond_m);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">--commit_threads;</span><br><span class="line">mysql_cond_wait(&amp;commit_cond, &amp;commit_cond_m);</span><br><span class="line"><span class="function">TrxInInnoDB <span class="title">trx_in_innodb</span><span class="params">(trx)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (trx_in_innodb.is_aborted()) &#123;</span><br><span class="line">innobase_rollback(hton, thd, commit_trx);</span><br><span class="line">DBUG_RETURN(convert_error_code_to_mysql(</span><br><span class="line">DB_FORCED_ABORT, <span class="number">0</span>, thd));</span><br><span class="line">&#125;</span><br><span class="line">ut_ad(trx-&gt;dict_operation_lock_mode == <span class="number">0</span>);</span><br><span class="line">ut_ad(trx-&gt;dict_operation == TRX_DICT_OP_NONE);</span><br><span class="line"><span class="comment">/* Transaction is deregistered only in a commit or a rollback. If it is deregistered we know there cannot be resources to be freed and we could return immediately. For the time being, we play safe and do the cleanup though there should be nothing to clean up. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!trx_is_registered_for_2pc(trx) &amp;&amp; trx_is_started(trx)) &#123;</span><br><span class="line">sql_print_error(<span class="string">"Transaction not registered for MySQL 2PC,"</span></span><br><span class="line"><span class="string">" but transaction is active"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> read_only = trx-&gt;read_only || trx-&gt;id == <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**下面这个段代码实现了单语句事务和多语句事务（BEGIN...COMMIT）之间提交的区别。大致流程如下：1）if判断是否提交（commit_trx针对多语句事务）或是否autocommit = 1如果有一个满足，则进入提交流程。2）否则，则用trx_mark_sql_stat_end(trx)标记本条语句结束。&#123;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (commit_trx</span><br><span class="line">|| (!thd_test_options(thd, OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))) &#123;</span><br><span class="line"><span class="comment">/* We were instructed to commit the whole transaction, or this is an SQL statement end and autocommit is on */</span></span><br><span class="line"><span class="comment">/* We need current binlog position for mysqlbackup to work. */</span></span><br><span class="line"><span class="keyword">if</span> (!read_only) &#123;</span><br><span class="line"><span class="keyword">while</span> (innobase_commit_concurrency &gt; <span class="number">0</span>) &#123;</span><br><span class="line">mysql_mutex_lock(&amp;commit_cond_m);</span><br><span class="line">++commit_threads;</span><br><span class="line"><span class="keyword">if</span> (commit_threads</span><br><span class="line">&lt;= innobase_commit_concurrency) &#123;</span><br><span class="line">mysql_mutex_unlock(&amp;commit_cond_m);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">--commit_threads;</span><br><span class="line">mysql_cond_wait(&amp;commit_cond, &amp;commit_cond_m);</span><br><span class="line"><span class="keyword">if</span> (!read_only) &#123;</span><br><span class="line">lock_unlock_table_autoinc(trx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Store the current undo_no of the transaction so that we know where to roll back if we have to roll back the next SQL statement */</span></span><br><span class="line"></span><br><span class="line">trx_mark_sql_stat_end(trx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;*/</span></span><br><span class="line"><span class="comment">/* Reset the number AUTO-INC rows required */</span></span><br><span class="line">trx-&gt;n_autoinc_rows = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* This is a statement level variable. */</span></span><br><span class="line">trx-&gt;fts_next_doc_id = <span class="number">0</span>;</span><br><span class="line">innobase_srv_conc_force_exit_innodb(trx);</span><br><span class="line">DBUG_RETURN(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SELECT-FROM-trx-WHERE-pk-1"><a href="#SELECT-FROM-trx-WHERE-pk-1" class="headerlink" title="SELECT * FROM trx WHERE pk = 1;"></a>SELECT * FROM trx WHERE pk = 1;</h4><p>本条SELECT语句的大致执行流程如下：</p>
<ol>
<li>打开表，打开表是先在Server层进行的，再调用handle层的接口打开innobase里的表；</li>
<li>外，由于是第一次开始事务，innobase会为该会话对应的thd分配一个trx_t结构体；</li>
<li>接着server层会调用handle层为要查询的表上锁；</li>
<li>接着在调用 <code>row_search_mvcc()</code> 函数时会调用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> trx_start_if_not_started_low(<span class="keyword">trx_t</span> trx,<span class="keyword">bool</span></span><br><span class="line">read_write)</span><br></pre></td></tr></table></figure>
<p> 来启动事务，该函数会做两件事：<br>‑  a.如果事务处于 <code>TRX_STATE_NOT_STARTED</code> ，则会启动该事务，<br>‑  b.如果该事务已经处于 <code>TRX_STATE_ACTIVE</code> 状态，则根据 bool <code>read_write</code> 的值设置事务的读写状态；</p>
<ol start="5">
<li>接着调用 <code>trx_assign_read_view()</code> 为trx_t分配一个ReadView，用来做MVCC；</li>
<li>最后会关闭线程打开的表</li>
</ol>
<h4 id="UPDATE-trx-set-data-data-1-where-pk-1"><a href="#UPDATE-trx-set-data-data-1-where-pk-1" class="headerlink" title="UPDATE trx set data = data +1 where pk = 1;"></a>UPDATE trx set data = data +1 where pk = 1;</h4><p>本条UPDATE语句的大致执行流程如下：</p>
<ol>
<li>首先会尝试执行单表更新函数 <code>try_single_table_update()</code> ，打开表，步骤和上面SELECT的第1步类似，不过由于上个SELECT语句已经打开了trx表，这次打开会尝试从Table_cache里面查找。</li>
<li>接着上表锁；</li>
<li>接着会调用 <code>row_search_mvcc()</code> 函数进行读操作，这时会对表加<code>LOCK_IX</code>，在 <code>lock_table()</code> 中，检测到要加LOCK_I后，会将当前read_only事务转换成read_write事务，调用的函数为 <code>trx_set_rw_mode(trx)</code>; ，下面会阅读此函数。</li>
<li>将事务提升为RW事务后开始更新聚集索引记录，此时会调用 <code>trx_undo_report_row_operation()</code> 函数来分配undo页，写入对行的更改。</li>
<li>接着进行数据行的更新；</li>
<li><p>更新完毕后，写redo，释放表锁，关闭线程关联的表。</p>
<blockquote>
<p><strong>trx_set_rw_mode(trx);</strong> </p>
</blockquote>
</li>
</ol>
<p>此函数将RO事务提升为RW事务，具体完成的工作有：</p>
<ol>
<li>分配undo段；</li>
<li>获取事务号；</li>
<li>加入全局的读写事务集合</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************/</span></span><br><span class="line"><span class="comment">/**将RO事务提升为RW事务。RO事务一般不分配事务号，除非该RO事务需要写入临时表，这时会分配事务号和回滚段，但是该事务不能加入全局的RW事务链表，因为临时表的更新对其他事务不可见！*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trx_set_rw_mode(</span><br><span class="line"><span class="comment">/*============*/</span></span><br><span class="line"><span class="keyword">trx_t</span>* trx) <span class="comment">/*!&lt; in/out: transaction that is RW */</span></span><br><span class="line">&#123;</span><br><span class="line">ut_ad(trx-&gt;rsegs.m_redo.rseg == <span class="number">0</span>);</span><br><span class="line">ut_ad(!trx-&gt;in_rw_trx_list);</span><br><span class="line">ut_ad(!trx_is_autocommit_non_locking(trx));</span><br><span class="line"><span class="keyword">if</span> (srv_force_recovery &gt;= SRV_FORCE_NO_TRX_UNDO) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Function is promoting existing trx from ro mode to rw mode.In this process it has acquired trx_sys-&gt;mutex as it plan to move trx from ro list to rw list. If in future, some other threadlooks at this trx object while it is being promoted then ensure that both threads are synced by acquring trx-&gt;mutex to avoid decision based on in-consistent view formed during promotion. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分配undo段</span></span><br><span class="line">trx-&gt;rsegs.m_redo.rseg = trx_assign_rseg_low(</span><br><span class="line">srv_rollback_segments,</span><br><span class="line">srv_undo_tablespaces,</span><br><span class="line">TRX_RSEG_TYPE_REDO);</span><br><span class="line">ut_ad(trx-&gt;rsegs.m_redo.rseg != <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*获取trx_sys-&gt;mutex锁，以取得事务号+加入读写事务集合+修改ReadView &#123;*/</span></span><br><span class="line">mutex_enter(&amp;trx_sys-&gt;mutex);</span><br><span class="line">ut_ad(trx-&gt;id == <span class="number">0</span>);</span><br><span class="line">trx-&gt;id = trx_sys_get_new_trx_id(); <span class="comment">//获取事务号</span></span><br><span class="line">trx_sys-&gt;rw_trx_ids.push_back(trx-&gt;id); <span class="comment">//将改事务加入trx_sys的读写事务集合</span></span><br><span class="line">trx_sys-&gt;rw_trx_set.insert(TrxTrack(trx-&gt;id, trx));</span><br><span class="line"><span class="comment">/* 在已拥有的ReadView中加入本事务的事务号，以能看到自己的改动 */</span></span><br><span class="line"><span class="keyword">if</span> (MVCC::is_view_active(trx-&gt;read_view)) &#123;</span><br><span class="line">MVCC::set_view_creator_trx_id(trx-&gt;read_view, trx-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNIV_DEBUG</span></span><br><span class="line"><span class="keyword">if</span> (trx-&gt;id &gt; trx_sys-&gt;rw_max_trx_id) &#123;</span><br><span class="line">trx_sys-&gt;rw_max_trx_id = trx-&gt;id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* UNIV_DEBUG */</span></span></span><br><span class="line"><span class="keyword">if</span> (!trx-&gt;read_only) &#123;</span><br><span class="line">UT_LIST_ADD_FIRST(trx_sys-&gt;rw_trx_list, trx);</span><br><span class="line">ut_d(trx-&gt;in_rw_trx_list = <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">mutex_exit(&amp;trx_sys-&gt;mutex);</span><br><span class="line"><span class="comment">/* &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>trx_undo_assign_undo()</strong></p>
</blockquote>
<p>本函数为事务分配undo log页。执行逻辑如下：</p>
<ol>
<li>如果为临时表修改的操作，则只分配undo log，不记录对应的redo，否则则记录redo；</li>
<li>接着开始分配undo log，要么重用一个，要么创建一个；</li>
<li>最后判断本次undo log对应的修改是否是对数据字典的操作。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************/</span></span><br><span class="line"><span class="comment">/**Assigns an undo log for a transaction. A new undo log is created or a cached @return DB_SUCCESS if undo log assign successful, possible error codes are: DB_TOO_MANY_CONCURRENT_TRXS DB_OUT_OF_FILE_SPACE DB_READ_ONLY DB_OUT_OF_MEMORY */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">dberr_t</span></span><br><span class="line">trx_undo_assign_undo(</span><br><span class="line"><span class="comment">/*=================*/</span></span><br><span class="line"><span class="keyword">trx_t</span>* trx, <span class="comment">/*!&lt; in: transaction */</span></span><br><span class="line"><span class="keyword">trx_undo_ptr_t</span>* undo_ptr, <span class="comment">/*!&lt; in: assign undo log from</span></span><br><span class="line"><span class="comment">referred rollback segment. */</span></span><br><span class="line">ulint type) <span class="comment">/*!&lt; in: TRX_UNDO_INSERT or</span></span><br><span class="line"><span class="comment">TRX_UNDO_UPDATE */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">trx_rseg_t</span>* rseg;</span><br><span class="line"><span class="keyword">trx_undo_t</span>* undo;</span><br><span class="line"><span class="keyword">mtr_t</span> mtr;</span><br><span class="line"><span class="keyword">dberr_t</span> err = DB_SUCCESS;</span><br><span class="line">ut_ad(trx);</span><br><span class="line"><span class="comment">/* RO事务的trx-&gt;rsegs.m_redo.rseg 可能为NULL，但可能因为需要修改临时表而申请undo.但如果该trx没有被分配回滚段，却要申请undo页，则表明出现错误，此断言判断上面的情况。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ut_ad(trx_is_rseg_assigned(trx));</span><br><span class="line">rseg = undo_ptr-&gt;rseg;</span><br><span class="line">ut_ad(mutex_own(&amp;(trx-&gt;undo_mutex)));</span><br><span class="line"><span class="comment">/*分配undo页同样需要写入redo日志，所以此处开启mtr事务 &#123;*/</span></span><br><span class="line">mtr_start(&amp;mtr);</span><br><span class="line"><span class="comment">/*如果传入的undo段为m_noredo，表明是对临时表的修改，</span></span><br><span class="line"><span class="comment">则设置mtr为MTR_LOG_NO_REDO，不写入redo log */</span></span><br><span class="line"><span class="keyword">if</span> (&amp;trx-&gt;rsegs.m_noredo == undo_ptr) &#123;</span><br><span class="line">mtr.set_log_mode(MTR_LOG_NO_REDO);;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ut_ad(&amp;trx-&gt;rsegs.m_redo == undo_ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果该事务的回滚段为临时回滚段，则表明是临时表的修改，同样设置mtr为MTR_LOG_NO_REDO，不写入redo log*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trx_sys_is_noredo_rseg_slot(rseg-&gt;id)) &#123;</span><br><span class="line">mtr.set_log_mode(MTR_LOG_NO_REDO);;</span><br><span class="line">ut_ad(undo_ptr == &amp;trx-&gt;rsegs.m_noredo);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ut_ad(undo_ptr == &amp;trx-&gt;rsegs.m_redo);</span><br><span class="line">&#125;</span><br><span class="line">mutex_enter(&amp;rseg-&gt;mutex);</span><br><span class="line"><span class="comment">/* 下面开始分配undo log &#123;*/</span></span><br><span class="line"><span class="comment">//先看是否有可重用的undo log页</span></span><br><span class="line">undo = trx_undo_reuse_cached(trx, rseg, type, trx-&gt;id, trx-&gt;xid,</span><br><span class="line">&amp;mtr);</span><br><span class="line"><span class="comment">//如果没有可重用的，则开始分配undo log页</span></span><br><span class="line"><span class="keyword">if</span> (undo == <span class="literal">NULL</span>) &#123;</span><br><span class="line">err = trx_undo_create(trx, rseg, type, trx-&gt;id, trx-&gt;xid,</span><br><span class="line">&amp;undo, &amp;mtr);</span><br><span class="line"><span class="keyword">if</span> (err != DB_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">goto</span> func_exit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type == TRX_UNDO_INSERT) &#123;</span><br><span class="line">UT_LIST_ADD_FIRST(rseg-&gt;insert_undo_list, undo);</span><br><span class="line">ut_ad(undo_ptr-&gt;insert_undo == <span class="literal">NULL</span>);</span><br><span class="line">undo_ptr-&gt;insert_undo = undo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">UT_LIST_ADD_FIRST(rseg-&gt;update_undo_list, undo);</span><br><span class="line">ut_ad(undo_ptr-&gt;update_undo == <span class="literal">NULL</span>);</span><br><span class="line">undo_ptr-&gt;update_undo = undo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果本次修改是对数据字典的修改，则要在undo log头部做标记！！！ */</span></span><br><span class="line"><span class="keyword">if</span> (trx_get_dict_operation(trx) != TRX_DICT_OP_NONE) &#123;</span><br><span class="line">trx_undo_mark_as_dict_operation(trx, undo, &amp;mtr);</span><br><span class="line">&#125;</span><br><span class="line">func_exit:</span><br><span class="line">mutex_exit(&amp;(rseg-&gt;mutex));</span><br><span class="line">mtr_commit(&amp;mtr);</span><br><span class="line"><span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="INSERT-INTO-trx-VALUES-6-1"><a href="#INSERT-INTO-trx-VALUES-6-1" class="headerlink" title="INSERT INTO trx VALUES(6,1);"></a>INSERT INTO trx VALUES(6,1);</h4><p>本条INSERT语句的大致执行流程如下：</p>
<ol>
<li>打开需要的表；</li>
<li>上表锁；</li>
<li>调用 <code>row_insert_for_mysql((byte*) record, m_prebuilt)</code> 进行实际数据的更新；</li>
<li>上面的函数会首先调用 <code>dict_sys_get_new_row_id()</code> 来获取要插入行的行号；</li>
<li>接着执行插入操作，同样调用 <code>trx_undo_report_row_operation()</code> 函数来将修改写入undo log；</li>
<li>接着进行实际的插入操作；</li>
<li>接着关闭线程锁拥有的表。<h4 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT;"></a>COMMIT;</h4>执行COMMIT会直接调用 <code>trans_commit(thd)#1</code> 函数来提交事务，使其持久化。COMMIT执行的大致流程如下：</li>
<li>调用 <code>trans_commit(thd)</code> 来设置一些状态变量;</li>
<li>接着调用 <code>ha_commit_trans()</code> ，该函数除了进行单语句/多语句事务判断和2PC事务判断外，根据传入参数（all = true）直接调用 <code>tc_log‑&gt;commit(thd, all)</code> 进行事务的提交。</li>
<li><code>tc_log‑&gt;commit(thd, all)</code> 调用<code>innnobase_commit()</code>来进行最后innodb层的提交操作。<br>另外，innobase层提交时，最重要的是设置该事务所对应undo页的状态，该操作是在<code>trx_write_serialisation_history(trx, mtr);</code> 函数完成的，同时该函数还会对insert undo log进行truncate，update undo log放入purge队列，下面看下其内容<strong>(#2)</strong>：<blockquote>
<p><strong>trans_commit(THD* thd)</strong></p>
</blockquote>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**注意：此函数在handle层.提交线程所关联的事务，使其持久化。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//@param thd Current thread</span></span><br><span class="line"><span class="comment">//@retval FALSE Success</span></span><br><span class="line"><span class="comment">//@retval TRUE Failure</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">trans_commit</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">if</span> (trans_check_state(thd))</span><br><span class="line">DBUG_RETURN(TRUE);</span><br><span class="line"><span class="comment">//首先清除thd的服务器状态变量</span></span><br><span class="line">thd-&gt;server_status&amp;=</span><br><span class="line">~(SERVER_STATUS_IN_TRANS | SERVER_STATUS_IN_TRANS_READONLY);</span><br><span class="line"><span class="comment">/* 调用ha_commit_trans()来提交该事务 */</span></span><br><span class="line">res= ha_commit_trans(thd, TRUE);</span><br><span class="line"><span class="keyword">if</span> (res == FALSE)</span><br><span class="line"><span class="keyword">if</span> (thd-&gt;rpl_thd_ctx.session_gtids_ctx().</span><br><span class="line">notify_after_transaction_commit(thd))</span><br><span class="line">sql_print_warning(<span class="string">"Failed to collect GTID to send in the response packet!"</span>);</span><br><span class="line"><span class="comment">/*When gtid mode is enabled, a transaction may cause binlog rotation, which inserts a record into the gtid system table (which is probably a transactional table). Thence, the flag SERVER_STATUS_IN_TRANS may be set again while calling ha_commit_trans(...) Consequently, we need to reset it back,much like we are doing before calling ha_commit_trans(...).We would really only need to do this when gtid_mode=on. However,checking gtid_mode requires holding a lock, which is costly. So we clear the bit unconditionally. This has no side effects since if gtid_mode=off the bit is already cleared.*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清除SERVER_STATUS_IN_TRANS和OPTION_BEGIN标识 */</span></span><br><span class="line"></span><br><span class="line">thd-&gt;server_status&amp;= ~SERVER_STATUS_IN_TRANS;</span><br><span class="line">thd-&gt;variables.option_bits&amp;= ~OPTION_BEGIN;</span><br><span class="line">thd-&gt;get_transaction()-&gt;reset_unsafe_rollback_flags(Transaction_ctx::SESSION);</span><br><span class="line">thd-&gt;lex-&gt;start_transaction_opt= <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* The transaction should be marked as complete in P_S. */</span></span><br><span class="line">DBUG_ASSERT(thd-&gt;m_transaction_psi == <span class="literal">NULL</span>);</span><br><span class="line">thd-&gt;tx_priority= <span class="number">0</span>;</span><br><span class="line">trans_track_end_trx(thd);</span><br><span class="line">DBUG_RETURN(MY_TEST(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> #2</p>
<blockquote>
<p><strong>trx_write_serialisation_history(trx, mtr);</strong></p>
</blockquote>
<p>//需要再看下此函数完成以下功能：</p>
<ol>
<li>如果事务有UPDATE操作，则获取事务的序列号（trx_no 而不是trx_id）；</li>
<li>如果仅有INSERT操作，则不会获取序列号；</li>
<li><code>trx_serialisation_number_get()</code> [row 71]函数实际进行序列号的生成，通过调用<code>trx_sys_get_new_trx_id()</code> 来获得；除了获取序列号，此函数还会将事务的update undo页加入到<code>purge_sys‑&gt;purge_queue</code>队列中供purge线程清理。</li>
<li>最后设置回滚段的状态（<code>TRX_UNDO_CACHED、TRX_UNDO_TO_FREE、TRX_UNDO_TO_PURGE</code>）</li>
</ol>
<blockquote>
<p>注意：是先放入purge队列再设置回滚段的状态！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************/</span></span><br><span class="line"><span class="comment">/**Assign the transaction its history serialisation number and write the update UNDO log record to the assigned rollback segment.@return true if a serialisation log was written */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">trx_write_serialisation_history(</span><br><span class="line"><span class="comment">/*============================*/</span></span><br><span class="line"><span class="keyword">trx_t</span>* trx, <span class="comment">/*!&lt; in/out: transaction */</span></span><br><span class="line"><span class="keyword">mtr_t</span>* mtr) <span class="comment">/*!&lt; in/out: mini-transaction */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*将trx对应的undo log segment从TRX_UNDO_ACTIVE修改为其他状态。将上述这些修改写入文件后，标识着事务最终在文件层提交和持久化，其提交的逻辑时间就是下面获得的lsn号。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 因为修改后的undo log headers需要按UNDO trx number来有序放入history list 以便purge，所以下面需要获取rseg mutex。 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> own_redo_rseg_mutex = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> own_noredo_rseg_mutex = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* Get rollback segment mutex. */</span></span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_redo.rseg != <span class="literal">NULL</span> &amp;&amp; trx_is_redo_rseg_updated(trx)) &#123;</span><br><span class="line">mutex_enter(&amp;trx-&gt;rsegs.m_redo.rseg-&gt;mutex);</span><br><span class="line">own_redo_rseg_mutex = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mtr_t</span> temp_mtr;</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_noredo.rseg != <span class="literal">NULL</span></span><br><span class="line">&amp;&amp; trx_is_noredo_rseg_updated(trx)) &#123;</span><br><span class="line">mutex_enter(&amp;trx-&gt;rsegs.m_noredo.rseg-&gt;mutex);</span><br><span class="line">own_noredo_rseg_mutex = <span class="literal">true</span>;</span><br><span class="line">mtr_start(&amp;temp_mtr);</span><br><span class="line">temp_mtr.set_log_mode(MTR_LOG_NO_REDO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* If transaction involves insert then truncate undo logs. */</span></span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_redo.insert_undo != <span class="literal">NULL</span>) &#123;</span><br><span class="line">trx_undo_set_state_at_finish(</span><br><span class="line">trx-&gt;rsegs.m_redo.insert_undo, mtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_noredo.insert_undo != <span class="literal">NULL</span>) &#123;</span><br><span class="line">trx_undo_set_state_at_finish(</span><br><span class="line">trx-&gt;rsegs.m_noredo.insert_undo, &amp;temp_mtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> serialised = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/* If transaction involves update then add rollback segments to purge queue. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_redo.update_undo != <span class="literal">NULL</span></span><br><span class="line">|| trx-&gt;rsegs.m_noredo.update_undo != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/* Assign the transaction serialisation number and add these rollback segments to purge trx-no sorted priority queue if this is the first UNDO log being written to assigned rollback segments. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">trx_undo_ptr_t</span>* redo_rseg_undo_ptr =</span><br><span class="line">trx-&gt;rsegs.m_redo.update_undo != <span class="literal">NULL</span></span><br><span class="line">? &amp;trx-&gt;rsegs.m_redo : <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">trx_undo_ptr_t</span>* noredo_rseg_undo_ptr =</span><br><span class="line">trx-&gt;rsegs.m_noredo.update_undo != <span class="literal">NULL</span></span><br><span class="line">? &amp;trx-&gt;rsegs.m_noredo : <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* Will set trx-&gt;no and will add rseg to purge queue. */</span></span><br><span class="line"></span><br><span class="line">serialised = trx_serialisation_number_get(</span><br><span class="line">trx, redo_rseg_undo_ptr, noredo_rseg_undo_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* It is not necessary to obtain trx-&gt;undo_mutex here because only a single OS thread is allowed to do the transaction commit for this transaction. */</span></span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_redo.update_undo != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">page_t</span>* undo_hdr_page;</span><br><span class="line">undo_hdr_page = trx_undo_set_state_at_finish(</span><br><span class="line">trx-&gt;rsegs.m_redo.update_undo, mtr);</span><br><span class="line"><span class="comment">/* Delay update of rseg_history_len if we plan to add non-redo update_undo too. This is to avoid immediate invocation of purge as we need to club these 2 segments with same trx-no as single unit. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> update_rseg_len =</span><br><span class="line">!(trx-&gt;rsegs.m_noredo.update_undo != <span class="literal">NULL</span>);</span><br><span class="line">trx_undo_update_cleanup(</span><br><span class="line">trx, &amp;trx-&gt;rsegs.m_redo, undo_hdr_page,</span><br><span class="line">update_rseg_len, (update_rseg_len ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">mtr);</span><br><span class="line">&#125;</span><br><span class="line">DBUG_EXECUTE_IF(<span class="string">"ib_trx_crash_during_commit"</span>, DBUG_SUICIDE(););</span><br><span class="line"><span class="keyword">if</span> (trx-&gt;rsegs.m_noredo.update_undo != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">page_t</span>* undo_hdr_page;</span><br><span class="line">undo_hdr_page = trx_undo_set_state_at_finish(</span><br><span class="line">trx-&gt;rsegs.m_noredo.update_undo, &amp;temp_mtr);</span><br><span class="line">ulint n_added_logs =</span><br><span class="line">(redo_rseg_undo_ptr != <span class="literal">NULL</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">trx_undo_update_cleanup(</span><br><span class="line">trx, &amp;trx-&gt;rsegs.m_noredo, undo_hdr_page,</span><br><span class="line"><span class="literal">true</span>, n_added_logs, &amp;temp_mtr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (own_redo_rseg_mutex) &#123;</span><br><span class="line">mutex_exit(&amp;trx-&gt;rsegs.m_redo.rseg-&gt;mutex);</span><br><span class="line">own_redo_rseg_mutex = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (own_noredo_rseg_mutex) &#123;</span><br><span class="line">mutex_exit(&amp;trx-&gt;rsegs.m_noredo.rseg-&gt;mutex);</span><br><span class="line">own_noredo_rseg_mutex = <span class="literal">false</span>;</span><br><span class="line">mtr_commit(&amp;temp_mtr);</span><br><span class="line">&#125;</span><br><span class="line">MONITOR_INC(MONITOR_TRX_COMMIT_UNDO);</span><br><span class="line"><span class="comment">/* Update the latest MySQL binlog name and offset info in trx sys header if MySQL binlogging is on or the database server is a MySQL replication slave */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trx-&gt;mysql_log_file_name != <span class="literal">NULL</span></span><br><span class="line">&amp;&amp; trx-&gt;mysql_log_file_name[<span class="number">0</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">trx_sys_update_mysql_binlog_offset(</span><br><span class="line">trx-&gt;mysql_log_file_name,</span><br><span class="line">trx-&gt;mysql_log_offset,</span><br><span class="line">TRX_SYS_MYSQL_LOG_INFO, mtr);</span><br><span class="line">trx-&gt;mysql_log_file_name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(serialised);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReadView-MVCC-again"><a href="#ReadView-MVCC-again" class="headerlink" title="ReadView(MVCC) again"></a>ReadView(MVCC) again</h3><p>ReadView是InnoDB用来实现一致性读和多版本并发控制的方式。一个ReadView相当于一个快照，当事务开启且执行第一条SELECT的语句时（同时insert、update和delete语句不会触发ReadView的创建，或者执行：<code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code>在一开始就分配一个ReadView），系统会将当前活动的事务（事务号）拍摄下来，形成一个ReadView，该ReadView里的事务对数据的更改对拥有此ReadView的事务来说均是不可见的。另外，purge线程也会持有一个全局的ReadView 用来purge无用的undo页。</p>
<p>实现上，innobase里除了有ReadView类之外还有MVCC类，MVCC类里包装了操作ReadView的方法，是一个针对ReadView的工具类。下面分别看一下这两个类，之后看一下为一个事务创建ReadView的具体过程和purge线程根据ReadView清理undo的过程。</p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>ReadView简单来说是一个读写事务号的集合，该集合中的事务对数据的修改对于ReadView的持有者来说不可见，进而实现事务的隔离性（Isolation）。</p>
<ol>
<li>ReadView有一个ids_t类型的成员变量m_ids，该变量是拍摄</li>
<li>此ReadView时系统活动读写事务号的集合；</li>
<li>事务号大于<code>m_low_limit_id</code>的事务，其对数据的修改对本ReadView来说一定不可见；</li>
<li>事务号小于<code>m_up_limit_id</code>的事务，其修改对本ReadView一定可见；</li>
<li>当事务号小于<code>m_low_limit_id</code>大于<code>m_up_limit_id</code>时，则搜索m_ids，如果找到该事务号，则说明拍摄此ReadView时其为活动状态，其修改对本ReadView不可见，否则说明其已经提交，对本ReadView可见。</li>
</ol>
<p><strong>创建ReadView的时机</strong><br>在不同隔离级别下ReadView的创建时机不同，当处于RC隔离级别时，事务的每次读请求都会创建一个ReadView。当处于RR级别时事务会在第一个读请求时创建ReadView，为了RR的一致性读，此ReadView会一直存在且不会改变。另外值得一提的是，RR隔离级别下MDL语句不会触发ReadView的创建。举个例子，当事务A开启（BEGIN）后，事务B开启，对pk=1的记录做了修改后提交，这时如果A进行SELECT 会读到B修改后的值。但是，如果A在开启后立刻执行一个SELECT语句，那么B的修改对A是不可见的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadView</span> &#123;</span></span><br><span class="line"><span class="comment">/** 下面的ids_t类似于std中的vector，用以存放事务号. */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ids_t</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">trx_ids_t</span>::value_type value_type; <span class="comment">//value_type为trx_id_t</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// Prevent copying</span></span><br><span class="line"><span class="keyword">ids_t</span>(<span class="keyword">const</span> <span class="keyword">ids_t</span>&amp;);</span><br><span class="line"><span class="keyword">ids_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">ids_t</span>&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/** Memory for the array */</span></span><br><span class="line">value_type* m_ptr;</span><br><span class="line"><span class="comment">/** Number of active elements in the array */</span></span><br><span class="line">ulint m_size;</span><br><span class="line"><span class="comment">/** Size of m_ptr in elements */</span></span><br><span class="line">ulint m_reserved;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadView</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ReadView();</span><br><span class="line">~ReadView();</span><br><span class="line"><span class="comment">/** 检查传入trx id是否大于系统当前最大事务号</span></span><br><span class="line"><span class="comment">@param[in] id transaction id to check</span></span><br><span class="line"><span class="comment">@param[in] name table name */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_trx_id_sanity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">trx_id_t</span> id,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">table_name_t</span>&amp; name)</span></span>;</span><br><span class="line"><span class="comment">/************注意重点看下此函数*****************/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">change_visible</span> <span class="params">(<span class="keyword">trx_id_t</span> id, <span class="keyword">const</span> <span class="keyword">table_name_t</span>&amp; name)</span></span></span><br><span class="line"><span class="function"><span class="comment">//检查传入id的事务所做的修改对该ReadView可见！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ut_ad(id &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">//先检查是否是小于m_up_limit_id或是创建此ReadView的id，如果是则返回true。</span></span><br><span class="line"><span class="keyword">if</span> (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">check_trx_id_sanity(id, name);</span><br><span class="line"><span class="comment">//检查是否大于m_low_limit_id，大于则直接返回false，不可见，如果小于则查看</span></span><br><span class="line"><span class="comment">//m_ids活动列表是否为空，如果为空说明此事务虽然在系统可见最小事务号之后发生</span></span><br><span class="line"><span class="comment">//但在此事务开始前已经不是活动的了，此时也是可以看见的。</span></span><br><span class="line"><span class="keyword">if</span> (id &gt;= m_low_limit_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_ids.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">ids_t</span>::value_type* p = m_ids.data();</span><br><span class="line"><span class="comment">//最后如果m_ids活动事务列表不为空，则二分查找m_ids，如果找到，说明拍摄此ReadView</span></span><br><span class="line"><span class="comment">//时此id是活动的，直接对找到结果的取反。</span></span><br><span class="line"><span class="keyword">return</span>(!<span class="built_in">std</span>::binary_search(p, p + m_ids.size(), id));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**@param id transaction to check*/</span></span><br><span class="line"><span class="comment">//@return true if view sees transaction id </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sees</span><span class="params">(<span class="keyword">trx_id_t</span> id)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>(id &lt; m_up_limit_id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**将此ReadView的创建者id设为系统最大事务号，用来标记ReadView为closed状态 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ut_ad(m_creator_trx_id != TRX_ID_MAX);</span><br><span class="line">m_creator_trx_id = TRX_ID_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**@return true if the view is closed */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_closed</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>(m_closed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**Write the limits to the file.*/</span></span><br><span class="line"><span class="comment">//@param file file to write to </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_limits</span><span class="params">(FILE* file)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(file,</span><br><span class="line"><span class="string">"Trx read view will not see trx with"</span></span><br><span class="line"><span class="string">" id &gt;= "</span> TRX_ID_FMT <span class="string">", sees &lt; "</span> TRX_ID_FMT <span class="string">"\n"</span>,</span><br><span class="line">m_low_limit_id, m_up_limit_id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNIV_DEBUG</span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment">//@param rhs view to compare with</span></span><br><span class="line"><span class="comment">//@return true if this view is less than or equal rhs */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">le</span><span class="params">(<span class="keyword">const</span> ReadView* rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>(m_low_limit_no &lt;= rhs-&gt;m_low_limit_no);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* UNIV_DEBUG */</span></span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/**Copy the transaction ids from the source vector */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">copy_trx_ids</span><span class="params">(<span class="keyword">const</span> <span class="keyword">trx_ids_t</span>&amp; trx_ids)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**打开一个ReadView在此之前被序列化的事务都对本ReadView可见*/</span></span><br><span class="line"><span class="comment">//@param id Creator transaction id */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">trx_id_t</span> id)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Complete the read view creation */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**Copy state from another view. Must call copy_complete() to finish.*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@param other view to copy from */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">copy_prepare</span><span class="params">(<span class="keyword">const</span> ReadView&amp; other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**Complete the copy, insert the creator transaction id into the m_trx_ids too and adjust the m_up_limit_id *, if required */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">copy_complete</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**Set the creator transaction id, existing id must be 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creator_trx_id</span><span class="params">(<span class="keyword">trx_id_t</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ut_ad(m_creator_trx_id == <span class="number">0</span>);</span><br><span class="line">m_creator_trx_id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MVCC</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/** The read should not see any transaction with trx id &gt;= this value. In other words, this is the "high water mark". */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trx_id_t</span> m_low_limit_id;</span><br><span class="line"><span class="comment">/** The read should see all trx ids which are strictly</span></span><br><span class="line"><span class="comment">smaller (&lt;) than this value. In other words, this is the</span></span><br><span class="line"><span class="comment">low water mark". */</span></span><br><span class="line"><span class="keyword">trx_id_t</span> m_up_limit_id;</span><br><span class="line"><span class="comment">/** trx id of creating transaction, set to TRX_ID_MAX for free views. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trx_id_t</span> m_creator_trx_id;</span><br><span class="line"><span class="comment">/** Set of RW transactions that was active when this snapshot was taken */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ids_t</span> m_ids;</span><br><span class="line"><span class="comment">/** The view does not need to see the undo logs for transactionswhose transaction number is strictly smaller (&lt;) than this value:they can be removed in purge if not needed by other views */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">trx_id_t</span> m_low_limit_no;</span><br><span class="line"><span class="comment">/** AC-NL-RO transaction view that has been "closed". */</span></span><br><span class="line"><span class="keyword">bool</span> m_closed;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">UT_LIST_NODE_T</span><span class="params">(ReadView)</span> node_t</span>;</span><br><span class="line"><span class="comment">/** List of read views in trx_sys */</span></span><br><span class="line">byte pad1[<span class="number">64</span> - <span class="keyword">sizeof</span>(<span class="keyword">node_t</span>)];</span><br><span class="line"><span class="keyword">node_t</span> m_view_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Consistent Read</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ToDo list：</span><br><span class="line">row/page/space format</span><br><span class="line">row_search_mvc();</span><br><span class="line">struct row_prebuilt_t;</span><br></pre></td></tr></table></figure>
<h3 id="XA-2PC-and-binlog-in-MySQL"><a href="#XA-2PC-and-binlog-in-MySQL" class="headerlink" title="XA (2PC)and binlog in MySQL"></a>XA (2PC)and binlog in MySQL</h3><p>MySQL中的XA实现分为：外部XA和内部XA；前者是指我们通常意义上的分布式事务实现；后者是指单台MySQL服务器中，Server层作为TM(事务协调者)，而服务器中的多个数据库实例作为RM，而进行的一种分布式事务，也就是MySQL跨库事务；也就是一个事务涉及到同一条MySQL服务器中的两个innodb数据库(因为其它引擎不支持XA)。</p>
<h3 id="MySQL-内部XA事务与binlog"><a href="#MySQL-内部XA事务与binlog" class="headerlink" title="MySQL 内部XA事务与binlog"></a>MySQL 内部XA事务与binlog</h3><p>以下内容摘自：<a href="https://www.2cto.com/database/201511/448803.html" target="_blank" rel="noopener">MySQL binlog 组提交与 XA(两阶段提交)</a><br>XA 将事务的提交分为两个阶段，而这种实现，解决了 binlog 和 redo log的一致性问题，这就是MySQL内部XA的第三种功能。</p>
<p>MySQL为了兼容其它非事物引擎的复制，在server层面引入了 binlog, 它可以记录所有引擎中的修改操作，因而可以对所有的引擎使用复制功能；MySQL在4.x 的时候放弃redo的复制策略而引入binlog的复制(淘宝丁奇)。</p>
<p>但是引入了binlog，会导致一个问题――binlog和redo log的一致性问题：一个事务的提交必须写redo log和binlog，那么二者如何协调一致呢？事务的提交以哪一个log为标准？如何判断事务提交？事务崩溃恢复如何进行？</p>
<p>MySQL通过两阶段提交(内部XA的两阶段提交)很好地解决了这一问题：</p>
<p>第一阶段：InnoDB prepare，持有<code>prepare_commit_mutex</code>，并且<code>write/sync redo log</code>； 将回滚段设置为Prepared状态，binlog不作任何操作；</p>
<p>第二阶段：包含两步，1&gt; <code>write/sync Binlog；</code> 2&gt; InnoDB commit (写入COMMIT标记后释放<code>prepare_commit_mutex)；</code></p>
<p>以 binlog 的写入与否作为事务提交成功与否的标志，innodb commit标志并不是事务成功与否的标志。因为此时的事务崩溃恢复过程如下：</p>
<ol>
<li>崩溃恢复时，扫描最后一个Binlog文件，提取其中的xid；</li>
<li>InnoDB维持了状态为Prepare的事务链表，将这些事务的xid和Binlog中记录的xid做比较，如果在Binlog中存在，则提交，否则回滚事务。</li>
</ol>
<p>通过这种方式，可以让InnoDB和Binlog中的事务状态保持一致。如果在写入innodb commit标志时崩溃，则恢复时，会重新对commit标志进行写入；</p>
<p>在prepare阶段崩溃，则会回滚，在write/sync binlog阶段崩溃，也会回滚。这种事务提交的实现是MySQL5.6之前的实现。</p>
<h3 id="事务中的UNDO部分"><a href="#事务中的UNDO部分" class="headerlink" title="事务中的UNDO部分"></a>事务中的UNDO部分</h3><p>Innobase中undo不仅用于MVCC和回滚，它还承担着崩溃恢复和标记事务状态的工作。下面分两个方面开始阅读undo部分的代码：</p>
<ol>
<li>关注事务进行中对undo操作的内容，比如说如何基于undo做savepoint，如何进行多版本读，事务提交时如何修改所关联undo段的状态；</li>
<li>purge线程的工作原理，因为在最后的项目中redo日志应用到从机时purge线程的工作方式必须要做出相应改变，所以需要先清楚purge线程现在的工作方式。</li>
</ol>
<h4 id="如何基于undo记录savepoint"><a href="#如何基于undo记录savepoint" class="headerlink" title="如何基于undo记录savepoint"></a>如何基于undo记录savepoint</h4><p>先看一下<code>trx_t::undo_no</code>成员<br>从注释可以看到，undo_no是一个递增的序列号，标识该事务修改/插入行的数量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------------*/</span></span><br><span class="line">UT_LIST_BASE_NODE_T(<span class="keyword">trx_named_savept_t</span>)</span><br><span class="line">trx_savepoints; <span class="comment">/*!&lt; savepoints set with SAVEPOINT ...,oldest first */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------*/</span></span><br><span class="line">UndoMutex undo_mutex; <span class="comment">// mutex保护下部分变量，last_sql_stat_start除外</span></span><br><span class="line"><span class="keyword">undo_no_t</span> undo_no; <span class="comment">/*!&lt; next undo log record number to assign; since the undo log is private for a transaction, this is a simple ascending sequence with no gaps; thus it represents the number of modified/inserted rows in a transaction */</span></span><br><span class="line"></span><br><span class="line">ulint undo_rseg_space;</span><br><span class="line"><span class="comment">/*!&lt; 最后一个undo log所在的space_id */</span></span><br><span class="line"><span class="keyword">trx_savept_t</span> last_sql_stat_start;</span><br><span class="line"><span class="comment">/*!&lt; 上一条语句开始时的undo_no值，如果发生错误，则回滚到此处 */</span></span><br><span class="line"><span class="keyword">trx_rsegs_t</span> rsegs; <span class="comment">/* 事务的回滚段 */</span></span><br><span class="line"><span class="keyword">undo_no_t</span> roll_limit; <span class="comment">/*!&lt; least undo number to undo during a partial rollback; 0 otherwise */</span></span><br></pre></td></tr></table></figure>
<h4 id="trx-in-handler-layer"><a href="#trx-in-handler-layer" class="headerlink" title="trx in handler layer"></a>trx in handler layer</h4><p><strong>Ha_trx_info类</strong><br>该类属于是MySQL层的，其注释上写的该类是用来记录事务所对应线程相关的存储引擎的信息。上面<code>trans_commit_stmt(</code>)函数的第36行，就是根据 thd 的 <code>Transaction_ctx</code> 类型的成员 <code>m_transaction‑&gt;m_scope_info[]‑&gt;m_ha_list</code> 是否为null来判断该事务是否活动。如果为null则表明该事务/语句没有关联任何存储引擎的 <code>Ha_trx_info</code> ，则不是活动状态。</p>
<p>下面看一下 <code>Ha_trx_info</code> 类的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Either statement transaction or normal transaction - related thread-specific storage engine data.If a storage engine participates in a statement/transaction,an instance of this class is present in thd-&gt;m_transaction.m_scope_info[STMT|SESSION].ha_list. The addition this list is made by trans_register_ha().When it's time to commit or rollback, each element of ha_list is used to access storage engine's prepare()/commit()/rollback() methods, and also to evaluate if a full two phase commit is necessary.@sa General description of transaction handling in handler.cc.*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ha_trx_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/**Register this storage engine in the given transaction context.*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_ha</span><span class="params">(Ha_trx_info *ha_info, handlerton *ht_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBUG_ENTER(<span class="string">"Ha_trx_info::register_ha"</span>);</span><br><span class="line">DBUG_PRINT(<span class="string">"enter"</span>, (<span class="string">"ht: 0x%llx (%s)"</span>,</span><br><span class="line">(ulonglong) ht_arg,</span><br><span class="line">ha_legacy_type_name(ht_arg-&gt;db_type)));</span><br><span class="line">DBUG_ASSERT(m_flags == <span class="number">0</span>);</span><br><span class="line">DBUG_ASSERT(m_ht == <span class="literal">NULL</span>);</span><br><span class="line">DBUG_ASSERT(m_next == <span class="literal">NULL</span>);</span><br><span class="line">m_ht= ht_arg;</span><br><span class="line">m_flags= (<span class="keyword">int</span>) TRX_READ_ONLY; <span class="comment">/* Assume read-only at start. */</span></span><br><span class="line">m_next= ha_info;</span><br><span class="line">DBUG_VOID_RETURN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**Clear, prepare for reuse.*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBUG_ENTER(<span class="string">"Ha_trx_info::reset"</span>);</span><br><span class="line">m_next= <span class="literal">NULL</span>;</span><br><span class="line">m_ht= <span class="literal">NULL</span>;</span><br><span class="line">m_flags= <span class="number">0</span>;</span><br><span class="line">DBUG_VOID_RETURN;</span><br><span class="line">&#125;</span><br><span class="line">Ha_trx_info()</span><br><span class="line">&#123;</span><br><span class="line">reset();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_trx_read_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBUG_ASSERT(is_started());</span><br><span class="line">m_flags|= (<span class="keyword">int</span>) TRX_READ_WRITE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_trx_read_write</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBUG_ASSERT(is_started());</span><br><span class="line"><span class="keyword">return</span> m_flags &amp; (<span class="keyword">int</span>) TRX_READ_WRITE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_started</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_ht != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**Mark this transaction read-write if the argument is read-write.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coalesce_trx_with</span><span class="params">(<span class="keyword">const</span> Ha_trx_info *stmt_trx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*Must be called only after the transaction has been started. Can be called many times, e.g. when we have many read-write statements in a transaction.*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DBUG_ASSERT(is_started());</span><br><span class="line"><span class="keyword">if</span> (stmt_trx-&gt;is_trx_read_write())</span><br><span class="line">set_trx_read_write();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Ha_trx_info *<span class="title">next</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBUG_ASSERT(is_started());</span><br><span class="line"><span class="keyword">return</span> m_next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">handlerton *<span class="title">ht</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DBUG_ASSERT(is_started());</span><br><span class="line"><span class="keyword">return</span> m_ht;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123; TRX_READ_ONLY= <span class="number">0</span>, TRX_READ_WRITE= <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">/**Auxiliary, used for ha_list management*/</span></span><br><span class="line">Ha_trx_info *m_next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**Although a given Ha_trx_info instance is currently always used for the same storage engine, 'ht' is not-NULL only when the corresponding storage is a part of a transaction.*/</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">handlerton *m_ht;</span><br><span class="line"><span class="comment">/**Transaction flags related to this engine.Not-null only if this instance is a part of transaction.May assume a combination of enum values above.*/</span></span><br><span class="line">uchar m_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="部分常量释义"><a href="#部分常量释义" class="headerlink" title="部分常量释义"></a>部分常量释义</h4><p><strong>OPTION_NOT_AUTOCOMMIT</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//When autocommit is off, a multi-statement transaction is implicitly started on the first</span></span><br><span class="line"><span class="comment">//statement after a previous transaction has been ended.</span></span><br></pre></td></tr></table></figure>
<p><strong>OPTION_BEGIN</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Regardless of the autocommit status, a multi-statement transaction can be explicitly startedwith the statements <span class="string">"START TRANSACTION"</span>, <span class="string">"BEGIN [WORK]"</span>, <span class="string">"[COMMIT | ROLLBACK] AND CHAIN"</span>,</span><br><span class="line">etc.</span><br></pre></td></tr></table></figure>
<h3 id="Redo-log及其缓冲区代码阅读记录"><a href="#Redo-log及其缓冲区代码阅读记录" class="headerlink" title="Redo log及其缓冲区代码阅读记录"></a>Redo log及其缓冲区代码阅读记录</h3><h4 id="Redo-log-buffer阅读"><a href="#Redo-log-buffer阅读" class="headerlink" title="Redo log buffer阅读"></a>Redo log buffer阅读</h4><p>Redo log buffer对应的句柄为 <code>log_t</code> 结构体类型的变量， <code>log_t</code> 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Redo log buffer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log_t</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> pad1[CACHE_LINE_SIZE];</span><br><span class="line"><span class="comment">/*!&lt; 防止出现“伪共享”问题，进行Cache line填充*/</span></span><br><span class="line"><span class="keyword">lsn_t</span> lsn; <span class="comment">/*!&lt; log sequence number */</span></span><br><span class="line">ulint buf_free; <span class="comment">/*!&lt; first free offset within the log</span></span><br><span class="line"><span class="comment">buffer in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNIV_HOTBACKUP</span></span><br><span class="line"><span class="keyword">char</span> pad2[CACHE_LINE_SIZE];<span class="comment">/*!&lt; 进行Cache line填充*/</span></span><br><span class="line">LogSysMutex mutex; <span class="comment">/*!&lt; mutex protecting the log */</span></span><br><span class="line">LogSysMutex write_mutex; <span class="comment">/*!&lt; 写日志文件锁+访问log_group_t成员锁 */</span></span><br><span class="line"><span class="keyword">char</span> pad3[CACHE_LINE_SIZE];<span class="comment">/*!&lt; 进行Cache line填充 */</span></span><br><span class="line">FlushOrderMutex log_flush_order_mutex;<span class="comment">/*!&lt; 添加脏block时顺序访问flush list，增加此变量可以使得mtr_commit时释放log_sys-&gt;mutex，并且保证flush list的插入按lsn顺序！ */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !UNIV_HOTBACKUP */</span></span></span><br><span class="line">byte* buf_ptr; <span class="comment">/*!&lt; 总的redo buf的首地址 */</span></span><br><span class="line">byte* buf; <span class="comment">/*!&lt; 当前使用的redo buf首地址，可能是buf_ptr的前一段或后一段 */</span></span><br><span class="line"><span class="keyword">bool</span> first_in_use; <span class="comment">/*!&lt; true ：第一段在用, false：第二段在用 */</span></span><br><span class="line">ulint buf_size; <span class="comment">/*!&lt; 两段buf的大小 */</span></span><br><span class="line">ulint max_buf_free; <span class="comment">/*!&lt; 推荐redo buf free空间的最小值，当小于此值时需要刷redo到磁盘默认值为：1/2 buf_size*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> check_flush_or_checkpoint;</span><br><span class="line"><span class="comment">/*!&lt; this is set when there may be need to flush the log buffer, or preflush buffer pool pages, or make a checkpoint; this MUST be TRUE when lsn - last_checkpoint_lsn &gt; max_checkpoint_age; this flag is peeked at by log_free_check(), which does not reserve the log mutex */</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">UT_LIST_BASE_NODE_T(<span class="keyword">log_group_t</span>)</span><br><span class="line">log_groups; <span class="comment">/*!&lt; redo 日志文件组链表 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNIV_HOTBACKUP</span></span><br><span class="line"><span class="comment">/** The fields involved in the log buffer flush @&#123; */</span></span><br><span class="line">ulint buf_next_to_write;<span class="comment">/*!&lt; 下一个要写盘的redo buf的位置 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> is_extending; <span class="comment">/*!&lt; true:当前redo buf正在扩展 */</span></span><br><span class="line"><span class="keyword">lsn_t</span> write_lsn; <span class="comment">/*!&lt; 已经写入文件系统的lsn（可能没有flush到磁盘） */</span></span><br><span class="line"><span class="keyword">lsn_t</span> current_flush_lsn;<span class="comment">/*!&lt; 当前正在flush的lsn，可能还没写入盘！该值的目的是：设A是当前正在flush的线程，当另外一个flush请求(B)到的时候，会检查B要写入lsn是否小于此值，小于的话直接等待A返回就可以了，不用再发起flush。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">lsn_t</span> flushed_to_disk_lsn;</span><br><span class="line"><span class="comment">/*!&lt; 已经刷盘的lsn */</span></span><br><span class="line">ulint n_pending_flushes;<span class="comment">/*!&lt; 正在flush的数量， 受log mutex保护*/</span></span><br><span class="line"><span class="keyword">os_event_t</span> flush_event; <span class="comment">/*!&lt; this event is in the reset state when a flush is running; a thread should wait for this without owning the log mutex, but NOTE that to set this event, the thread MUST own the log mutex! */</span></span><br><span class="line"></span><br><span class="line">ulint n_log_ios; <span class="comment">/*!&lt; number of log i/os initiated thus far */</span></span><br><span class="line"></span><br><span class="line">ulint n_log_ios_old; <span class="comment">/*!&lt; number of log i/o's at the previous printout */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">time_t</span> last_printout_time;<span class="comment">/*!&lt; when log_print was last time called */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @&#125; */</span></span><br><span class="line"><span class="comment">/** Fields involved in checkpoints @&#123; */</span></span><br><span class="line"><span class="keyword">lsn_t</span> log_group_capacity; <span class="comment">/*!&lt; capacity of the log group; if the checkpoint age exceeds this, it is a serious error because it is possible we will then overwrite log and spoil crash recovery */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">lsn_t</span> max_modified_age_async;</span><br><span class="line"><span class="comment">/*!&lt; when this recommended value for lsn - buf_pool_get_oldest_modification() is exceeded, we start an asynchronous preflush of pool pages */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">lsn_t</span> max_modified_age_sync;</span><br><span class="line"><span class="comment">/*!&lt; when this recommended value for lsn - buf_pool_get_oldest_modification() is exceeded, we start a synchronous preflush of pool pages */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">lsn_t</span> max_checkpoint_age_async;</span><br><span class="line"><span class="comment">/*!&lt; when this checkpoint age is exceeded we start an asynchronous writing of a new checkpoint */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">lsn_t</span> max_checkpoint_age;</span><br><span class="line"><span class="comment">/*!&lt; this is the maximum allowed value for lsn - last_checkpoint_lsn when a new query step is started */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ib_uint64_t</span> next_checkpoint_no;</span><br><span class="line"><span class="comment">/*!&lt; next checkpoint number */</span></span><br><span class="line"><span class="keyword">lsn_t</span> last_checkpoint_lsn;</span><br><span class="line"><span class="comment">/*!&lt; latest checkpoint lsn */</span></span><br><span class="line"><span class="keyword">lsn_t</span> next_checkpoint_lsn;</span><br><span class="line"><span class="comment">/*!&lt; next checkpoint lsn */</span></span><br><span class="line"><span class="keyword">mtr_buf_t</span>* append_on_checkpoint;</span><br><span class="line"><span class="comment">/*!&lt; extra redo log records to write during a checkpoint, or NULL if none. The pointer is protected by log_sys-&gt;mutex, and the data must remain constant as long as this pointer is not NULL. */</span></span><br><span class="line">ulint n_pending_checkpoint_writes;</span><br><span class="line"><span class="comment">/*!&lt; number of currently pending</span></span><br><span class="line"><span class="comment">checkpoint writes */</span></span><br><span class="line"><span class="keyword">rw_lock_t</span> checkpoint_lock;<span class="comment">/*!&lt; this latch is x-locked when a</span></span><br><span class="line"><span class="comment">checkpoint write is running; a thread</span></span><br><span class="line"><span class="comment">should wait for this without owning</span></span><br><span class="line"><span class="comment">the log mutex */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !UNIV_HOTBACKUP */</span></span></span><br><span class="line">byte* checkpoint_buf_ptr;<span class="comment">/* unaligned checkpoint header */</span></span><br><span class="line">byte* checkpoint_buf; <span class="comment">/*!&lt; checkpoint header is read to this buffer */</span></span><br><span class="line"><span class="comment">/* @&#125; */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="写入redo-buffer有关的函数"><a href="#写入redo-buffer有关的函数" class="headerlink" title="写入redo buffer有关的函数"></a>写入redo buffer有关的函数</h4><p>下面列出的函数仅和写入redo缓冲区有关，不涉及redo的写盘！<br><strong>log_write_low()</strong><br>函数伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">log_write_low(</span><br><span class="line"><span class="comment">/*==========*/</span></span><br><span class="line"><span class="keyword">const</span> byte* str, <span class="comment">/*!&lt; in: string */</span></span><br><span class="line">ulint str_len) <span class="comment">/*!&lt; in: string length */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">log_t</span>* <span class="built_in">log</span> = log_sys;</span><br><span class="line">ulint len;</span><br><span class="line">ulint data_len;</span><br><span class="line">byte* log_block;</span><br><span class="line"><span class="comment">//已经获得log_mutex锁</span></span><br><span class="line">part_loop：</span><br><span class="line"><span class="keyword">if</span> (待写入数据长度小于当前redo block的可用空间) &#123;</span><br><span class="line">可以一次性写入，将本次写入长度直接赋值为str_len</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">否则，分块写入，将本次写入长度设为当前redo block的可用空间大小</span><br><span class="line">&#125;</span><br><span class="line">将str对应的内存拷贝当前可写入长度的内容到redo block上</span><br><span class="line">设置该redo block的LOG_BLOCK_HDR_DATA_LEN值</span><br><span class="line"><span class="keyword">if</span> (当前redo block已满) &#123;</span><br><span class="line">设置当前redo block的checkpoin值，</span><br><span class="line">并重新初始化下一个block，待用。</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">log</span>-&gt;lsn += len;</span><br><span class="line">&#125;</span><br><span class="line">修改log_sys-&gt;buf_free，使其增加len。</span><br><span class="line">如果本次循环没写完str的内容，则<span class="keyword">goto</span>至part_loop继续写str剩余的内容。</span><br><span class="line">srv_stats.log_write_requests.inc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写入redo-file有关的函数"><a href="#写入redo-file有关的函数" class="headerlink" title="写入redo file有关的函数"></a>写入redo file有关的函数</h4><p>注意：下面的函数是关于redo log写盘的<br><strong>log_write_up_to()</strong><br><code>log_write_up_to() [log0log.cc, row 1209]</code> 是将redo log写盘至指定的log条目（lsn标记），该函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">log_write_up_to(</span><br><span class="line"><span class="keyword">lsn_t</span> lsn,</span><br><span class="line"><span class="keyword">bool</span> flush_to_disk)</span><br><span class="line">&#123;</span><br><span class="line">byte* write_buf;</span><br><span class="line"><span class="keyword">lsn_t</span> write_lsn;</span><br><span class="line"><span class="keyword">if</span> (recv_no_ibuf_operations) &#123;</span><br><span class="line"><span class="comment">/* 正在进行Recovery ，直接返回*/</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">loop:</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">log_write_mutex_enter();</span><br><span class="line"><span class="comment">//将limit_lsn设为当前已经写入的lsn值</span></span><br><span class="line"><span class="keyword">lsn_t</span> limit_lsn = flush_to_disk</span><br><span class="line">? log_sys-&gt;flushed_to_disk_lsn</span><br><span class="line">: log_sys-&gt;write_lsn;</span><br><span class="line"><span class="comment">//如果当前的limit_lsn大于等于要求写入的lsn，即传入lsn对应的redo log已经写盘，直接放锁返回。</span></span><br><span class="line"><span class="keyword">if</span> (limit_lsn &gt;= lsn) &#123;</span><br><span class="line">log_write_mutex_exit();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果limit_lsn &lt; lsn，即确实有数据要落盘，则进行写盘操作 */</span></span><br><span class="line"><span class="comment">/*如果有一个flush正在进行*/</span></span><br><span class="line"><span class="keyword">if</span> (flush_to_disk</span><br><span class="line">&amp;&amp; (log_sys-&gt;n_pending_flushes &gt; <span class="number">0</span></span><br><span class="line">|| !os_event_is_set(log_sys-&gt;flush_event))) &#123;</span><br><span class="line"><span class="comment">/* 看下当前flush任务能否将包含lsn的redo写盘 */</span></span><br><span class="line"><span class="keyword">bool</span> work_done = log_sys-&gt;current_flush_lsn &gt;= lsn;</span><br><span class="line">log_write_mutex_exit();</span><br><span class="line"><span class="comment">//无论能否包含都要等待当前的flush完成</span></span><br><span class="line">os_event_wait(log_sys-&gt;flush_event);</span><br><span class="line"><span class="comment">//如果当前的flush能将包含此lsn的redo写盘，则直接返回。</span></span><br><span class="line"><span class="keyword">if</span> (work_done) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//什么时候会出现这种情况？？？</span></span><br><span class="line">log_mutex_enter();</span><br><span class="line"><span class="keyword">if</span> (!flush_to_disk</span><br><span class="line">&amp;&amp; log_sys-&gt;buf_free == log_sys-&gt;buf_next_to_write) &#123;</span><br><span class="line"><span class="comment">/* Nothing to write and no flush to disk requested */</span></span><br><span class="line">log_mutex_exit_all();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是最后的情况，即没有正在运行的flush。则开始对传入的lsn进行写盘</span></span><br><span class="line"><span class="keyword">log_group_t</span>* group;</span><br><span class="line">ulint start_offset;</span><br><span class="line">ulint end_offset;</span><br><span class="line">ulint area_start;</span><br><span class="line">ulint area_end;</span><br><span class="line">ulong write_ahead_size = srv_log_write_ahead_size;</span><br><span class="line">ulint pad_size;</span><br><span class="line">DBUG_PRINT(<span class="string">"ib_log"</span>, (<span class="string">"write "</span> LSN_PF <span class="string">" to "</span> LSN_PF,</span><br><span class="line">log_sys-&gt;write_lsn,</span><br><span class="line">log_sys-&gt;lsn));</span><br><span class="line"><span class="keyword">if</span> (flush_to_disk) &#123;</span><br><span class="line">log_sys-&gt;n_pending_flushes++;</span><br><span class="line">log_sys-&gt;current_flush_lsn = log_sys-&gt;lsn;</span><br><span class="line">MONITOR_INC(MONITOR_PENDING_LOG_FLUSH);</span><br><span class="line">os_event_reset(log_sys-&gt;flush_event);</span><br><span class="line"><span class="keyword">if</span> (log_sys-&gt;buf_free == log_sys-&gt;buf_next_to_write) &#123;</span><br><span class="line"><span class="comment">/* Nothing to write, flush only */</span></span><br><span class="line">log_mutex_exit_all();</span><br><span class="line">log_write_flush_to_disk_low();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">start_offset = log_sys-&gt;buf_next_to_write;</span><br><span class="line">end_offset = log_sys-&gt;buf_free;</span><br><span class="line">area_start = ut_calc_align_down(start_offset, OS_FILE_LOG_BLOCK_SIZE);</span><br><span class="line">area_end = ut_calc_align(end_offset, OS_FILE_LOG_BLOCK_SIZE);</span><br><span class="line">ut_ad(area_end - area_start &gt; <span class="number">0</span>);</span><br><span class="line">log_block_set_flush_bit(log_sys-&gt;buf + area_start, TRUE);</span><br><span class="line">log_block_set_checkpoint_no(</span><br><span class="line">log_sys-&gt;buf + area_end - OS_FILE_LOG_BLOCK_SIZE,</span><br><span class="line">log_sys-&gt;next_checkpoint_no);</span><br><span class="line">write_lsn = log_sys-&gt;lsn;</span><br><span class="line">write_buf = log_sys-&gt;buf;</span><br><span class="line">log_buffer_switch();</span><br><span class="line">group = UT_LIST_GET_FIRST(log_sys-&gt;log_groups);</span><br><span class="line">log_group_set_fields(group, log_sys-&gt;write_lsn);</span><br><span class="line">log_mutex_exit();</span><br><span class="line"><span class="comment">/* Calculate pad_size if needed. */</span></span><br><span class="line">pad_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (write_ahead_size &gt; OS_FILE_LOG_BLOCK_SIZE) &#123;</span><br><span class="line"><span class="keyword">lsn_t</span> end_offset;</span><br><span class="line">ulint end_offset_in_unit;</span><br><span class="line">end_offset = log_group_calc_lsn_offset(</span><br><span class="line">ut_uint64_align_up(write_lsn,</span><br><span class="line">OS_FILE_LOG_BLOCK_SIZE),</span><br><span class="line">group);</span><br><span class="line">end_offset_in_unit = (ulint) (end_offset % write_ahead_size);</span><br><span class="line"><span class="keyword">if</span> (end_offset_in_unit &gt; <span class="number">0</span></span><br><span class="line">&amp;&amp; (area_end - area_start) &gt; end_offset_in_unit) &#123;</span><br><span class="line"><span class="comment">/* The first block in the unit was initialized after the last writing.Needs to be written padded data once. */</span></span><br><span class="line">pad_size = write_ahead_size - end_offset_in_unit;</span><br><span class="line"><span class="keyword">if</span> (area_end + pad_size &gt; log_sys-&gt;buf_size) &#123;</span><br><span class="line">pad_size = log_sys-&gt;buf_size - area_end;</span><br><span class="line">&#125;</span><br><span class="line">::<span class="built_in">memset</span>(write_buf + area_end, <span class="number">0</span>, pad_size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Do the write to the log files */</span></span><br><span class="line">log_group_write_buf(</span><br><span class="line">group, write_buf + area_start,</span><br><span class="line">area_end - area_start + pad_size,</span><br><span class="line">#ifdef UNIV_DEBUG</span><br><span class="line">pad_size,</span><br><span class="line">#endif <span class="comment">/* UNIV_DEBUG */</span></span><br><span class="line">ut_uint64_align_down(log_sys-&gt;write_lsn,</span><br><span class="line">OS_FILE_LOG_BLOCK_SIZE),</span><br><span class="line">start_offset - area_start);</span><br><span class="line">srv_stats.log_padded.add(pad_size);</span><br><span class="line">log_sys-&gt;write_lsn = write_lsn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="keyword">if</span> (srv_unix_file_flush_method == SRV_UNIX_O_DSYNC) &#123;</span><br><span class="line"><span class="comment">/* O_SYNC means the OS did not buffer the log file at all: so we have also flushed to disk what we have written */</span></span><br><span class="line"></span><br><span class="line">log_sys-&gt;flushed_to_disk_lsn = log_sys-&gt;write_lsn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !_WIN32 */</span></span></span><br><span class="line">log_write_mutex_exit();</span><br><span class="line"><span class="keyword">if</span> (flush_to_disk) &#123;</span><br><span class="line">log_write_flush_to_disk_low();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mini‑transaction-mtr"><a href="#mini‑transaction-mtr" class="headerlink" title="mini‑transaction(mtr)"></a>mini‑transaction(mtr)</h4><p>一个事务会用多个mtr来提交产生的redo日志到redo log buf。具体来说，<code>mtr_commit(mtr)</code>时，会将<code>mtr_t‑&gt;m_impl‑&gt;m_log</code>日志的内容复制到redo log buf中。其函数调用顺序为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mtr_t::commit();</span><br><span class="line">		mtr_t::Command();</span><br><span class="line">			mtr_t::Command::execute();</span><br><span class="line">				mtr_t::Command::prepare_write();</span><br><span class="line">				mtr_t::Command::finish_write();</span><br></pre></td></tr></table></figure>
<p>另外，mini‑transaction只负责将redo log从自身复制到redo log buf，持久化的工作（redo刷盘）由其他程序负责（如事务提交）。下面开始阅读和mtr提交redo日志相关的代码，主要是 <code>prepare_write()</code> 和<code>finish_write()</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/** Prepare to write the mini-transaction log to the redo log buffer.@return number of bytes to write in finish_write() */</span><br><span class="line"></span><br><span class="line">ulint</span><br><span class="line">mtr_t::Command::prepare_write()</span><br><span class="line">&#123;</span><br><span class="line">switch (m_impl-&gt;m_log_mode) &#123;</span><br><span class="line">case MTR_LOG_NONE选项开启</span><br><span class="line">直接返回0，即不写redo;</span><br><span class="line">case MTR_LOG_ALL:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">ulint len = mtr中redo日志大小-&gt;m_log.size();</span><br><span class="line">ulint n_recs = m_impl-&gt;m_n_log_recs;</span><br><span class="line">if (len长度超过redo buf缓冲区大小的1/2) &#123;</span><br><span class="line">log_buffer_extend((len + 1) * 2); //进行缓冲区扩展，因为在当前redo buf使用空间</span><br><span class="line">//没到1/2时不会被flush，所以当本次mtr的redo</span><br><span class="line">//log长度大于buf的1/2时，可能会写不下，防止</span><br><span class="line">//缓冲区溢出而进行扩展。</span><br><span class="line">&#125;</span><br><span class="line">fil_space_t* space = m_impl-&gt;m_user_space;</span><br><span class="line">if (space != NULL &amp;&amp; is_system_or_undo_tablespace(space-&gt;id)) &#123;</span><br><span class="line">/* Omit MLOG_FILE_NAME for predefined tablespaces. */</span><br><span class="line">space = NULL;</span><br><span class="line">&#125;</span><br><span class="line">log_mutex_enter();</span><br><span class="line">//下面的逻辑注意看下,MLOG_FILE_NAME是什么意思？</span><br><span class="line">if (fil_names_write_if_was_clean(space, m_impl-&gt;m_mtr)) &#123;</span><br><span class="line">/* This mini-transaction was the first one to modify this tablespace since the latest checkpoint, so some MLOG_FILE_NAME records were appended to m_log. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ut_ad(m_impl-&gt;m_n_log_recs &gt; n_recs);</span><br><span class="line">mlog_catenate_ulint(</span><br><span class="line">&amp;m_impl-&gt;m_log, MLOG_MULTI_REC_END, MLOG_1BYTE);</span><br><span class="line">len = m_impl-&gt;m_log.size();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">/* This was not the first time of dirtying a</span><br><span class="line">tablespace since the latest checkpoint. */</span><br><span class="line">if (n_recs &lt;= 1) &#123;</span><br><span class="line">ut_ad(n_recs == 1);</span><br><span class="line">/* Flag the single log record as the</span><br><span class="line">only record in this mini-transaction. */</span><br><span class="line">*m_impl-&gt;m_log.front()-&gt;begin()</span><br><span class="line">|= MLOG_SINGLE_REC_FLAG;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">/* Because this mini-transaction comprises multiple log records, append MLOG_MULTI_REC_END at the end. */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mlog_catenate_ulint(</span><br><span class="line">&amp;m_impl-&gt;m_log, MLOG_MULTI_REC_END,</span><br><span class="line">MLOG_1BYTE);</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 尝试推进检查点 */</span><br><span class="line">log_margin_checkpoint_age(len);</span><br><span class="line">return(len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/** Append the redo log records to the redo log buffer @param[in] len number of bytes to write */</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">mtr_t::Command::finish_write(</span><br><span class="line">ulint len)</span><br><span class="line">&#123;</span><br><span class="line">if (m_impl-&gt;m_log.is_small()) &#123;</span><br><span class="line">const mtr_buf_t::block_t* front = m_impl-&gt;m_log.front();</span><br><span class="line">//如果当前日志小于512K则尝试用memcpy写入redo log buf</span><br><span class="line">m_end_lsn = log_reserve_and_write_fast(</span><br><span class="line">front-&gt;begin(), len, &amp;m_start_lsn);</span><br><span class="line">//m_end_lsn&gt;0表示写成功。</span><br><span class="line">if (m_end_lsn &gt; 0) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 如果当前redo log大于一个block的大小 */</span><br><span class="line">m_start_lsn = log_reserve_and_open(len);</span><br><span class="line">mtr_write_log_t write_log;</span><br><span class="line">//调用log_write_low()逐块写入redo log buf</span><br><span class="line">m_impl-&gt;m_log.for_each_block(write_log);</span><br><span class="line">m_end_lsn = log_close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日志文件组-struct-log-group-t"><a href="#日志文件组-struct-log-group-t" class="headerlink" title="日志文件组 (struct log_group_t)"></a>日志文件组 (struct log_group_t)</h4><p>日志文件组是由几个大小相同的文件组成的一组文件，这几个文件用于循环写入redo log buf的内容以持久化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Log group consists of a number of log files, each of the same size; a log group is implemented as a space in the sense of the module fil0fil.Currently, this is only protected by log_sys-&gt;mutex. However, in the case of log_write_up_to(), we will access some members only with the protection of log_sys-&gt;write_mutex, which should affect nothing for now. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log_group_t</span>&#123;</span></span><br><span class="line"><span class="comment">/** 组id，因为5.7只有一个日志文件组，所以永远是0 */</span></span><br><span class="line">ulint id;</span><br><span class="line"><span class="comment">/** 组文件个数*/</span></span><br><span class="line">ulint n_files;</span><br><span class="line"><span class="comment">/** format of the redo log: e.g., LOG_HEADER_FORMAT_CURRENT */</span></span><br><span class="line">ulint format;</span><br><span class="line"><span class="comment">/** 单个文件大小（单位字节） */</span></span><br><span class="line"><span class="keyword">lsn_t</span> file_size</span><br><span class="line"><span class="comment">/** file space which implements the log group */</span>;</span><br><span class="line">ulint space_id;</span><br><span class="line"><span class="comment">/** corruption status */</span></span><br><span class="line"><span class="keyword">log_group_state_t</span> state;</span><br><span class="line"><span class="comment">/** lsn used to fix coordinates within the log group */</span></span><br><span class="line"><span class="keyword">lsn_t</span> lsn;</span><br><span class="line"><span class="comment">/** the byte offset of the above lsn */</span></span><br><span class="line"><span class="keyword">lsn_t</span> lsn_offset;</span><br><span class="line"><span class="comment">/** unaligned buffers */</span></span><br><span class="line">byte** file_header_bufs_ptr;</span><br><span class="line"><span class="comment">/** buffers for each file header in the group */</span></span><br><span class="line">byte** file_header_bufs;</span><br><span class="line"><span class="comment">/** used only in recovery: recovery scan succeeded up to this</span></span><br><span class="line"><span class="comment">lsn in this log group */</span></span><br><span class="line"><span class="keyword">lsn_t</span> scanned_lsn;</span><br><span class="line"><span class="comment">/** unaligned checkpoint header */</span></span><br><span class="line">byte* checkpoint_buf_ptr;</span><br><span class="line"><span class="comment">/** buffer for writing a checkpoint header */</span></span><br><span class="line">byte* checkpoint_buf;</span><br><span class="line"><span class="comment">/** 日志组链表，为空 */</span></span><br><span class="line">UT_LIST_NODE_T(<span class="keyword">log_group_t</span>) log_groups;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="srv-master-thread-线程"><a href="#srv-master-thread-线程" class="headerlink" title="srv_master_thread()线程"></a>srv_master_thread()线程</h4><p>master线程<code>[srv0srv.cc,row 2339]</code>是innodb主线程，下面阅读一下代码梳理其大致流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/*********************************************************************/</span><br><span class="line">/**The master thread controlling the server. @return a dummy parameter */</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">os_thread_ret_t</span><br><span class="line">DECLARE_THREAD(srv_master_thread)(</span><br><span class="line">/*==============================*/</span><br><span class="line">void* arg MY_ATTRIBUTE((unused)))</span><br><span class="line">/*!&lt; in: a dummy parameter required by</span><br><span class="line">os_thread_create */</span><br><span class="line">&#123;</span><br><span class="line">//初始化;</span><br><span class="line">srv_slot_t* slot;</span><br><span class="line">ulint old_activity_count = srv_get_activity_count();</span><br><span class="line">ib_time_t last_print_time;</span><br><span class="line">//注册当前线程到performance schema</span><br><span class="line">pfs_register_thread(srv_master_thread_key);</span><br><span class="line">//下面两个都是获取线程id，第一个直接用线程号，第二个将一个结构变量转成ulint</span><br><span class="line">srv_main_thread_process_no = os_proc_get_number();</span><br><span class="line">srv_main_thread_id = os_thread_pf(os_thread_get_curr_id());</span><br><span class="line">//分配一个slot，slot相当于thread table的一个表项，thread table后面阅读</span><br><span class="line">slot = srv_reserve_slot(SRV_MASTER);</span><br><span class="line">//下面的循环包括master thread开始与结束，和正常工作的循环。</span><br><span class="line">loop:</span><br><span class="line">if (srv_force_recovery &gt;= SRV_FORCE_NO_BACKGROUND) &#123;</span><br><span class="line">goto suspend_thread;</span><br><span class="line">&#125;</span><br><span class="line">/* 下面的循环为正常工作时的循环，@&#123;*/</span><br><span class="line">while (srv_shutdown_state == SRV_SHUTDOWN_NONE) &#123;</span><br><span class="line">//线程先sleep 1s</span><br><span class="line">srv_master_sleep();</span><br><span class="line">MONITOR_INC(MONITOR_MASTER_THREAD_SLEEP);</span><br><span class="line">//activity_count是由谁来更新？？</span><br><span class="line">if (当前为活动状态) &#123;</span><br><span class="line">//更新计数器，用srv_sys-&gt;activity_count来赋值</span><br><span class="line">old_activity_count = srv_get_activity_count();</span><br><span class="line">//进行active_task</span><br><span class="line">srv_master_do_active_tasks();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//进行idle_task</span><br><span class="line">srv_master_do_idle_tasks();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* @&#125;*/</span><br><span class="line">...</span><br><span class="line">suspend_thread:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>srv_master_do_active_tasks()</strong><br>下面分别看一下 <code>srv_master_do_active_tasks()</code> 和 <code>srv_master_do_idle_tasks()</code> 两个函数，首先看第一个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************/</span></span><br><span class="line"><span class="comment">/**Perform the tasks that the master thread is supposed to do when the server is active. There are two types of tasks. The first category is of such tasks which are performed at each inovcation of this function.We assume that this function is called roughly every second when the server is active. The second category is of such tasks which are performed at some interval e.g.: purge, dict_LRU cleanup etc. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">srv_master_do_active_tasks(<span class="keyword">void</span>)</span><br><span class="line"><span class="comment">/*============================*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ib_time_t</span> cur_time = ut_time();</span><br><span class="line"><span class="keyword">uintmax_t</span> counter_time = ut_time_us(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//首先增加此变量，记录该函数调用了多少次，srv_main_active_loops为全局变量</span></span><br><span class="line">++srv_main_active_loops;</span><br><span class="line">MONITOR_INC(MONITOR_MASTER_ACTIVE_LOOPS);</span><br><span class="line"><span class="comment">/* 如果有ALTER TABLE查询，现在进行真正的alter table操作 */</span></span><br><span class="line">srv_main_thread_op_info = <span class="string">"doing background drop tables"</span>;</span><br><span class="line">row_drop_tables_for_mysql_in_background();</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line">MONITOR_SRV_BACKGROUND_DROP_TABLE_MICROSECOND, counter_time);</span><br><span class="line"><span class="keyword">if</span> (srv_shutdown_state &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 检查redo log file可重用空间是否足够 */</span></span><br><span class="line">srv_main_thread_op_info = <span class="string">"checking free log space"</span>;</span><br><span class="line">log_free_check();</span><br><span class="line"><span class="comment">/* 进行insert buffer的merge，后面详细阅读 */</span></span><br><span class="line">srv_main_thread_op_info = <span class="string">"doing insert buffer merge"</span>;</span><br><span class="line">counter_time = ut_time_us(<span class="literal">NULL</span>);</span><br><span class="line">ibuf_merge_in_background(<span class="literal">false</span>);</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line">MONITOR_SRV_IBUF_MERGE_MICROSECOND, counter_time);</span><br><span class="line"><span class="comment">/* 进行redo log的刷盘 */</span></span><br><span class="line">srv_main_thread_op_info = <span class="string">"flushing log"</span>;</span><br><span class="line">srv_sync_log_buffer_in_background();</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line">MONITOR_SRV_LOG_FLUSH_MICROSECOND, counter_time);</span><br><span class="line"><span class="comment">/* 上面的函数每次执行时都会调用，下面的根据cur_time的时间决定是否执行*/</span></span><br><span class="line"><span class="comment">//下面给两个if 不知道什么意思</span></span><br><span class="line"><span class="keyword">if</span> (srv_shutdown_state &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (srv_shutdown_state &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每47s执行一次，执行一次table cache的清理</span></span><br><span class="line"><span class="keyword">if</span> (cur_time % SRV_MASTER_DICT_LRU_INTERVAL == <span class="number">0</span>) &#123;</span><br><span class="line">srv_main_thread_op_info = <span class="string">"enforcing dict cache limit"</span>;</span><br><span class="line">ulint n_evicted = srv_master_evict_from_table_cache(<span class="number">50</span>);</span><br><span class="line"><span class="keyword">if</span> (n_evicted != <span class="number">0</span>) &#123;</span><br><span class="line">MONITOR_INC_VALUE(</span><br><span class="line">MONITOR_SRV_DICT_LRU_EVICT_COUNT, n_evicted);</span><br><span class="line">&#125;</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line">MONITOR_SRV_DICT_LRU_MICROSECOND, counter_time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (srv_shutdown_state &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每7s进行一次checkpoint</span></span><br><span class="line"><span class="keyword">if</span> (cur_time % SRV_MASTER_CHECKPOINT_INTERVAL == <span class="number">0</span>) &#123;</span><br><span class="line">srv_main_thread_op_info = <span class="string">"making checkpoint"</span>;</span><br><span class="line">log_checkpoint(TRUE, FALSE);</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line">MONITOR_SRV_CHECKPOINT_MICROSECOND, counter_time);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>srv_master_do_idle_tasks()</strong><br>接着看一下 <code>srv_master_do_idle_tasks()</code> 函数，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************/</span></span><br><span class="line"><span class="comment">/*当master thread进入shutdown state时退出此函数；执行此函数时不会在意此时master thread是否由idle转为active状态 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">srv_master_do_idle_tasks(<span class="keyword">void</span>)</span><br><span class="line"><span class="comment">/*==========================*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uintmax_t</span> counter_time;</span><br><span class="line">++srv_main_idle_loops;</span><br><span class="line">MONITOR_INC(MONITOR_MASTER_IDLE_LOOPS);</span><br><span class="line"><span class="comment">/* 进行实际的ALTER TABLE操作，和上面的active_task函数一样 */</span></span><br><span class="line">counter_time = ut_time_us(<span class="literal">NULL</span>);</span><br><span class="line">srv_main_thread_op_info = <span class="string">"doing background drop tables"</span>;</span><br><span class="line">row_drop_tables_for_mysql_in_background();</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line">MONITOR_SRV_BACKGROUND_DROP_TABLE_MICROSECOND,</span><br><span class="line">counter_time);</span><br><span class="line"><span class="keyword">if</span> (srv_shutdown_state &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 检查redo log file空间是否足够 */</span></span><br><span class="line">srv_main_thread_op_info = <span class="string">"checking free log space"</span>;</span><br><span class="line">log_free_check();</span><br><span class="line"><span class="comment">/* 进行insert buf的merge */</span></span><br><span class="line">counter_time = ut_time_us(<span class="literal">NULL</span>);</span><br><span class="line">srv_main_thread_op_info = <span class="string">"doing insert buffer merge"</span>;</span><br><span class="line">ibuf_merge_in_background(<span class="literal">true</span>);</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line">MONITOR_SRV_IBUF_MERGE_MICROSECOND, counter_time);</span><br><span class="line"><span class="keyword">if</span> (srv_shutdown_state &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行一次table cache的清理</span></span><br><span class="line">srv_main_thread_op_info = <span class="string">"enforcing dict cache limit"</span>;</span><br><span class="line">ulint n_evicted = srv_master_evict_from_table_cache(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (n_evicted != <span class="number">0</span>) &#123;</span><br><span class="line">MONITOR_INC_VALUE(</span><br><span class="line">MONITOR_SRV_DICT_LRU_EVICT_COUNT, n_evicted);</span><br><span class="line">&#125;</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line">MONITOR_SRV_DICT_LRU_MICROSECOND, counter_time);</span><br><span class="line"><span class="comment">/* redo log刷盘 */</span></span><br><span class="line">srv_sync_log_buffer_in_background();</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(</span><br><span class="line">MONITOR_SRV_LOG_FLUSH_MICROSECOND, counter_time);</span><br><span class="line"><span class="keyword">if</span> (srv_shutdown_state &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 做checkpoint */</span></span><br><span class="line">srv_main_thread_op_info = <span class="string">"making checkpoint"</span>;</span><br><span class="line">log_checkpoint(TRUE, FALSE);</span><br><span class="line">MONITOR_INC_TIME_IN_MICRO_SECS(MONITOR_SRV_CHECKPOINT_MICROSECOND,</span><br><span class="line">counter_time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>master thread在active和idle状态下工作方式差异</p>
<ul>
<li>相同点<ul>
<li>master thread在两种状态下的所做的工作内容相同</li>
</ul>
</li>
<li>不同点<ul>
<li>当master thread处于active状态时，刷table cache和做checkpoint不是每次都进行的，而是有单独的时间间隔（比如checkpoint是7s一次）。而处于idle状态时则每次都要进行上述工作。</li>
</ul>
</li>
</ul>
<h4 id="master-thread中有关redo-log相关的工作"><a href="#master-thread中有关redo-log相关的工作" class="headerlink" title="master thread中有关redo log相关的工作"></a>master thread中有关redo log相关的工作</h4><p>master thread中的三部分内容和redo log直接相关分别是：</p>
<ul>
<li>进行redo log file空间检查： <code>log_free_check() ；</code><ul>
<li>在当前redo log buf空闲空间小于1/2时，将buf中的内容刷盘至<code>log_sys‑&gt;lsn</code>；</li>
<li>检查是否到checkpoint，redo log file空间是否足够，哪一个不满足做哪一个。</li>
</ul>
</li>
<li>进行redo log buf刷盘： <code>srv_sync_log_buffer_in_background()</code> ；</li>
<li>每1s将redo log刷盘一次，注释上写的是为了避免当选项innodb_flush_logs_at_trx_commit != 1时，系统崩溃丢失不多于1s的事务信息。</li>
<li>进行checkpoint： <code>log_checkpoint(TRUE,FALSE)</code><ul>
<li>推进checkpoint。另外，在函数注释中此函数 不进行redo buf刷盘的，但在实现时可能会刷盘，而且记录checkpoint。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>log_sys­&gt;next_checkpoint_no</code> 的一个用途是在做checkpoint时，根据其最后一位决定写入redo file header中第一个checkpoint block或第二个checkpoint block。</p>
</blockquote>
<h4 id="checkpoint写盘的细节"><a href="#checkpoint写盘的细节" class="headerlink" title="checkpoint写盘的细节"></a>checkpoint写盘的细节</h4><p>在进行checkpoint时，需要写两部分内容，一是redo log，存在log block中，二是更新ib_logfile0头部的Checkpoint block，下面分别看下这两部分。</p>
<ul>
<li>写redo log file头部的checkpoint block的函数有：<ul>
<li><code>log_write_checkpoint_info()</code>，调用下面的函数，其作用是控制是同步写还是异步写；</li>
<li><code>log_group_checkpoint()</code>，进行实际的checkpoint block写盘。<br><code>log_group_checkpoint()</code>，此函数将checkpoint的信息写入<code>ib_logfile0</code>头部的Checkpoint block中，注意只是写头部的checkpoint block。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************/</span><span class="comment">/**Writes the checkpoint info to a log group header. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">log_group_checkpoint(</span><br><span class="line"><span class="comment">/*=================*/</span></span><br><span class="line"><span class="keyword">log_group_t</span>* group) <span class="comment">/*!&lt; in: log group */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">lsn_t</span> lsn_offset;</span><br><span class="line">byte* buf;</span><br><span class="line">buf = group-&gt;checkpoint_buf;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, OS_FILE_LOG_BLOCK_SIZE);</span><br><span class="line"><span class="comment">//写 Checkpoint block内容：LOG_CHECKPOINT_NO、LOG_CHECKPOINT_LSN</span></span><br><span class="line">mach_write_to_8(buf + LOG_CHECKPOINT_NO, log_sys-&gt;next_checkpoint_no);</span><br><span class="line">mach_write_to_8(buf + LOG_CHECKPOINT_LSN, log_sys-&gt;next_checkpoint_lsn);</span><br><span class="line"><span class="comment">//写 Checkpoint block内容：LOG_CHECKPOINT_OFFSET、LOG_CHECKPOINT_LOG_BUF_SIZE</span></span><br><span class="line"><span class="comment">//LOG_CHECKPOINT_OFFSET的细节见ppt</span></span><br><span class="line">lsn_offset = log_group_calc_lsn_offset(log_sys-&gt;next_checkpoint_lsn,</span><br><span class="line">group);</span><br><span class="line">mach_write_to_8(buf + LOG_CHECKPOINT_OFFSET, lsn_offset);</span><br><span class="line">mach_write_to_8(buf + LOG_CHECKPOINT_LOG_BUF_SIZE, log_sys-&gt;buf_size);</span><br><span class="line"><span class="comment">//计算block的checksum</span></span><br><span class="line">log_block_set_checksum(buf, log_block_calc_checksum_crc32(buf));</span><br><span class="line">MONITOR_INC(MONITOR_PENDING_CHECKPOINT_WRITE);</span><br><span class="line">log_sys-&gt;n_log_ios++;</span><br><span class="line">MONITOR_INC(MONITOR_LOG_IO);</span><br><span class="line"><span class="keyword">if</span> (log_sys-&gt;n_pending_checkpoint_writes++ == <span class="number">0</span>) &#123;</span><br><span class="line">rw_lock_x_lock_gen(&amp;log_sys-&gt;checkpoint_lock,</span><br><span class="line">LOG_CHECKPOINT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Note: 根据log_sys-&gt;next_checkpoint_no的最低位决定写哪一个checkpoint block */</span></span><br><span class="line"><span class="comment">/* We send as the last parameter the group machine address file write and a checkpoint field write */</span></span><br><span class="line"></span><br><span class="line">fil_io(IORequestLogWrite, <span class="literal">false</span>,</span><br><span class="line"><span class="keyword">page_id_t</span>(group-&gt;space_id, <span class="number">0</span>),</span><br><span class="line">univ_page_size,</span><br><span class="line">(log_sys-&gt;next_checkpoint_no &amp; <span class="number">1</span>)</span><br><span class="line">? LOG_CHECKPOINT_2 : LOG_CHECKPOINT_1,</span><br><span class="line">OS_FILE_LOG_BLOCK_SIZE,</span><br><span class="line">buf, (byte*) group + <span class="number">1</span>);</span><br><span class="line">ut_ad(((ulint) group &amp; <span class="number">0x1</span>UL) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="srv-purge-coordinator-thread-线程"><a href="#srv-purge-coordinator-thread-线程" class="headerlink" title="srv_purge_coordinator_thread()线程"></a>srv_purge_coordinator_thread()线程</h4><p>purge线程<code>[srv0srv.cc ,row 2753]</code>用于完成最后的update和delete，包括最终数据的删除和修改，以及undo page的回收。有几个问题：</p>
<ul>
<li>purge线程和main_thread如何交互？</li>
<li>purge线程和page_cleaner线程如何交互？</li>
<li>purge完成的细节.</li>
</ul>
<p>首先看一下 <code>srv_purge_coordinator_thread()</code> 的代码：</p>
<h4 id="buf-flush-page-cleaner-coordinator-线程"><a href="#buf-flush-page-cleaner-coordinator-线程" class="headerlink" title="buf_flush_page_cleaner_coordinator()线程"></a>buf_flush_page_cleaner_coordinator()线程</h4><p>page clean线程<code>[buf0flu.cc row 3094]</code>用于脏页的刷盘，下面阅读其代码：</p>
<ul>
<li>“伪共享”问题<br>“伪共享”是由于CPU预取内存到L1缓存时，会按Cache line的size加载数据而出现的问题。例如，当同一个Cache line中存在两个线程分别需要写入的两个变量，而这两个线程分别运行于不同核心上，就会出现“伪共享”问题，降低程序效率。⸺解决办法为Cache line填充。<br><a href="http://ifeve.com/disruptor-cacheline-padding/" target="_blank" rel="noopener">剖析Disruptor:为什么会这么快？（二）神奇的缓存行填充</a></li>
</ul>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/03/01/Oracle 12c 的使用和学习/" class="pre">Oracle 12c 的使用和学习</a><a href="/2019/03/01/跟踪innodb_flush_method代码/" class="next">跟踪innodb_flush_method代码</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#事务进阶"><span class="toc-text">事务进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跟踪SQL语句"><span class="toc-text">跟踪SQL语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#尝试跟踪一条select语句"><span class="toc-text">尝试跟踪一条select语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跟踪事务流程"><span class="toc-text">跟踪事务流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#trx-pool-init函数阅读"><span class="toc-text">trx_pool_init函数阅读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trx-pools类型阅读"><span class="toc-text">trx_pools类型阅读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行一个UPDATE的函数调用"><span class="toc-text">执行一个UPDATE的函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mtr和trx联系"><span class="toc-text">mtr和trx联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNDO日志"><span class="toc-text">UNDO日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务流程分析"><span class="toc-text">事务流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实验一：包含select、update和insert的事务执行"><span class="toc-text">实验一：包含select、update和insert的事务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BEGIN；"><span class="toc-text">BEGIN；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SELECT-FROM-trx-WHERE-pk-1"><span class="toc-text">SELECT * FROM trx WHERE pk = 1;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UPDATE-trx-set-data-data-1-where-pk-1"><span class="toc-text">UPDATE trx set data = data +1 where pk = 1;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#INSERT-INTO-trx-VALUES-6-1"><span class="toc-text">INSERT INTO trx VALUES(6,1);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COMMIT"><span class="toc-text">COMMIT;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadView-MVCC-again"><span class="toc-text">ReadView(MVCC) again</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReadView"><span class="toc-text">ReadView</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XA-2PC-and-binlog-in-MySQL"><span class="toc-text">XA (2PC)and binlog in MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-内部XA事务与binlog"><span class="toc-text">MySQL 内部XA事务与binlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务中的UNDO部分"><span class="toc-text">事务中的UNDO部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何基于undo记录savepoint"><span class="toc-text">如何基于undo记录savepoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trx-in-handler-layer"><span class="toc-text">trx in handler layer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#部分常量释义"><span class="toc-text">部分常量释义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redo-log及其缓冲区代码阅读记录"><span class="toc-text">Redo log及其缓冲区代码阅读记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redo-log-buffer阅读"><span class="toc-text">Redo log buffer阅读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写入redo-buffer有关的函数"><span class="toc-text">写入redo buffer有关的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写入redo-file有关的函数"><span class="toc-text">写入redo file有关的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mini‑transaction-mtr"><span class="toc-text">mini‑transaction(mtr)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#日志文件组-struct-log-group-t"><span class="toc-text">日志文件组 (struct log_group_t)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#srv-master-thread-线程"><span class="toc-text">srv_master_thread()线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#master-thread中有关redo-log相关的工作"><span class="toc-text">master thread中有关redo log相关的工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkpoint写盘的细节"><span class="toc-text">checkpoint写盘的细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#srv-purge-coordinator-thread-线程"><span class="toc-text">srv_purge_coordinator_thread()线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buf-flush-page-cleaner-coordinator-线程"><span class="toc-text">buf_flush_page_cleaner_coordinator()线程</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（三）——valgrind/">性能分析工具（三）——valgrind</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（二）——perf/">性能分析工具（二）——perf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/MysqlTuner使用/MysqlTuner使用/">MysqlTuner使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/性能分析工具（一）——gprof/">性能分析工具（一）——gprof</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/Oracle 12c 的使用和学习/">Oracle 12c 的使用和学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/事务进阶/">事务进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/跟踪innodb_flush_method代码/">跟踪innodb_flush_method代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/SSD与数据库/">SSD与数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/Percona源码安装/">Percona源码安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/01/Linux环境下源码安装Mysql/">Linux环境下源码安装Mysql</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能分析/">性能分析</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Stockdean Mu.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>